//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using DslModeling = global::Microsoft.VisualStudio.Modeling;
using DslDiagrams = global::Microsoft.VisualStudio.Modeling.Diagrams;

namespace Castle.ActiveWriter
{
	/// <summary>
	/// Serializer ModelSerializer for DomainClass Model.
	/// </summary>
	public partial class ModelSerializer : DslModeling::DomainClassXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// ModelSerializer Constructor
		/// </summary>
		public ModelSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of Model.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"model"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of Model.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"modelMoniker"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of Model in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"Id"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one Model instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the Model element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory Model instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					ActiveWriterSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							ActiveWriterSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory Model instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			Model instanceOfModel = element as Model;
			global::System.Diagnostics.Debug.Assert(instanceOfModel != null, "Expecting an instance of Model");
	
			// UseNullables
			if (!serializationContext.Result.Failed)
			{
				string attribUseNullables = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "useNullables");
				if (attribUseNullables != null)
				{
					NullableUsage valueOfUseNullables;
					if (DslModeling::SerializationUtilities.TryGetValue<NullableUsage>(serializationContext, attribUseNullables, out valueOfUseNullables))
					{
						instanceOfModel.UseNullables = valueOfUseNullables;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "useNullables", typeof(NullableUsage), attribUseNullables);
					}
				}
			}
			// CaseOfPrivateFields
			if (!serializationContext.Result.Failed)
			{
				string attribCaseOfPrivateFields = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "caseOfPrivateFields");
				if (attribCaseOfPrivateFields != null)
				{
					FieldCase valueOfCaseOfPrivateFields;
					if (DslModeling::SerializationUtilities.TryGetValue<FieldCase>(serializationContext, attribCaseOfPrivateFields, out valueOfCaseOfPrivateFields))
					{
						instanceOfModel.CaseOfPrivateFields = valueOfCaseOfPrivateFields;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "caseOfPrivateFields", typeof(FieldCase), attribCaseOfPrivateFields);
					}
				}
			}
			// GenerateMonoRailProject
			if (!serializationContext.Result.Failed)
			{
				string attribGenerateMonoRailProject = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "generateMonoRailProject");
				if (attribGenerateMonoRailProject != null)
				{
					global::System.Boolean valueOfGenerateMonoRailProject;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribGenerateMonoRailProject, out valueOfGenerateMonoRailProject))
					{
						instanceOfModel.GenerateMonoRailProject = valueOfGenerateMonoRailProject;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "generateMonoRailProject", typeof(global::System.Boolean), attribGenerateMonoRailProject);
					}
				}
			}
			// MonoRailProjectName
			if (!serializationContext.Result.Failed)
			{
				string attribMonoRailProjectName = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "monoRailProjectName");
				if (attribMonoRailProjectName != null)
				{
					global::System.String valueOfMonoRailProjectName;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribMonoRailProjectName, out valueOfMonoRailProjectName))
					{
						instanceOfModel.MonoRailProjectName = valueOfMonoRailProjectName;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "monoRailProjectName", typeof(global::System.String), attribMonoRailProjectName);
					}
				}
			}
			// MonoRailProjectPath
			if (!serializationContext.Result.Failed)
			{
				string attribMonoRailProjectPath = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "monoRailProjectPath");
				if (attribMonoRailProjectPath != null)
				{
					global::System.String valueOfMonoRailProjectPath;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribMonoRailProjectPath, out valueOfMonoRailProjectPath))
					{
						instanceOfModel.MonoRailProjectPath = valueOfMonoRailProjectPath;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "monoRailProjectPath", typeof(global::System.String), attribMonoRailProjectPath);
					}
				}
			}
			// MonoRailDefaultLayout
			if (!serializationContext.Result.Failed)
			{
				string attribMonoRailDefaultLayout = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "monoRailDefaultLayout");
				if (attribMonoRailDefaultLayout != null)
				{
					global::System.String valueOfMonoRailDefaultLayout;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribMonoRailDefaultLayout, out valueOfMonoRailDefaultLayout))
					{
						instanceOfModel.MonoRailDefaultLayout = valueOfMonoRailDefaultLayout;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "monoRailDefaultLayout", typeof(global::System.String), attribMonoRailDefaultLayout);
					}
				}
			}
			// MonoRailDefaultRescue
			if (!serializationContext.Result.Failed)
			{
				string attribMonoRailDefaultRescue = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "monoRailDefaultRescue");
				if (attribMonoRailDefaultRescue != null)
				{
					global::System.String valueOfMonoRailDefaultRescue;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribMonoRailDefaultRescue, out valueOfMonoRailDefaultRescue))
					{
						instanceOfModel.MonoRailDefaultRescue = valueOfMonoRailDefaultRescue;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "monoRailDefaultRescue", typeof(global::System.String), attribMonoRailDefaultRescue);
					}
				}
			}
			// MonoRailViewFileExtension
			if (!serializationContext.Result.Failed)
			{
				string attribMonoRailViewFileExtension = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "monoRailViewFileExtension");
				if (attribMonoRailViewFileExtension != null)
				{
					global::System.String valueOfMonoRailViewFileExtension;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribMonoRailViewFileExtension, out valueOfMonoRailViewFileExtension))
					{
						instanceOfModel.MonoRailViewFileExtension = valueOfMonoRailViewFileExtension;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "monoRailViewFileExtension", typeof(global::System.String), attribMonoRailViewFileExtension);
					}
				}
			}
			// UseGenerics
			if (!serializationContext.Result.Failed)
			{
				string attribUseGenerics = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "useGenerics");
				if (attribUseGenerics != null)
				{
					global::System.Boolean valueOfUseGenerics;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribUseGenerics, out valueOfUseGenerics))
					{
						instanceOfModel.UseGenerics = valueOfUseGenerics;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "useGenerics", typeof(global::System.Boolean), attribUseGenerics);
					}
				}
			}
			// UseBaseClass
			if (!serializationContext.Result.Failed)
			{
				string attribUseBaseClass = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "useBaseClass");
				if (attribUseBaseClass != null)
				{
					global::System.Boolean valueOfUseBaseClass;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribUseBaseClass, out valueOfUseBaseClass))
					{
						instanceOfModel.UseBaseClass = valueOfUseBaseClass;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "useBaseClass", typeof(global::System.Boolean), attribUseBaseClass);
					}
				}
			}
			// BaseClassName
			if (!serializationContext.Result.Failed)
			{
				string attribBaseClassName = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "baseClassName");
				if (attribBaseClassName != null)
				{
					global::System.String valueOfBaseClassName;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribBaseClassName, out valueOfBaseClassName))
					{
						instanceOfModel.BaseClassName = valueOfBaseClassName;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "baseClassName", typeof(global::System.String), attribBaseClassName);
					}
				}
			}
			// GeneratesDoubleDerived
			if (!serializationContext.Result.Failed)
			{
				string attribGeneratesDoubleDerived = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "generatesDoubleDerived");
				if (attribGeneratesDoubleDerived != null)
				{
					global::System.Boolean valueOfGeneratesDoubleDerived;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribGeneratesDoubleDerived, out valueOfGeneratesDoubleDerived))
					{
						instanceOfModel.GeneratesDoubleDerived = valueOfGeneratesDoubleDerived;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "generatesDoubleDerived", typeof(global::System.Boolean), attribGeneratesDoubleDerived);
					}
				}
			}
			// DoubleDerivedNameSuffix
			if (!serializationContext.Result.Failed)
			{
				string attribDoubleDerivedNameSuffix = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "doubleDerivedNameSuffix");
				if (attribDoubleDerivedNameSuffix != null)
				{
					global::System.String valueOfDoubleDerivedNameSuffix;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribDoubleDerivedNameSuffix, out valueOfDoubleDerivedNameSuffix))
					{
						instanceOfModel.DoubleDerivedNameSuffix = valueOfDoubleDerivedNameSuffix;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "doubleDerivedNameSuffix", typeof(global::System.String), attribDoubleDerivedNameSuffix);
					}
				}
			}
			// UseGeneratedCodeAttribute
			if (!serializationContext.Result.Failed)
			{
				string attribUseGeneratedCodeAttribute = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "useGeneratedCodeAttribute");
				if (attribUseGeneratedCodeAttribute != null)
				{
					global::System.Boolean valueOfUseGeneratedCodeAttribute;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribUseGeneratedCodeAttribute, out valueOfUseGeneratedCodeAttribute))
					{
						instanceOfModel.UseGeneratedCodeAttribute = valueOfUseGeneratedCodeAttribute;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "useGeneratedCodeAttribute", typeof(global::System.Boolean), attribUseGeneratedCodeAttribute);
					}
				}
			}
			// Target
			if (!serializationContext.Result.Failed)
			{
				string attribTarget = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "target");
				if (attribTarget != null)
				{
					CodeGenerationTarget valueOfTarget;
					if (DslModeling::SerializationUtilities.TryGetValue<CodeGenerationTarget>(serializationContext, attribTarget, out valueOfTarget))
					{
						instanceOfModel.Target = valueOfTarget;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "target", typeof(CodeGenerationTarget), attribTarget);
					}
				}
			}
			// AssemblyPath
			if (!serializationContext.Result.Failed)
			{
				string attribAssemblyPath = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "assemblyPath");
				if (attribAssemblyPath != null)
				{
					global::System.String valueOfAssemblyPath;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribAssemblyPath, out valueOfAssemblyPath))
					{
						instanceOfModel.AssemblyPath = valueOfAssemblyPath;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "assemblyPath", typeof(global::System.String), attribAssemblyPath);
					}
				}
			}
			// ActiveRecordAssemblyName
			if (!serializationContext.Result.Failed)
			{
				string attribActiveRecordAssemblyName = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "activeRecordAssemblyName");
				if (attribActiveRecordAssemblyName != null)
				{
					global::System.String valueOfActiveRecordAssemblyName;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribActiveRecordAssemblyName, out valueOfActiveRecordAssemblyName))
					{
						instanceOfModel.ActiveRecordAssemblyName = valueOfActiveRecordAssemblyName;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "activeRecordAssemblyName", typeof(global::System.String), attribActiveRecordAssemblyName);
					}
				}
			}
			// NHibernateAssemblyName
			if (!serializationContext.Result.Failed)
			{
				string attribNHibernateAssemblyName = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "nHibernateAssemblyName");
				if (attribNHibernateAssemblyName != null)
				{
					global::System.String valueOfNHibernateAssemblyName;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribNHibernateAssemblyName, out valueOfNHibernateAssemblyName))
					{
						instanceOfModel.NHibernateAssemblyName = valueOfNHibernateAssemblyName;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "nHibernateAssemblyName", typeof(global::System.String), attribNHibernateAssemblyName);
					}
				}
			}
			// RelateWithActiwFile
			if (!serializationContext.Result.Failed)
			{
				string attribRelateWithActiwFile = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "relateWithActiwFile");
				if (attribRelateWithActiwFile != null)
				{
					global::System.Boolean valueOfRelateWithActiwFile;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribRelateWithActiwFile, out valueOfRelateWithActiwFile))
					{
						instanceOfModel.RelateWithActiwFile = valueOfRelateWithActiwFile;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "relateWithActiwFile", typeof(global::System.Boolean), attribRelateWithActiwFile);
					}
				}
			}
			// UseVirtualProperties
			if (!serializationContext.Result.Failed)
			{
				string attribUseVirtualProperties = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "useVirtualProperties");
				if (attribUseVirtualProperties != null)
				{
					global::System.Boolean valueOfUseVirtualProperties;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribUseVirtualProperties, out valueOfUseVirtualProperties))
					{
						instanceOfModel.UseVirtualProperties = valueOfUseVirtualProperties;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "useVirtualProperties", typeof(global::System.Boolean), attribUseVirtualProperties);
					}
				}
			}
			// Namespace
			if (!serializationContext.Result.Failed)
			{
				string attribNamespace = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "namespace");
				if (attribNamespace != null)
				{
					global::System.String valueOfNamespace;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribNamespace, out valueOfNamespace))
					{
						instanceOfModel.Namespace = valueOfNamespace;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "namespace", typeof(global::System.String), attribNamespace);
					}
				}
			}
			// ImplementINotifyPropertyChanged
			if (!serializationContext.Result.Failed)
			{
				string attribImplementINotifyPropertyChanged = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "implementINotifyPropertyChanged");
				if (attribImplementINotifyPropertyChanged != null)
				{
					global::System.Boolean valueOfImplementINotifyPropertyChanged;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribImplementINotifyPropertyChanged, out valueOfImplementINotifyPropertyChanged))
					{
						instanceOfModel.ImplementINotifyPropertyChanged = valueOfImplementINotifyPropertyChanged;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "implementINotifyPropertyChanged", typeof(global::System.Boolean), attribImplementINotifyPropertyChanged);
					}
				}
			}
			// GenerateMetaData
			if (!serializationContext.Result.Failed)
			{
				string attribGenerateMetaData = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "generateMetaData");
				if (attribGenerateMetaData != null)
				{
					MetaDataGeneration valueOfGenerateMetaData;
					if (DslModeling::SerializationUtilities.TryGetValue<MetaDataGeneration>(serializationContext, attribGenerateMetaData, out valueOfGenerateMetaData))
					{
						instanceOfModel.GenerateMetaData = valueOfGenerateMetaData;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "generateMetaData", typeof(MetaDataGeneration), attribGenerateMetaData);
					}
				}
			}
			// UseNHQG
			if (!serializationContext.Result.Failed)
			{
				string attribUseNHQG = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "useNHQG");
				if (attribUseNHQG != null)
				{
					global::System.Boolean valueOfUseNHQG;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribUseNHQG, out valueOfUseNHQG))
					{
						instanceOfModel.UseNHQG = valueOfUseNHQG;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "useNHQG", typeof(global::System.Boolean), attribUseNHQG);
					}
				}
			}
			// NHQGExecutable
			if (!serializationContext.Result.Failed)
			{
				string attribNHQGExecutable = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "nHQGExecutable");
				if (attribNHQGExecutable != null)
				{
					global::System.String valueOfNHQGExecutable;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribNHQGExecutable, out valueOfNHQGExecutable))
					{
						instanceOfModel.NHQGExecutable = valueOfNHQGExecutable;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "nHQGExecutable", typeof(global::System.String), attribNHQGExecutable);
					}
				}
			}
			// UseGenericRelations
			if (!serializationContext.Result.Failed)
			{
				string attribUseGenericRelations = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "useGenericRelations");
				if (attribUseGenericRelations != null)
				{
					global::System.Boolean valueOfUseGenericRelations;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribUseGenericRelations, out valueOfUseGenericRelations))
					{
						instanceOfModel.UseGenericRelations = valueOfUseGenericRelations;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "useGenericRelations", typeof(global::System.Boolean), attribUseGenericRelations);
					}
				}
			}
			// PropertyNameFilterExpression
			if (!serializationContext.Result.Failed)
			{
				string attribPropertyNameFilterExpression = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "propertyNameFilterExpression");
				if (attribPropertyNameFilterExpression != null)
				{
					global::System.String valueOfPropertyNameFilterExpression;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribPropertyNameFilterExpression, out valueOfPropertyNameFilterExpression))
					{
						instanceOfModel.PropertyNameFilterExpression = valueOfPropertyNameFilterExpression;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "propertyNameFilterExpression", typeof(global::System.String), attribPropertyNameFilterExpression);
					}
				}
			}
			// InitializeIListFields
			if (!serializationContext.Result.Failed)
			{
				string attribInitializeIListFields = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "initializeIListFields");
				if (attribInitializeIListFields != null)
				{
					global::System.Boolean valueOfInitializeIListFields;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribInitializeIListFields, out valueOfInitializeIListFields))
					{
						instanceOfModel.InitializeIListFields = valueOfInitializeIListFields;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "initializeIListFields", typeof(global::System.Boolean), attribInitializeIListFields);
					}
				}
			}
			// ImplementINotifyPropertyChanging
			if (!serializationContext.Result.Failed)
			{
				string attribImplementINotifyPropertyChanging = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "implementINotifyPropertyChanging");
				if (attribImplementINotifyPropertyChanging != null)
				{
					global::System.Boolean valueOfImplementINotifyPropertyChanging;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribImplementINotifyPropertyChanging, out valueOfImplementINotifyPropertyChanging))
					{
						instanceOfModel.ImplementINotifyPropertyChanging = valueOfImplementINotifyPropertyChanging;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "implementINotifyPropertyChanging", typeof(global::System.Boolean), attribImplementINotifyPropertyChanging);
					}
				}
			}
			// CollectionInterface
			if (!serializationContext.Result.Failed)
			{
				string attribCollectionInterface = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "collectionInterface");
				if (attribCollectionInterface != null)
				{
					global::System.String valueOfCollectionInterface;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribCollectionInterface, out valueOfCollectionInterface))
					{
						instanceOfModel.CollectionInterface = valueOfCollectionInterface;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "collectionInterface", typeof(global::System.String), attribCollectionInterface);
					}
				}
			}
			// CollectionImplementation
			if (!serializationContext.Result.Failed)
			{
				string attribCollectionImplementation = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "collectionImplementation");
				if (attribCollectionImplementation != null)
				{
					global::System.String valueOfCollectionImplementation;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribCollectionImplementation, out valueOfCollectionImplementation))
					{
						instanceOfModel.CollectionImplementation = valueOfCollectionImplementation;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "collectionImplementation", typeof(global::System.String), attribCollectionImplementation);
					}
				}
			}
			// ManyToManyRelationType
			if (!serializationContext.Result.Failed)
			{
				string attribManyToManyRelationType = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "manyToManyRelationType");
				if (attribManyToManyRelationType != null)
				{
					RelationType valueOfManyToManyRelationType;
					if (DslModeling::SerializationUtilities.TryGetValue<RelationType>(serializationContext, attribManyToManyRelationType, out valueOfManyToManyRelationType))
					{
						instanceOfModel.ManyToManyRelationType = valueOfManyToManyRelationType;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "manyToManyRelationType", typeof(RelationType), attribManyToManyRelationType);
					}
				}
			}
			// ManyToOneRelationType
			if (!serializationContext.Result.Failed)
			{
				string attribManyToOneRelationType = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "manyToOneRelationType");
				if (attribManyToOneRelationType != null)
				{
					RelationType valueOfManyToOneRelationType;
					if (DslModeling::SerializationUtilities.TryGetValue<RelationType>(serializationContext, attribManyToOneRelationType, out valueOfManyToOneRelationType))
					{
						instanceOfModel.ManyToOneRelationType = valueOfManyToOneRelationType;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "manyToOneRelationType", typeof(RelationType), attribManyToOneRelationType);
					}
				}
			}
			// ManyToManyCollectionIDColumnFormat
			if (!serializationContext.Result.Failed)
			{
				string attribManyToManyCollectionIDColumnFormat = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "manyToManyCollectionIDColumnFormat");
				if (attribManyToManyCollectionIDColumnFormat != null)
				{
					global::System.String valueOfManyToManyCollectionIDColumnFormat;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribManyToManyCollectionIDColumnFormat, out valueOfManyToManyCollectionIDColumnFormat))
					{
						instanceOfModel.ManyToManyCollectionIDColumnFormat = valueOfManyToManyCollectionIDColumnFormat;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "manyToManyCollectionIDColumnFormat", typeof(global::System.String), attribManyToManyCollectionIDColumnFormat);
					}
				}
			}
			// ManyToManyCollectionIDColumnType
			if (!serializationContext.Result.Failed)
			{
				string attribManyToManyCollectionIDColumnType = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "manyToManyCollectionIDColumnType");
				if (attribManyToManyCollectionIDColumnType != null)
				{
					NHibernateType valueOfManyToManyCollectionIDColumnType;
					if (DslModeling::SerializationUtilities.TryGetValue<NHibernateType>(serializationContext, attribManyToManyCollectionIDColumnType, out valueOfManyToManyCollectionIDColumnType))
					{
						instanceOfModel.ManyToManyCollectionIDColumnType = valueOfManyToManyCollectionIDColumnType;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "manyToManyCollectionIDColumnType", typeof(NHibernateType), attribManyToManyCollectionIDColumnType);
					}
				}
			}
			// ManyToManyCollectionIDGenerator
			if (!serializationContext.Result.Failed)
			{
				string attribManyToManyCollectionIDGenerator = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "manyToManyCollectionIDGenerator");
				if (attribManyToManyCollectionIDGenerator != null)
				{
					PrimaryKeyType valueOfManyToManyCollectionIDGenerator;
					if (DslModeling::SerializationUtilities.TryGetValue<PrimaryKeyType>(serializationContext, attribManyToManyCollectionIDGenerator, out valueOfManyToManyCollectionIDGenerator))
					{
						instanceOfModel.ManyToManyCollectionIDGenerator = valueOfManyToManyCollectionIDGenerator;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "manyToManyCollectionIDGenerator", typeof(PrimaryKeyType), attribManyToManyCollectionIDGenerator);
					}
				}
			}
			// ManyToManyIUserCollectionType
			if (!serializationContext.Result.Failed)
			{
				string attribManyToManyIUserCollectionType = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "manyToManyIUserCollectionType");
				if (attribManyToManyIUserCollectionType != null)
				{
					global::System.String valueOfManyToManyIUserCollectionType;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribManyToManyIUserCollectionType, out valueOfManyToManyIUserCollectionType))
					{
						instanceOfModel.ManyToManyIUserCollectionType = valueOfManyToManyIUserCollectionType;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "manyToManyIUserCollectionType", typeof(global::System.String), attribManyToManyIUserCollectionType);
					}
				}
			}
			// ManyToOneIUserCollectionType
			if (!serializationContext.Result.Failed)
			{
				string attribManyToOneIUserCollectionType = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "manyToOneIUserCollectionType");
				if (attribManyToOneIUserCollectionType != null)
				{
					global::System.String valueOfManyToOneIUserCollectionType;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribManyToOneIUserCollectionType, out valueOfManyToOneIUserCollectionType))
					{
						instanceOfModel.ManyToOneIUserCollectionType = valueOfManyToOneIUserCollectionType;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "manyToOneIUserCollectionType", typeof(global::System.String), attribManyToOneIUserCollectionType);
					}
				}
			}
			// AutomaticAssociations
			if (!serializationContext.Result.Failed)
			{
				string attribAutomaticAssociations = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "automaticAssociations");
				if (attribAutomaticAssociations != null)
				{
					global::System.Boolean valueOfAutomaticAssociations;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribAutomaticAssociations, out valueOfAutomaticAssociations))
					{
						instanceOfModel.AutomaticAssociations = valueOfAutomaticAssociations;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "automaticAssociations", typeof(global::System.Boolean), attribAutomaticAssociations);
					}
				}
			}
			// AutomaticAssociationCollectionImplementation
			if (!serializationContext.Result.Failed)
			{
				string attribAutomaticAssociationCollectionImplementation = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "automaticAssociationCollectionImplementation");
				if (attribAutomaticAssociationCollectionImplementation != null)
				{
					global::System.String valueOfAutomaticAssociationCollectionImplementation;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribAutomaticAssociationCollectionImplementation, out valueOfAutomaticAssociationCollectionImplementation))
					{
						instanceOfModel.AutomaticAssociationCollectionImplementation = valueOfAutomaticAssociationCollectionImplementation;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "automaticAssociationCollectionImplementation", typeof(global::System.String), attribAutomaticAssociationCollectionImplementation);
					}
				}
			}
			// ManyToManyTableFormat
			if (!serializationContext.Result.Failed)
			{
				string attribManyToManyTableFormat = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "manyToManyTableFormat");
				if (attribManyToManyTableFormat != null)
				{
					global::System.String valueOfManyToManyTableFormat;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribManyToManyTableFormat, out valueOfManyToManyTableFormat))
					{
						instanceOfModel.ManyToManyTableFormat = valueOfManyToManyTableFormat;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "manyToManyTableFormat", typeof(global::System.String), attribManyToManyTableFormat);
					}
				}
			}
			// ForeignKeyFormat
			if (!serializationContext.Result.Failed)
			{
				string attribForeignKeyFormat = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "foreignKeyFormat");
				if (attribForeignKeyFormat != null)
				{
					global::System.String valueOfForeignKeyFormat;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribForeignKeyFormat, out valueOfForeignKeyFormat))
					{
						instanceOfModel.ForeignKeyFormat = valueOfForeignKeyFormat;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "foreignKeyFormat", typeof(global::System.String), attribForeignKeyFormat);
					}
				}
			}
			// CommonPrimaryKeyPropertyFormat
			if (!serializationContext.Result.Failed)
			{
				string attribCommonPrimaryKeyPropertyFormat = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "commonPrimaryKeyPropertyFormat");
				if (attribCommonPrimaryKeyPropertyFormat != null)
				{
					global::System.String valueOfCommonPrimaryKeyPropertyFormat;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribCommonPrimaryKeyPropertyFormat, out valueOfCommonPrimaryKeyPropertyFormat))
					{
						instanceOfModel.CommonPrimaryKeyPropertyFormat = valueOfCommonPrimaryKeyPropertyFormat;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "commonPrimaryKeyPropertyFormat", typeof(global::System.String), attribCommonPrimaryKeyPropertyFormat);
					}
				}
			}
			// CommonPrimaryKeyColumnFormat
			if (!serializationContext.Result.Failed)
			{
				string attribCommonPrimaryKeyColumnFormat = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "commonPrimaryKeyColumnFormat");
				if (attribCommonPrimaryKeyColumnFormat != null)
				{
					global::System.String valueOfCommonPrimaryKeyColumnFormat;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribCommonPrimaryKeyColumnFormat, out valueOfCommonPrimaryKeyColumnFormat))
					{
						instanceOfModel.CommonPrimaryKeyColumnFormat = valueOfCommonPrimaryKeyColumnFormat;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "commonPrimaryKeyColumnFormat", typeof(global::System.String), attribCommonPrimaryKeyColumnFormat);
					}
				}
			}
			// CommonPrimaryKeyColumnType
			if (!serializationContext.Result.Failed)
			{
				string attribCommonPrimaryKeyColumnType = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "commonPrimaryKeyColumnType");
				if (attribCommonPrimaryKeyColumnType != null)
				{
					NHibernateType valueOfCommonPrimaryKeyColumnType;
					if (DslModeling::SerializationUtilities.TryGetValue<NHibernateType>(serializationContext, attribCommonPrimaryKeyColumnType, out valueOfCommonPrimaryKeyColumnType))
					{
						instanceOfModel.CommonPrimaryKeyColumnType = valueOfCommonPrimaryKeyColumnType;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "commonPrimaryKeyColumnType", typeof(NHibernateType), attribCommonPrimaryKeyColumnType);
					}
				}
			}
			// CommonPrimaryKeyGenerator
			if (!serializationContext.Result.Failed)
			{
				string attribCommonPrimaryKeyGenerator = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "commonPrimaryKeyGenerator");
				if (attribCommonPrimaryKeyGenerator != null)
				{
					PrimaryKeyType valueOfCommonPrimaryKeyGenerator;
					if (DslModeling::SerializationUtilities.TryGetValue<PrimaryKeyType>(serializationContext, attribCommonPrimaryKeyGenerator, out valueOfCommonPrimaryKeyGenerator))
					{
						instanceOfModel.CommonPrimaryKeyGenerator = valueOfCommonPrimaryKeyGenerator;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "commonPrimaryKeyGenerator", typeof(PrimaryKeyType), attribCommonPrimaryKeyGenerator);
					}
				}
			}
			// MemberTemplateFile
			if (!serializationContext.Result.Failed)
			{
				string attribMemberTemplateFile = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "memberTemplateFile");
				if (attribMemberTemplateFile != null)
				{
					global::System.String valueOfMemberTemplateFile;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribMemberTemplateFile, out valueOfMemberTemplateFile))
					{
						instanceOfModel.MemberTemplateFile = valueOfMemberTemplateFile;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "memberTemplateFile", typeof(global::System.String), attribMemberTemplateFile);
					}
				}
			}
			// BaseClassPropertyChangedMethod
			if (!serializationContext.Result.Failed)
			{
				string attribBaseClassPropertyChangedMethod = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "baseClassPropertyChangedMethod");
				if (attribBaseClassPropertyChangedMethod != null)
				{
					global::System.String valueOfBaseClassPropertyChangedMethod;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribBaseClassPropertyChangedMethod, out valueOfBaseClassPropertyChangedMethod))
					{
						instanceOfModel.BaseClassPropertyChangedMethod = valueOfBaseClassPropertyChangedMethod;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "baseClassPropertyChangedMethod", typeof(global::System.String), attribBaseClassPropertyChangedMethod);
					}
				}
			}
			// BaseClassPropertyChangingMethod
			if (!serializationContext.Result.Failed)
			{
				string attribBaseClassPropertyChangingMethod = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "baseClassPropertyChangingMethod");
				if (attribBaseClassPropertyChangingMethod != null)
				{
					global::System.String valueOfBaseClassPropertyChangingMethod;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribBaseClassPropertyChangingMethod, out valueOfBaseClassPropertyChangingMethod))
					{
						instanceOfModel.BaseClassPropertyChangingMethod = valueOfBaseClassPropertyChangingMethod;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "baseClassPropertyChangingMethod", typeof(global::System.String), attribBaseClassPropertyChangingMethod);
					}
				}
			}
			// Access
			if (!serializationContext.Result.Failed)
			{
				string attribAccess = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "access");
				if (attribAccess != null)
				{
					PropertyAccess valueOfAccess;
					if (DslModeling::SerializationUtilities.TryGetValue<PropertyAccess>(serializationContext, attribAccess, out valueOfAccess))
					{
						instanceOfModel.Access = valueOfAccess;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "access", typeof(PropertyAccess), attribAccess);
					}
				}
			}
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory Model instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadElements(serializationContext, element, reader);
	
			Model instanceOfModel = element as Model;
			global::System.Diagnostics.Debug.Assert(instanceOfModel != null, "Expecting an instance of Model!");
	
			// Read properties serialized as nested XML elements.
			if (!serializationContext.Result.Failed)
				ReadPropertiesFromElements(serializationContext, instanceOfModel, reader);
			// Read child model elements (which are always serialized as nested XML elements).
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
				ReadChildElements(serializationContext, instanceOfModel, reader);
		}
	
		/// <summary>
		/// This method deserializes all properties that are serialized as nested XML elements.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first child XML element, but it can be either a property 
		/// or a child element. 
		/// This method will read as many properties as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered ("unknown" means it's not a property. It can be either a bogus tag, or
		///    a child model element). In this case, this method will position the reader at the open tag of the unknown element. This
		///    implies the if the first child XML element is unknown, this method should return immediately and do nothing.
		/// 2) When all properties are read. In this case, the reader will be positioned at the next tag, which is either the open tag
		///    of the next sibling (which can be the open tag of a child model element), or the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory Model instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		private static void ReadPropertiesFromElements(DslModeling::SerializationContext serializationContext, Model element, global::System.Xml.XmlReader reader)
		{
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
					case "additionalImports":	// AdditionalImports
						if (reader.IsEmptyElement)
						{	// No serialized value, must be default one.
							DslModeling::SerializationUtilities.Skip(reader);  // Skip this tag.
						}
						else
						{
							string strAdditionalImports = ActiveWriterSerializationHelper.Instance.ReadElementContentAsString(serializationContext, element, reader);
							global::System.Collections.Generic.List<Castle.ActiveWriter.Import> valueOfAdditionalImports;
							if (DslModeling::SerializationUtilities.TryGetValue<global::System.Collections.Generic.List<Castle.ActiveWriter.Import>>(serializationContext, strAdditionalImports, out valueOfAdditionalImports))
							{
								element.AdditionalImports = valueOfAdditionalImports;
							}
							else
							{	// Invalid property value, ignored.
								ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "additionalImports", typeof(global::System.Collections.Generic.List<Castle.ActiveWriter.Import>), strAdditionalImports);
							}
	
							DslModeling::SerializationUtilities.SkipToNextElement(reader);
						}
						break;
					default:
						return;  // Don't know this element.
				}
			}
		}
	
		/// <summary>
		/// This method deserializes all child model elements.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first child XML element to deserialized.
		/// This method will read as many child elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the 
		///    open tag of the unknown element. This implies that if the first child XML element is unknown, this method 
		///    should return immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="element">In-memory Model instance that will get the deserialized data.</param>
		private static void ReadChildElements(DslModeling::SerializationContext serializationContext, Model element, global::System.Xml.XmlReader reader)
		{
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
					case "classes":	// Relationship "ModelHasClass"
						if (reader.IsEmptyElement)
						{	// No instance of this relationship, just skip
							DslModeling::SerializationUtilities.Skip(reader);
						}
						else
						{
							DslModeling::SerializationUtilities.SkipToFirstChild(reader);  // Skip the open tag of <classes>
							ReadModelHasClassInstances(serializationContext, element, reader);
							DslModeling::SerializationUtilities.Skip(reader);  // Skip the close tag of </classes>
						}
						break;
					case "nestedClasses":	// Relationship "ModelHasNestedClasses"
						if (reader.IsEmptyElement)
						{	// No instance of this relationship, just skip
							DslModeling::SerializationUtilities.Skip(reader);
						}
						else
						{
							DslModeling::SerializationUtilities.SkipToFirstChild(reader);  // Skip the open tag of <nestedClasses>
							ReadModelHasNestedClassesInstances(serializationContext, element, reader);
							DslModeling::SerializationUtilities.Skip(reader);  // Skip the close tag of </nestedClasses>
						}
						break;
					default:
						return;  // Don't know this element.
				}
			}
		}
	
		/// <summary>
		/// Reads all instances of relationship ModelHasClass.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first XML element inside the relationship tag, so it can be
		/// either the first instance, or a bogus tag. This method will deserialize all instances and ignore all bogus tags. When the
		/// method returns, the reader will be positioned at the end tag of the relationship (or EOF if somehow that happens).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory Model instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		private static void ReadModelHasClassInstances(DslModeling::SerializationContext serializationContext, Model element, global::System.Xml.XmlReader reader)
		{
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				DslModeling::DomainClassXmlSerializer newModelClassOfModelHasClassSerializer = serializationContext.Directory.GetSerializer(ModelClass.DomainClassId);
				global::System.Diagnostics.Debug.Assert(newModelClassOfModelHasClassSerializer != null, "Cannot find serializer for ModelClass!");
				ModelClass newModelClassOfModelHasClass = newModelClassOfModelHasClassSerializer.TryCreateInstance(serializationContext, reader, element.Partition) as ModelClass;
				if (newModelClassOfModelHasClass != null)
				{
					element.Classes.Add(newModelClassOfModelHasClass);
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newModelClassOfModelHasClass.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newModelClassOfModelHasClass.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, newModelClassOfModelHasClass, reader);
				}
				else
				{
					global::System.Type typeofModelHasClass = typeof(ModelHasClass);
					DslModeling::DomainRelationshipXmlSerializer newModelHasClassSerializer = serializationContext.Directory.GetSerializer(ModelHasClass.DomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
					global::System.Diagnostics.Debug.Assert(newModelHasClassSerializer != null, "Cannot find serializer for ModelHasClass!");
					ModelHasClass newModelHasClass = newModelHasClassSerializer.TryCreateInstance (serializationContext, reader, element.Partition) as ModelHasClass;
					if (newModelHasClass != null)
					{
						if (newModelHasClass.GetType() == typeofModelHasClass)
						{	// The relationship should be serialized in short-form.
							ActiveWriterSerializationBehaviorSerializationMessages.ExpectingShortFormRelationship(serializationContext, reader, typeof(ModelHasClass));
						}
						DslModeling::DomainRoleInfo.SetRolePlayer (newModelHasClass, ModelHasClass.ModelDomainRoleId, element);
						DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newModelHasClass.GetDomainClass().Id);	
						global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newModelHasClass.GetDomainClass().Name + "!");
						targetSerializer.Read(serializationContext, newModelHasClass, reader);
					}
					else
					{	// Unknown element, skip
						DslModeling::SerializationUtilities.Skip(reader);
					}
				}
			}
		}
	
		/// <summary>
		/// Reads all instances of relationship ModelHasNestedClasses.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first XML element inside the relationship tag, so it can be
		/// either the first instance, or a bogus tag. This method will deserialize all instances and ignore all bogus tags. When the
		/// method returns, the reader will be positioned at the end tag of the relationship (or EOF if somehow that happens).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory Model instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		private static void ReadModelHasNestedClassesInstances(DslModeling::SerializationContext serializationContext, Model element, global::System.Xml.XmlReader reader)
		{
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				DslModeling::DomainClassXmlSerializer newNestedClassOfModelHasNestedClassesSerializer = serializationContext.Directory.GetSerializer(NestedClass.DomainClassId);
				global::System.Diagnostics.Debug.Assert(newNestedClassOfModelHasNestedClassesSerializer != null, "Cannot find serializer for NestedClass!");
				NestedClass newNestedClassOfModelHasNestedClasses = newNestedClassOfModelHasNestedClassesSerializer.TryCreateInstance(serializationContext, reader, element.Partition) as NestedClass;
				if (newNestedClassOfModelHasNestedClasses != null)
				{
					element.NestedClasses.Add(newNestedClassOfModelHasNestedClasses);
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newNestedClassOfModelHasNestedClasses.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newNestedClassOfModelHasNestedClasses.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, newNestedClassOfModelHasNestedClasses, reader);
				}
				else
				{
					global::System.Type typeofModelHasNestedClasses = typeof(ModelHasNestedClasses);
					DslModeling::DomainRelationshipXmlSerializer newModelHasNestedClassesSerializer = serializationContext.Directory.GetSerializer(ModelHasNestedClasses.DomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
					global::System.Diagnostics.Debug.Assert(newModelHasNestedClassesSerializer != null, "Cannot find serializer for ModelHasNestedClasses!");
					ModelHasNestedClasses newModelHasNestedClasses = newModelHasNestedClassesSerializer.TryCreateInstance (serializationContext, reader, element.Partition) as ModelHasNestedClasses;
					if (newModelHasNestedClasses != null)
					{
						if (newModelHasNestedClasses.GetType() == typeofModelHasNestedClasses)
						{	// The relationship should be serialized in short-form.
							ActiveWriterSerializationBehaviorSerializationMessages.ExpectingShortFormRelationship(serializationContext, reader, typeof(ModelHasNestedClasses));
						}
						DslModeling::DomainRoleInfo.SetRolePlayer (newModelHasNestedClasses, ModelHasNestedClasses.ModelDomainRoleId, element);
						DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newModelHasNestedClasses.GetDomainClass().Id);	
						global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newModelHasNestedClasses.GetDomainClass().Name + "!");
						targetSerializer.Read(serializationContext, newModelHasNestedClasses, reader);
					}
					else
					{	// Unknown element, skip
						DslModeling::SerializationUtilities.Skip(reader);
					}
				}
			}
		}
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of Model based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized Model, a new Model instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created Model instance, or null if the reader is not pointing to a serialized Model instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "Model" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "Model".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						ModelSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ModelSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of Model based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of Model.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new Model instance should be created.</param>	
		/// <returns>Created Model instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (string.IsNullOrEmpty(idStr))
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					ActiveWriterSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				return new Model(partition, new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id));
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				ActiveWriterSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				ActiveWriterSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				ActiveWriterSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from Model, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from Model.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(Model.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including Model itself) instance of Model based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "Model" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "Model".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						ModelSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ModelSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of Model based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				ActiveWriterSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			try
			{	// Normalize the Id.
				global::System.Guid id = new global::System.Guid(monikerString);
				monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
				DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, Model.DomainClassId, partition.Store), partition.Store);
				// Set location info if possible.
				result.Location = serializationContext.Location;
				global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
				if (xmlLineInfo != null)
				{
					result.Line = xmlLineInfo.LineNumber;
					result.Column = xmlLineInfo.LinePosition;
				}
				return result;
			}
			catch (global::System.FormatException /* fEx */)
			{
				ActiveWriterSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
			catch (global::System.OverflowException /* oEx */)
			{	
				ActiveWriterSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from Model, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from Model.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(Model.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized Model instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Model instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the Model instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the Model instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one Model instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Model instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				ActiveWriterSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Model instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			Model instanceOfModel = element as Model;
			global::System.Diagnostics.Debug.Assert(instanceOfModel != null, "Expecting an instance of Model");
	
			// UseNullables
			if (!serializationContext.Result.Failed)
			{
				NullableUsage propValue = instanceOfModel.UseNullables;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<NullableUsage>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "No") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "useNullables", serializedPropValue);
					}
				}
			}
			// CaseOfPrivateFields
			if (!serializationContext.Result.Failed)
			{
				FieldCase propValue = instanceOfModel.CaseOfPrivateFields;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<FieldCase>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "CamelcaseUnderscore") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "caseOfPrivateFields", serializedPropValue);
					}
				}
			}
			// GenerateMonoRailProject
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfModel.GenerateMonoRailProject;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "false") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "generateMonoRailProject", serializedPropValue);
					}
				}
			}
			// MonoRailProjectName
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModel.MonoRailProjectName;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "monoRailProjectName", propValue);
	
				}
			}
			// MonoRailProjectPath
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModel.MonoRailProjectPath;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "monoRailProjectPath", propValue);
	
				}
			}
			// MonoRailDefaultLayout
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModel.MonoRailDefaultLayout;
				if (!serializationContext.Result.Failed)
				{
					if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, "default") != 0))
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "monoRailDefaultLayout", propValue);
					}
				}
			}
			// MonoRailDefaultRescue
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModel.MonoRailDefaultRescue;
				if (!serializationContext.Result.Failed)
				{
					if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, "generalerror") != 0))
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "monoRailDefaultRescue", propValue);
					}
				}
			}
			// MonoRailViewFileExtension
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModel.MonoRailViewFileExtension;
				if (!serializationContext.Result.Failed)
				{
					if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, ".vm") != 0))
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "monoRailViewFileExtension", propValue);
					}
				}
			}
			// UseGenerics
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfModel.UseGenerics;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "true") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "useGenerics", serializedPropValue);
					}
				}
			}
			// UseBaseClass
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfModel.UseBaseClass;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "true") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "useBaseClass", serializedPropValue);
					}
				}
			}
			// BaseClassName
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModel.BaseClassName;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "baseClassName", propValue);
	
				}
			}
			// GeneratesDoubleDerived
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfModel.GeneratesDoubleDerived;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "false") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "generatesDoubleDerived", serializedPropValue);
					}
				}
			}
			// DoubleDerivedNameSuffix
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModel.DoubleDerivedNameSuffix;
				if (!serializationContext.Result.Failed)
				{
					if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, "Base") != 0))
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "doubleDerivedNameSuffix", propValue);
					}
				}
			}
			// UseGeneratedCodeAttribute
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfModel.UseGeneratedCodeAttribute;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "false") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "useGeneratedCodeAttribute", serializedPropValue);
					}
				}
			}
			// Target
			if (!serializationContext.Result.Failed)
			{
				CodeGenerationTarget propValue = instanceOfModel.Target;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<CodeGenerationTarget>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "ActiveRecord") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "target", serializedPropValue);
					}
				}
			}
			// AssemblyPath
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModel.AssemblyPath;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "assemblyPath", propValue);
	
				}
			}
			// ActiveRecordAssemblyName
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModel.ActiveRecordAssemblyName;
				if (!serializationContext.Result.Failed)
				{
					if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, "Castle.ActiveRecord") != 0))
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "activeRecordAssemblyName", propValue);
					}
				}
			}
			// NHibernateAssemblyName
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModel.NHibernateAssemblyName;
				if (!serializationContext.Result.Failed)
				{
					if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, "NHibernate") != 0))
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "nHibernateAssemblyName", propValue);
					}
				}
			}
			// RelateWithActiwFile
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfModel.RelateWithActiwFile;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "true") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "relateWithActiwFile", serializedPropValue);
					}
				}
			}
			// UseVirtualProperties
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfModel.UseVirtualProperties;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "true") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "useVirtualProperties", serializedPropValue);
					}
				}
			}
			// Namespace
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModel.Namespace;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "namespace", propValue);
	
				}
			}
			// ImplementINotifyPropertyChanged
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfModel.ImplementINotifyPropertyChanged;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "false") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "implementINotifyPropertyChanged", serializedPropValue);
					}
				}
			}
			// GenerateMetaData
			if (!serializationContext.Result.Failed)
			{
				MetaDataGeneration propValue = instanceOfModel.GenerateMetaData;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<MetaDataGeneration>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "False") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "generateMetaData", serializedPropValue);
					}
				}
			}
			// UseNHQG
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfModel.UseNHQG;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "false") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "useNHQG", serializedPropValue);
					}
				}
			}
			// NHQGExecutable
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModel.NHQGExecutable;
				if (!serializationContext.Result.Failed)
				{
					if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, "C:\\Program Files\\Rhino\\NHibernate Query Generator\\NHQG.exe") != 0))
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "nHQGExecutable", propValue);
					}
				}
			}
			// UseGenericRelations
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfModel.UseGenericRelations;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "true") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "useGenericRelations", serializedPropValue);
					}
				}
			}
			// PropertyNameFilterExpression
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModel.PropertyNameFilterExpression;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "propertyNameFilterExpression", propValue);
	
				}
			}
			// InitializeIListFields
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfModel.InitializeIListFields;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "false") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "initializeIListFields", serializedPropValue);
					}
				}
			}
			// ImplementINotifyPropertyChanging
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfModel.ImplementINotifyPropertyChanging;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "false") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "implementINotifyPropertyChanging", serializedPropValue);
					}
				}
			}
			// CollectionInterface
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModel.CollectionInterface;
				if (!serializationContext.Result.Failed)
				{
					if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, "IList") != 0))
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "collectionInterface", propValue);
					}
				}
			}
			// CollectionImplementation
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModel.CollectionImplementation;
				if (!serializationContext.Result.Failed)
				{
					if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, "List") != 0))
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "collectionImplementation", propValue);
					}
				}
			}
			// ManyToManyRelationType
			if (!serializationContext.Result.Failed)
			{
				RelationType propValue = instanceOfModel.ManyToManyRelationType;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<RelationType>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Guess") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "manyToManyRelationType", serializedPropValue);
					}
				}
			}
			// ManyToOneRelationType
			if (!serializationContext.Result.Failed)
			{
				RelationType propValue = instanceOfModel.ManyToOneRelationType;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<RelationType>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Guess") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "manyToOneRelationType", serializedPropValue);
					}
				}
			}
			// ManyToManyCollectionIDColumnFormat
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModel.ManyToManyCollectionIDColumnFormat;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "manyToManyCollectionIDColumnFormat", propValue);
	
				}
			}
			// ManyToManyCollectionIDColumnType
			if (!serializationContext.Result.Failed)
			{
				NHibernateType propValue = instanceOfModel.ManyToManyCollectionIDColumnType;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<NHibernateType>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "manyToManyCollectionIDColumnType", serializedPropValue);
				}
			}
			// ManyToManyCollectionIDGenerator
			if (!serializationContext.Result.Failed)
			{
				PrimaryKeyType propValue = instanceOfModel.ManyToManyCollectionIDGenerator;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<PrimaryKeyType>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "manyToManyCollectionIDGenerator", serializedPropValue);
				}
			}
			// ManyToManyIUserCollectionType
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModel.ManyToManyIUserCollectionType;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "manyToManyIUserCollectionType", propValue);
	
				}
			}
			// ManyToOneIUserCollectionType
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModel.ManyToOneIUserCollectionType;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "manyToOneIUserCollectionType", propValue);
	
				}
			}
			// AutomaticAssociations
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfModel.AutomaticAssociations;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "false") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "automaticAssociations", serializedPropValue);
					}
				}
			}
			// AutomaticAssociationCollectionImplementation
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModel.AutomaticAssociationCollectionImplementation;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "automaticAssociationCollectionImplementation", propValue);
	
				}
			}
			// ManyToManyTableFormat
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModel.ManyToManyTableFormat;
				if (!serializationContext.Result.Failed)
				{
					if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, "{0}{1}") != 0))
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "manyToManyTableFormat", propValue);
					}
				}
			}
			// ForeignKeyFormat
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModel.ForeignKeyFormat;
				if (!serializationContext.Result.Failed)
				{
					if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, "{0}") != 0))
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "foreignKeyFormat", propValue);
					}
				}
			}
			// CommonPrimaryKeyPropertyFormat
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModel.CommonPrimaryKeyPropertyFormat;
				if (!serializationContext.Result.Failed)
				{
					if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, string.Empty) != 0))
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "commonPrimaryKeyPropertyFormat", propValue);
					}
				}
			}
			// CommonPrimaryKeyColumnFormat
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModel.CommonPrimaryKeyColumnFormat;
				if (!serializationContext.Result.Failed)
				{
					if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, string.Empty) != 0))
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "commonPrimaryKeyColumnFormat", propValue);
					}
				}
			}
			// CommonPrimaryKeyColumnType
			if (!serializationContext.Result.Failed)
			{
				NHibernateType propValue = instanceOfModel.CommonPrimaryKeyColumnType;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<NHibernateType>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Int32") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "commonPrimaryKeyColumnType", serializedPropValue);
					}
				}
			}
			// CommonPrimaryKeyGenerator
			if (!serializationContext.Result.Failed)
			{
				PrimaryKeyType propValue = instanceOfModel.CommonPrimaryKeyGenerator;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<PrimaryKeyType>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Native") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "commonPrimaryKeyGenerator", serializedPropValue);
					}
				}
			}
			// MemberTemplateFile
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModel.MemberTemplateFile;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "memberTemplateFile", propValue);
	
				}
			}
			// BaseClassPropertyChangedMethod
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModel.BaseClassPropertyChangedMethod;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "baseClassPropertyChangedMethod", propValue);
	
				}
			}
			// BaseClassPropertyChangingMethod
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModel.BaseClassPropertyChangingMethod;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "baseClassPropertyChangingMethod", propValue);
	
				}
			}
			// Access
			if (!serializationContext.Result.Failed)
			{
				PropertyAccess propValue = instanceOfModel.Access;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<PropertyAccess>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Property") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "access", serializedPropValue);
					}
				}
			}
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Model instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WriteElements(serializationContext, element, writer);
	
			Model instance = element as Model;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of Model!");
	
			// Write properties serialized as nested XML elements.
			if (!serializationContext.Result.Failed)
				WritePropertiesAsElements(serializationContext, instance, writer);
			// Write child model elements (which are always serialized as nested XML elements).
			if (!serializationContext.Result.Failed)
				WriteChildElements(serializationContext, instance, writer);
		}
		
	
		/// <summary>
		/// Serialize all properties that need to be stored as nested XML elements.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Model instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		private static void WritePropertiesAsElements(DslModeling::SerializationContext serializationContext, Model element, global::System.Xml.XmlWriter writer)
		{
			// AdditionalImports
			if (!serializationContext.Result.Failed)
			{
				global::System.Collections.Generic.List<Castle.ActiveWriter.Import> propValue = element.AdditionalImports;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Collections.Generic.List<Castle.ActiveWriter.Import>>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
				ActiveWriterSerializationHelper.Instance.WriteElementString(serializationContext, element, writer, "additionalImports", serializedPropValue);
				}
			}
		} 
	
		/// <summary>
		/// Serialize all child model elements.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Model instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Generated code.")]		
		private static void WriteChildElements(DslModeling::SerializationContext serializationContext, Model element, global::System.Xml.XmlWriter writer)
		{
			// ModelHasClass
			global::System.Collections.ObjectModel.ReadOnlyCollection<ModelHasClass> allModelHasClassInstances = ModelHasClass.GetLinksToClasses(element);
			if (!serializationContext.Result.Failed && allModelHasClassInstances.Count > 0)
			{
				writer.WriteStartElement("classes");
				global::System.Type typeofModelHasClass = typeof(ModelHasClass);
				foreach (ModelHasClass eachModelHasClassInstance in allModelHasClassInstances)
				{
					if (serializationContext.Result.Failed)
						break;
	
					if (eachModelHasClassInstance.GetType() != typeofModelHasClass)
					{	// Derived relationships will be serialized in full-form.
						DslModeling::DomainClassXmlSerializer derivedRelSerializer = serializationContext.Directory.GetSerializer(eachModelHasClassInstance.GetDomainClass().Id);
						global::System.Diagnostics.Debug.Assert(derivedRelSerializer != null, "Cannot find serializer for " + eachModelHasClassInstance.GetDomainClass().Name + "!");			
						derivedRelSerializer.Write(serializationContext, eachModelHasClassInstance, writer);
					}
					else
					{	// No need to serialize the relationship itself, just serialize the role-player directly.
						DslModeling::ModelElement targetElement = eachModelHasClassInstance.Class;
						DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
						global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");			
						targetSerializer.Write(serializationContext, targetElement, writer);
					}
				}
				writer.WriteEndElement();
			}
	
			// ModelHasNestedClasses
			global::System.Collections.ObjectModel.ReadOnlyCollection<ModelHasNestedClasses> allModelHasNestedClassesInstances = ModelHasNestedClasses.GetLinksToNestedClasses(element);
			if (!serializationContext.Result.Failed && allModelHasNestedClassesInstances.Count > 0)
			{
				writer.WriteStartElement("nestedClasses");
				global::System.Type typeofModelHasNestedClasses = typeof(ModelHasNestedClasses);
				foreach (ModelHasNestedClasses eachModelHasNestedClassesInstance in allModelHasNestedClassesInstances)
				{
					if (serializationContext.Result.Failed)
						break;
	
					if (eachModelHasNestedClassesInstance.GetType() != typeofModelHasNestedClasses)
					{	// Derived relationships will be serialized in full-form.
						DslModeling::DomainClassXmlSerializer derivedRelSerializer = serializationContext.Directory.GetSerializer(eachModelHasNestedClassesInstance.GetDomainClass().Id);
						global::System.Diagnostics.Debug.Assert(derivedRelSerializer != null, "Cannot find serializer for " + eachModelHasNestedClassesInstance.GetDomainClass().Name + "!");			
						derivedRelSerializer.Write(serializationContext, eachModelHasNestedClassesInstance, writer);
					}
					else
					{	// No need to serialize the relationship itself, just serialize the role-player directly.
						DslModeling::ModelElement targetElement = eachModelHasNestedClassesInstance.NestedClass;
						DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
						global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");			
						targetSerializer.Write(serializationContext, targetElement, writer);
					}
				}
				writer.WriteEndElement();
			}
	
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given Model instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">Model instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the Model instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			Model instance = element as Model;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of Model!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">Model instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	}
}

namespace Castle.ActiveWriter
{
	/// <summary>
	/// Serializer ModelClassSerializer for DomainClass ModelClass.
	/// </summary>
	public partial class ModelClassSerializer : ModelElementWithAccessSerializer
	{
		#region Constructor
		/// <summary>
		/// ModelClassSerializer Constructor
		/// </summary>
		public ModelClassSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of ModelClass.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"modelClass"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of ModelClass.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"modelClassMoniker"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of ModelClass in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"name"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one ModelClass instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the ModelClass element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ModelClass instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					ActiveWriterSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							ActiveWriterSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ModelClass instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			ModelClass instanceOfModelClass = element as ModelClass;
			global::System.Diagnostics.Debug.Assert(instanceOfModelClass != null, "Expecting an instance of ModelClass");
	
			// Cache
			if (!serializationContext.Result.Failed)
			{
				string attribCache = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "cache");
				if (attribCache != null)
				{
					CacheEnum valueOfCache;
					if (DslModeling::SerializationUtilities.TryGetValue<CacheEnum>(serializationContext, attribCache, out valueOfCache))
					{
						instanceOfModelClass.Cache = valueOfCache;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "cache", typeof(CacheEnum), attribCache);
					}
				}
			}
			// DiscriminatorColumn
			if (!serializationContext.Result.Failed)
			{
				string attribDiscriminatorColumn = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "discriminatorColumn");
				if (attribDiscriminatorColumn != null)
				{
					global::System.String valueOfDiscriminatorColumn;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribDiscriminatorColumn, out valueOfDiscriminatorColumn))
					{
						instanceOfModelClass.DiscriminatorColumn = valueOfDiscriminatorColumn;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "discriminatorColumn", typeof(global::System.String), attribDiscriminatorColumn);
					}
				}
			}
			// DiscriminatorType
			if (!serializationContext.Result.Failed)
			{
				string attribDiscriminatorType = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "discriminatorType");
				if (attribDiscriminatorType != null)
				{
					global::System.String valueOfDiscriminatorType;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribDiscriminatorType, out valueOfDiscriminatorType))
					{
						instanceOfModelClass.DiscriminatorType = valueOfDiscriminatorType;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "discriminatorType", typeof(global::System.String), attribDiscriminatorType);
					}
				}
			}
			// DiscriminatorValue
			if (!serializationContext.Result.Failed)
			{
				string attribDiscriminatorValue = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "discriminatorValue");
				if (attribDiscriminatorValue != null)
				{
					global::System.String valueOfDiscriminatorValue;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribDiscriminatorValue, out valueOfDiscriminatorValue))
					{
						instanceOfModelClass.DiscriminatorValue = valueOfDiscriminatorValue;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "discriminatorValue", typeof(global::System.String), attribDiscriminatorValue);
					}
				}
			}
			// Lazy
			if (!serializationContext.Result.Failed)
			{
				string attribLazy = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "lazy");
				if (attribLazy != null)
				{
					global::System.Boolean valueOfLazy;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribLazy, out valueOfLazy))
					{
						instanceOfModelClass.Lazy = valueOfLazy;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "lazy", typeof(global::System.Boolean), attribLazy);
					}
				}
			}
			// Proxy
			if (!serializationContext.Result.Failed)
			{
				string attribProxy = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "proxy");
				if (attribProxy != null)
				{
					global::System.String valueOfProxy;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribProxy, out valueOfProxy))
					{
						instanceOfModelClass.Proxy = valueOfProxy;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "proxy", typeof(global::System.String), attribProxy);
					}
				}
			}
			// Schema
			if (!serializationContext.Result.Failed)
			{
				string attribSchema = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "schema");
				if (attribSchema != null)
				{
					global::System.String valueOfSchema;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribSchema, out valueOfSchema))
					{
						instanceOfModelClass.Schema = valueOfSchema;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "schema", typeof(global::System.String), attribSchema);
					}
				}
			}
			// Table
			if (!serializationContext.Result.Failed)
			{
				string attribTable = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "table");
				if (attribTable != null)
				{
					global::System.String valueOfTable;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribTable, out valueOfTable))
					{
						instanceOfModelClass.Table = valueOfTable;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "table", typeof(global::System.String), attribTable);
					}
				}
			}
			// Where
			if (!serializationContext.Result.Failed)
			{
				string attribWhere = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "where");
				if (attribWhere != null)
				{
					global::System.String valueOfWhere;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribWhere, out valueOfWhere))
					{
						instanceOfModelClass.Where = valueOfWhere;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "where", typeof(global::System.String), attribWhere);
					}
				}
			}
			// DynamicInsert
			if (!serializationContext.Result.Failed)
			{
				string attribDynamicInsert = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "dynamicInsert");
				if (attribDynamicInsert != null)
				{
					global::System.Boolean valueOfDynamicInsert;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribDynamicInsert, out valueOfDynamicInsert))
					{
						instanceOfModelClass.DynamicInsert = valueOfDynamicInsert;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "dynamicInsert", typeof(global::System.Boolean), attribDynamicInsert);
					}
				}
			}
			// DynamicUpdate
			if (!serializationContext.Result.Failed)
			{
				string attribDynamicUpdate = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "dynamicUpdate");
				if (attribDynamicUpdate != null)
				{
					global::System.Boolean valueOfDynamicUpdate;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribDynamicUpdate, out valueOfDynamicUpdate))
					{
						instanceOfModelClass.DynamicUpdate = valueOfDynamicUpdate;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "dynamicUpdate", typeof(global::System.Boolean), attribDynamicUpdate);
					}
				}
			}
			// Persister
			if (!serializationContext.Result.Failed)
			{
				string attribPersister = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "persister");
				if (attribPersister != null)
				{
					global::System.String valueOfPersister;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribPersister, out valueOfPersister))
					{
						instanceOfModelClass.Persister = valueOfPersister;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "persister", typeof(global::System.String), attribPersister);
					}
				}
			}
			// SelectBeforeUpdate
			if (!serializationContext.Result.Failed)
			{
				string attribSelectBeforeUpdate = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "selectBeforeUpdate");
				if (attribSelectBeforeUpdate != null)
				{
					global::System.Boolean valueOfSelectBeforeUpdate;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribSelectBeforeUpdate, out valueOfSelectBeforeUpdate))
					{
						instanceOfModelClass.SelectBeforeUpdate = valueOfSelectBeforeUpdate;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "selectBeforeUpdate", typeof(global::System.Boolean), attribSelectBeforeUpdate);
					}
				}
			}
			// Polymorphism
			if (!serializationContext.Result.Failed)
			{
				string attribPolymorphism = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "polymorphism");
				if (attribPolymorphism != null)
				{
					Polymorphism valueOfPolymorphism;
					if (DslModeling::SerializationUtilities.TryGetValue<Polymorphism>(serializationContext, attribPolymorphism, out valueOfPolymorphism))
					{
						instanceOfModelClass.Polymorphism = valueOfPolymorphism;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "polymorphism", typeof(Polymorphism), attribPolymorphism);
					}
				}
			}
			// Mutable
			if (!serializationContext.Result.Failed)
			{
				string attribMutable = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "mutable");
				if (attribMutable != null)
				{
					global::System.Boolean valueOfMutable;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribMutable, out valueOfMutable))
					{
						instanceOfModelClass.Mutable = valueOfMutable;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "mutable", typeof(global::System.Boolean), attribMutable);
					}
				}
			}
			// BatchSize
			if (!serializationContext.Result.Failed)
			{
				string attribBatchSize = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "batchSize");
				if (attribBatchSize != null)
				{
					global::System.Int32 valueOfBatchSize;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Int32>(serializationContext, attribBatchSize, out valueOfBatchSize))
					{
						instanceOfModelClass.BatchSize = valueOfBatchSize;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "batchSize", typeof(global::System.Int32), attribBatchSize);
					}
				}
			}
			// Locking
			if (!serializationContext.Result.Failed)
			{
				string attribLocking = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "locking");
				if (attribLocking != null)
				{
					OptimisticLocking valueOfLocking;
					if (DslModeling::SerializationUtilities.TryGetValue<OptimisticLocking>(serializationContext, attribLocking, out valueOfLocking))
					{
						instanceOfModelClass.Locking = valueOfLocking;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "locking", typeof(OptimisticLocking), attribLocking);
					}
				}
			}
			// UseAutoImport
			if (!serializationContext.Result.Failed)
			{
				string attribUseAutoImport = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "useAutoImport");
				if (attribUseAutoImport != null)
				{
					global::System.Boolean valueOfUseAutoImport;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribUseAutoImport, out valueOfUseAutoImport))
					{
						instanceOfModelClass.UseAutoImport = valueOfUseAutoImport;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "useAutoImport", typeof(global::System.Boolean), attribUseAutoImport);
					}
				}
			}
			// BaseClassName
			if (!serializationContext.Result.Failed)
			{
				string attribBaseClassName = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "baseClassName");
				if (attribBaseClassName != null)
				{
					global::System.String valueOfBaseClassName;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribBaseClassName, out valueOfBaseClassName))
					{
						instanceOfModelClass.BaseClassName = valueOfBaseClassName;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "baseClassName", typeof(global::System.String), attribBaseClassName);
					}
				}
			}
			// UseGenerics
			if (!serializationContext.Result.Failed)
			{
				string attribUseGenerics = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "useGenerics");
				if (attribUseGenerics != null)
				{
					InheritableBoolean valueOfUseGenerics;
					if (DslModeling::SerializationUtilities.TryGetValue<InheritableBoolean>(serializationContext, attribUseGenerics, out valueOfUseGenerics))
					{
						instanceOfModelClass.UseGenerics = valueOfUseGenerics;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "useGenerics", typeof(InheritableBoolean), attribUseGenerics);
					}
				}
			}
			// ImplementINotifyPropertyChanged
			if (!serializationContext.Result.Failed)
			{
				string attribImplementINotifyPropertyChanged = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "implementINotifyPropertyChanged");
				if (attribImplementINotifyPropertyChanged != null)
				{
					InheritableBoolean valueOfImplementINotifyPropertyChanged;
					if (DslModeling::SerializationUtilities.TryGetValue<InheritableBoolean>(serializationContext, attribImplementINotifyPropertyChanged, out valueOfImplementINotifyPropertyChanged))
					{
						instanceOfModelClass.ImplementINotifyPropertyChanged = valueOfImplementINotifyPropertyChanged;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "implementINotifyPropertyChanged", typeof(InheritableBoolean), attribImplementINotifyPropertyChanged);
					}
				}
			}
			// UseGenericRelations
			if (!serializationContext.Result.Failed)
			{
				string attribUseGenericRelations = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "useGenericRelations");
				if (attribUseGenericRelations != null)
				{
					InheritableBoolean valueOfUseGenericRelations;
					if (DslModeling::SerializationUtilities.TryGetValue<InheritableBoolean>(serializationContext, attribUseGenericRelations, out valueOfUseGenericRelations))
					{
						instanceOfModelClass.UseGenericRelations = valueOfUseGenericRelations;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "useGenericRelations", typeof(InheritableBoolean), attribUseGenericRelations);
					}
				}
			}
			// ImplementINotifyPropertyChanging
			if (!serializationContext.Result.Failed)
			{
				string attribImplementINotifyPropertyChanging = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "implementINotifyPropertyChanging");
				if (attribImplementINotifyPropertyChanging != null)
				{
					InheritableBoolean valueOfImplementINotifyPropertyChanging;
					if (DslModeling::SerializationUtilities.TryGetValue<InheritableBoolean>(serializationContext, attribImplementINotifyPropertyChanging, out valueOfImplementINotifyPropertyChanging))
					{
						instanceOfModelClass.ImplementINotifyPropertyChanging = valueOfImplementINotifyPropertyChanging;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "implementINotifyPropertyChanging", typeof(InheritableBoolean), attribImplementINotifyPropertyChanging);
					}
				}
			}
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ModelClass instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadElements(serializationContext, element, reader);
	
			ModelClass instanceOfModelClass = element as ModelClass;
			global::System.Diagnostics.Debug.Assert(instanceOfModelClass != null, "Expecting an instance of ModelClass!");
	
			// Read child model elements (which are always serialized as nested XML elements).
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
				ReadChildElements(serializationContext, instanceOfModelClass, reader);
		}
	
		/// <summary>
		/// This method deserializes all child model elements.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first child XML element to deserialized.
		/// This method will read as many child elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the 
		///    open tag of the unknown element. This implies that if the first child XML element is unknown, this method 
		///    should return immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="element">In-memory ModelClass instance that will get the deserialized data.</param>
		private static void ReadChildElements(DslModeling::SerializationContext serializationContext, ModelClass element, global::System.Xml.XmlReader reader)
		{
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
					case "targets":	// Relationship "ManyToOneRelation"
						if (reader.IsEmptyElement)
						{	// No instance of this relationship, just skip
							DslModeling::SerializationUtilities.Skip(reader);
						}
						else
						{
							DslModeling::SerializationUtilities.SkipToFirstChild(reader);  // Skip the open tag of <targets>
							ReadManyToOneRelationInstances(serializationContext, element, reader);
							DslModeling::SerializationUtilities.Skip(reader);  // Skip the close tag of </targets>
						}
						break;
					case "properties":	// Relationship "ClassHasProperty"
						if (reader.IsEmptyElement)
						{	// No instance of this relationship, just skip
							DslModeling::SerializationUtilities.Skip(reader);
						}
						else
						{
							DslModeling::SerializationUtilities.SkipToFirstChild(reader);  // Skip the open tag of <properties>
							ReadClassHasPropertyInstances(serializationContext, element, reader);
							DslModeling::SerializationUtilities.Skip(reader);  // Skip the close tag of </properties>
						}
						break;
					case "manyToManyTargets":	// Relationship "ManyToManyRelation"
						if (reader.IsEmptyElement)
						{	// No instance of this relationship, just skip
							DslModeling::SerializationUtilities.Skip(reader);
						}
						else
						{
							DslModeling::SerializationUtilities.SkipToFirstChild(reader);  // Skip the open tag of <manyToManyTargets>
							ReadManyToManyRelationInstances(serializationContext, element, reader);
							DslModeling::SerializationUtilities.Skip(reader);  // Skip the close tag of </manyToManyTargets>
						}
						break;
					case "oneToOneTarget":	// Relationship "OneToOneRelation"
						if (reader.IsEmptyElement)
						{	// No instance of this relationship, just skip
							DslModeling::SerializationUtilities.Skip(reader);
						}
						else
						{
							DslModeling::SerializationUtilities.SkipToFirstChild(reader);  // Skip the open tag of <oneToOneTarget>
							ReadOneToOneRelationInstance(serializationContext, element, reader);
							DslModeling::SerializationUtilities.Skip(reader);  // Skip the close tag of </oneToOneTarget>
						}
						break;
					case "targetModelClasses":	// Relationship "InheritanceRelation"
						if (reader.IsEmptyElement)
						{	// No instance of this relationship, just skip
							DslModeling::SerializationUtilities.Skip(reader);
						}
						else
						{
							DslModeling::SerializationUtilities.SkipToFirstChild(reader);  // Skip the open tag of <targetModelClasses>
							ReadInheritanceRelationInstances(serializationContext, element, reader);
							DslModeling::SerializationUtilities.Skip(reader);  // Skip the close tag of </targetModelClasses>
						}
						break;
					default:
						return;  // Don't know this element.
				}
			}
		}
	
		/// <summary>
		/// Reads all instances of relationship ManyToOneRelation.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first XML element inside the relationship tag, so it can be
		/// either the first instance, or a bogus tag. This method will deserialize all instances and ignore all bogus tags. When the
		/// method returns, the reader will be positioned at the end tag of the relationship (or EOF if somehow that happens).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ModelClass instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1806")]
		private static void ReadManyToOneRelationInstances(DslModeling::SerializationContext serializationContext, ModelClass element, global::System.Xml.XmlReader reader)
		{
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				DslModeling::DomainClassXmlSerializer newManyToOneRelationSerializer = serializationContext.Directory.GetSerializer(ManyToOneRelation.DomainClassId);
				global::System.Diagnostics.Debug.Assert(newManyToOneRelationSerializer != null, "Cannot find serializer for ManyToOneRelation!");
				ManyToOneRelation newManyToOneRelation = newManyToOneRelationSerializer.TryCreateInstance (serializationContext, reader, element.Partition) as ManyToOneRelation;
				if (newManyToOneRelation != null)
				{
					DslModeling::DomainRoleInfo.SetRolePlayer (newManyToOneRelation, ManyToOneRelation.SourceDomainRoleId, element);
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newManyToOneRelation.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newManyToOneRelation.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, newManyToOneRelation, reader);
				}
				else
				{	// Maybe the relationship is serialized in short-form by mistake.
					DslModeling::DomainClassXmlSerializer newModelClassMonikerOfManyToOneRelationSerializer = serializationContext.Directory.GetSerializer(ModelClass.DomainClassId);
					global::System.Diagnostics.Debug.Assert(newModelClassMonikerOfManyToOneRelationSerializer != null, "Cannot find serializer for ModelClass!");
					DslModeling::Moniker newModelClassMonikerOfManyToOneRelation = newModelClassMonikerOfManyToOneRelationSerializer.TryCreateMonikerInstance(serializationContext, reader, element, ManyToOneRelation.DomainClassId, element.Partition);
					if (newModelClassMonikerOfManyToOneRelation != null)
					{
						ActiveWriterSerializationBehaviorSerializationMessages.ExpectingFullFormRelationship(serializationContext, reader, typeof(ManyToOneRelation));
						new ManyToOneRelation(element.Partition, new DslModeling::RoleAssignment(ManyToOneRelation.SourceDomainRoleId, element), new DslModeling::RoleAssignment(ManyToOneRelation.TargetDomainRoleId, newModelClassMonikerOfManyToOneRelation));
						DslModeling::SerializationUtilities.Skip(reader);	// Moniker contains no child XML elements, so just skip.
					}
					else
					{	// Unknown element, skip.
						DslModeling::SerializationUtilities.Skip(reader);
					}
				}
			}
		}
	
		/// <summary>
		/// Reads all instances of relationship ClassHasProperty.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first XML element inside the relationship tag, so it can be
		/// either the first instance, or a bogus tag. This method will deserialize all instances and ignore all bogus tags. When the
		/// method returns, the reader will be positioned at the end tag of the relationship (or EOF if somehow that happens).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ModelClass instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		private static void ReadClassHasPropertyInstances(DslModeling::SerializationContext serializationContext, ModelClass element, global::System.Xml.XmlReader reader)
		{
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				DslModeling::DomainClassXmlSerializer newModelPropertyOfClassHasPropertySerializer = serializationContext.Directory.GetSerializer(ModelProperty.DomainClassId);
				global::System.Diagnostics.Debug.Assert(newModelPropertyOfClassHasPropertySerializer != null, "Cannot find serializer for ModelProperty!");
				ModelProperty newModelPropertyOfClassHasProperty = newModelPropertyOfClassHasPropertySerializer.TryCreateInstance(serializationContext, reader, element.Partition) as ModelProperty;
				if (newModelPropertyOfClassHasProperty != null)
				{
					element.Properties.Add(newModelPropertyOfClassHasProperty);
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newModelPropertyOfClassHasProperty.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newModelPropertyOfClassHasProperty.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, newModelPropertyOfClassHasProperty, reader);
				}
				else
				{
					global::System.Type typeofClassHasProperty = typeof(ClassHasProperty);
					DslModeling::DomainRelationshipXmlSerializer newClassHasPropertySerializer = serializationContext.Directory.GetSerializer(ClassHasProperty.DomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
					global::System.Diagnostics.Debug.Assert(newClassHasPropertySerializer != null, "Cannot find serializer for ClassHasProperty!");
					ClassHasProperty newClassHasProperty = newClassHasPropertySerializer.TryCreateInstance (serializationContext, reader, element.Partition) as ClassHasProperty;
					if (newClassHasProperty != null)
					{
						if (newClassHasProperty.GetType() == typeofClassHasProperty)
						{	// The relationship should be serialized in short-form.
							ActiveWriterSerializationBehaviorSerializationMessages.ExpectingShortFormRelationship(serializationContext, reader, typeof(ClassHasProperty));
						}
						DslModeling::DomainRoleInfo.SetRolePlayer (newClassHasProperty, ClassHasProperty.ModelClassDomainRoleId, element);
						DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newClassHasProperty.GetDomainClass().Id);	
						global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newClassHasProperty.GetDomainClass().Name + "!");
						targetSerializer.Read(serializationContext, newClassHasProperty, reader);
					}
					else
					{	// Unknown element, skip
						DslModeling::SerializationUtilities.Skip(reader);
					}
				}
			}
		}
	
		/// <summary>
		/// Reads all instances of relationship ManyToManyRelation.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first XML element inside the relationship tag, so it can be
		/// either the first instance, or a bogus tag. This method will deserialize all instances and ignore all bogus tags. When the
		/// method returns, the reader will be positioned at the end tag of the relationship (or EOF if somehow that happens).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ModelClass instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1806")]
		private static void ReadManyToManyRelationInstances(DslModeling::SerializationContext serializationContext, ModelClass element, global::System.Xml.XmlReader reader)
		{
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				DslModeling::DomainClassXmlSerializer newManyToManyRelationSerializer = serializationContext.Directory.GetSerializer(ManyToManyRelation.DomainClassId);
				global::System.Diagnostics.Debug.Assert(newManyToManyRelationSerializer != null, "Cannot find serializer for ManyToManyRelation!");
				ManyToManyRelation newManyToManyRelation = newManyToManyRelationSerializer.TryCreateInstance (serializationContext, reader, element.Partition) as ManyToManyRelation;
				if (newManyToManyRelation != null)
				{
					DslModeling::DomainRoleInfo.SetRolePlayer (newManyToManyRelation, ManyToManyRelation.SourceDomainRoleId, element);
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newManyToManyRelation.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newManyToManyRelation.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, newManyToManyRelation, reader);
				}
				else
				{	// Maybe the relationship is serialized in short-form by mistake.
					DslModeling::DomainClassXmlSerializer newModelClassMonikerOfManyToManyRelationSerializer = serializationContext.Directory.GetSerializer(ModelClass.DomainClassId);
					global::System.Diagnostics.Debug.Assert(newModelClassMonikerOfManyToManyRelationSerializer != null, "Cannot find serializer for ModelClass!");
					DslModeling::Moniker newModelClassMonikerOfManyToManyRelation = newModelClassMonikerOfManyToManyRelationSerializer.TryCreateMonikerInstance(serializationContext, reader, element, ManyToManyRelation.DomainClassId, element.Partition);
					if (newModelClassMonikerOfManyToManyRelation != null)
					{
						ActiveWriterSerializationBehaviorSerializationMessages.ExpectingFullFormRelationship(serializationContext, reader, typeof(ManyToManyRelation));
						new ManyToManyRelation(element.Partition, new DslModeling::RoleAssignment(ManyToManyRelation.SourceDomainRoleId, element), new DslModeling::RoleAssignment(ManyToManyRelation.TargetDomainRoleId, newModelClassMonikerOfManyToManyRelation));
						DslModeling::SerializationUtilities.Skip(reader);	// Moniker contains no child XML elements, so just skip.
					}
					else
					{	// Unknown element, skip.
						DslModeling::SerializationUtilities.Skip(reader);
					}
				}
			}
		}
	
		/// <summary>
		/// Reads instance of relationship OneToOneRelation.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first XML element inside the relationship tag, so it can be
		/// either the first instance, or a bogus tag. This method will deserialize only the first valid instance and ignore all the
		/// rest tags (because the multiplicity allows only one instance). When the method returns, the reader will be positioned at 
		/// the end tag of the relationship (or EOF if somehow that happens).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ModelClass instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1806")]
		private static void ReadOneToOneRelationInstance(DslModeling::SerializationContext serializationContext, ModelClass element, global::System.Xml.XmlReader reader)
		{
			if (DslModeling::DomainRoleInfo.GetElementLinks<OneToOneRelation> (element, OneToOneRelation.SourceDomainRoleId).Count > 0)
			{	// Only allow one instance, which already exists, so skip everything
				DslModeling::SerializationUtilities.Skip(reader);	// Moniker contains no child XML elements, so just skip.
				return;
			}
	
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				DslModeling::DomainClassXmlSerializer newOneToOneRelationSerializer = serializationContext.Directory.GetSerializer(OneToOneRelation.DomainClassId);
				global::System.Diagnostics.Debug.Assert(newOneToOneRelationSerializer != null, "Cannot find serializer for OneToOneRelation!");
				OneToOneRelation newOneToOneRelation = newOneToOneRelationSerializer.TryCreateInstance (serializationContext, reader, element.Partition) as OneToOneRelation;
				if (newOneToOneRelation != null)
				{
					DslModeling::DomainRoleInfo.SetRolePlayer (newOneToOneRelation, OneToOneRelation.SourceDomainRoleId, element);
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newOneToOneRelation.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newOneToOneRelation.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, newOneToOneRelation, reader);
					break;	// Only allow one instance.
				}
				else
				{	// Maybe the relationship is serialized in short-form by mistake.
					DslModeling::DomainClassXmlSerializer newModelClassMonikerOfOneToOneRelationSerializer = serializationContext.Directory.GetSerializer(ModelClass.DomainClassId);
					global::System.Diagnostics.Debug.Assert(newModelClassMonikerOfOneToOneRelationSerializer != null, "Cannot find serializer for ModelClass!");
					DslModeling::Moniker newModelClassMonikerOfOneToOneRelation = newModelClassMonikerOfOneToOneRelationSerializer.TryCreateMonikerInstance(serializationContext, reader, element, OneToOneRelation.DomainClassId, element.Partition);
					if (newModelClassMonikerOfOneToOneRelation != null)
					{
						ActiveWriterSerializationBehaviorSerializationMessages.ExpectingFullFormRelationship(serializationContext, reader, typeof(OneToOneRelation));
						new OneToOneRelation(element.Partition, new DslModeling::RoleAssignment(OneToOneRelation.SourceDomainRoleId, element), new DslModeling::RoleAssignment(OneToOneRelation.TargetDomainRoleId, newModelClassMonikerOfOneToOneRelation));
						DslModeling::SerializationUtilities.Skip(reader);	// Moniker contains no child XML elements, so just skip.
						break;	// Only allow one instance.
					}
					else
					{	// Unknown element, skip.
						DslModeling::SerializationUtilities.Skip(reader);
					}
				}
			}
		}
	
		/// <summary>
		/// Reads all instances of relationship InheritanceRelation.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first XML element inside the relationship tag, so it can be
		/// either the first instance, or a bogus tag. This method will deserialize all instances and ignore all bogus tags. When the
		/// method returns, the reader will be positioned at the end tag of the relationship (or EOF if somehow that happens).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ModelClass instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1806")]
		private static void ReadInheritanceRelationInstances(DslModeling::SerializationContext serializationContext, ModelClass element, global::System.Xml.XmlReader reader)
		{
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				DslModeling::DomainClassXmlSerializer newModelClassMonikerOfInheritanceRelationSerializer = serializationContext.Directory.GetSerializer(ModelClass.DomainClassId);
				global::System.Diagnostics.Debug.Assert(newModelClassMonikerOfInheritanceRelationSerializer != null, "Cannot find serializer for ModelClass!");
				DslModeling::Moniker newModelClassMonikerOfInheritanceRelation = newModelClassMonikerOfInheritanceRelationSerializer.TryCreateMonikerInstance(serializationContext, reader, element, InheritanceRelation.DomainClassId, element.Partition);
				if (newModelClassMonikerOfInheritanceRelation != null)
				{
					new InheritanceRelation(element.Partition, new DslModeling::RoleAssignment(InheritanceRelation.SourceModelClassDomainRoleId, element), new DslModeling::RoleAssignment(InheritanceRelation.TargetModelClassDomainRoleId, newModelClassMonikerOfInheritanceRelation));
					DslModeling::SerializationUtilities.Skip(reader);	// Moniker contains no child XML elements, so just skip.
				}
				else
				{
					global::System.Type typeofInheritanceRelation = typeof(InheritanceRelation);
					DslModeling::DomainRelationshipXmlSerializer newInheritanceRelationSerializer = serializationContext.Directory.GetSerializer(InheritanceRelation.DomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
					global::System.Diagnostics.Debug.Assert(newInheritanceRelationSerializer != null, "Cannot find serializer for InheritanceRelation!");
					InheritanceRelation newInheritanceRelation = newInheritanceRelationSerializer.TryCreateInstance (serializationContext, reader, element.Partition) as InheritanceRelation;
					if (newInheritanceRelation != null)
					{
						if (newInheritanceRelation.GetType() == typeofInheritanceRelation)
						{	// The relationship should be serialized in short-form.
							ActiveWriterSerializationBehaviorSerializationMessages.ExpectingShortFormRelationship(serializationContext, reader, typeof(InheritanceRelation));
						}
						DslModeling::DomainRoleInfo.SetRolePlayer (newInheritanceRelation, InheritanceRelation.SourceModelClassDomainRoleId, element);
						DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newInheritanceRelation.GetDomainClass().Id);	
						global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newInheritanceRelation.GetDomainClass().Name + "!");
						targetSerializer.Read(serializationContext, newInheritanceRelation, reader);
					}
					else
					{	// Unknown element, skip
						DslModeling::SerializationUtilities.Skip(reader);
					}
				}
			}
		}
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of ModelClass based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized ModelClass, a new ModelClass instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created ModelClass instance, or null if the reader is not pointing to a serialized ModelClass instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ModelClass" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "ModelClass".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						ModelClassSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ModelClassSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of ModelClass based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of ModelClass.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new ModelClass instance should be created.</param>	
		/// <returns>Created ModelClass instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			return new ModelClass(partition);
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from ModelClass, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from ModelClass.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ModelClass.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including ModelClass itself) instance of ModelClass based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ModelClass" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "ModelClass".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						ModelClassSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ModelClassSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of ModelClass based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				ActiveWriterSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			DslModeling::DomainRelationshipXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(relDomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
			global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for DomainRelationship with Id " + relDomainClassId + "!");
			DslModeling::Moniker result = relSerializer.MonikerizeReference(serializationContext, sourceRolePlayer, ModelClass.DomainClassId, monikerString, partition.Store);
			// Set location info if possible.
			result.Location = serializationContext.Location;
			global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
			if (xmlLineInfo != null)
			{
				result.Line = xmlLineInfo.LineNumber;
				result.Column = xmlLineInfo.LinePosition;
			}
			return result;
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from ModelClass, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from ModelClass.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ModelClass.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized ModelClass instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ModelClass instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the ModelClass instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the ModelClass instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = relSerializer.SerializeReference(serializationContext, sourceRolePlayer, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one ModelClass instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ModelClass instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				ActiveWriterSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ModelClass instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			ModelClass instanceOfModelClass = element as ModelClass;
			global::System.Diagnostics.Debug.Assert(instanceOfModelClass != null, "Expecting an instance of ModelClass");
	
			// Cache
			if (!serializationContext.Result.Failed)
			{
				CacheEnum propValue = instanceOfModelClass.Cache;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<CacheEnum>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Undefined") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "cache", serializedPropValue);
					}
				}
			}
			// DiscriminatorColumn
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModelClass.DiscriminatorColumn;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "discriminatorColumn", propValue);
	
				}
			}
			// DiscriminatorType
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModelClass.DiscriminatorType;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "discriminatorType", propValue);
	
				}
			}
			// DiscriminatorValue
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModelClass.DiscriminatorValue;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "discriminatorValue", propValue);
	
				}
			}
			// Lazy
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfModelClass.Lazy;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "false") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "lazy", serializedPropValue);
					}
				}
			}
			// Proxy
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModelClass.Proxy;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "proxy", propValue);
	
				}
			}
			// Schema
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModelClass.Schema;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "schema", propValue);
	
				}
			}
			// Table
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModelClass.Table;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "table", propValue);
	
				}
			}
			// Where
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModelClass.Where;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "where", propValue);
	
				}
			}
			// DynamicInsert
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfModelClass.DynamicInsert;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "false") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "dynamicInsert", serializedPropValue);
					}
				}
			}
			// DynamicUpdate
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfModelClass.DynamicUpdate;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "false") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "dynamicUpdate", serializedPropValue);
					}
				}
			}
			// Persister
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModelClass.Persister;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "persister", propValue);
	
				}
			}
			// SelectBeforeUpdate
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfModelClass.SelectBeforeUpdate;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "false") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "selectBeforeUpdate", serializedPropValue);
					}
				}
			}
			// Polymorphism
			if (!serializationContext.Result.Failed)
			{
				Polymorphism propValue = instanceOfModelClass.Polymorphism;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<Polymorphism>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Implicit") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "polymorphism", serializedPropValue);
					}
				}
			}
			// Mutable
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfModelClass.Mutable;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "true") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "mutable", serializedPropValue);
					}
				}
			}
			// BatchSize
			if (!serializationContext.Result.Failed)
			{
				global::System.Int32 propValue = instanceOfModelClass.BatchSize;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Int32>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "1") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "batchSize", serializedPropValue);
					}
				}
			}
			// Locking
			if (!serializationContext.Result.Failed)
			{
				OptimisticLocking propValue = instanceOfModelClass.Locking;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<OptimisticLocking>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Version") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "locking", serializedPropValue);
					}
				}
			}
			// UseAutoImport
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfModelClass.UseAutoImport;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "true") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "useAutoImport", serializedPropValue);
					}
				}
			}
			// BaseClassName
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModelClass.BaseClassName;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "baseClassName", propValue);
	
				}
			}
			// UseGenerics
			if (!serializationContext.Result.Failed)
			{
				InheritableBoolean propValue = instanceOfModelClass.UseGenerics;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<InheritableBoolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Inherit") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "useGenerics", serializedPropValue);
					}
				}
			}
			// ImplementINotifyPropertyChanged
			if (!serializationContext.Result.Failed)
			{
				InheritableBoolean propValue = instanceOfModelClass.ImplementINotifyPropertyChanged;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<InheritableBoolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Inherit") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "implementINotifyPropertyChanged", serializedPropValue);
					}
				}
			}
			// UseGenericRelations
			if (!serializationContext.Result.Failed)
			{
				InheritableBoolean propValue = instanceOfModelClass.UseGenericRelations;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<InheritableBoolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Inherit") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "useGenericRelations", serializedPropValue);
					}
				}
			}
			// ImplementINotifyPropertyChanging
			if (!serializationContext.Result.Failed)
			{
				InheritableBoolean propValue = instanceOfModelClass.ImplementINotifyPropertyChanging;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<InheritableBoolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Inherit") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "implementINotifyPropertyChanging", serializedPropValue);
					}
				}
			}
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ModelClass instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WriteElements(serializationContext, element, writer);
	
			ModelClass instance = element as ModelClass;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ModelClass!");
	
			// Write child model elements (which are always serialized as nested XML elements).
			if (!serializationContext.Result.Failed)
				WriteChildElements(serializationContext, instance, writer);
		}
		
	
		/// <summary>
		/// Serialize all child model elements.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ModelClass instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Generated code.")]		
		private static void WriteChildElements(DslModeling::SerializationContext serializationContext, ModelClass element, global::System.Xml.XmlWriter writer)
		{
			// ManyToOneRelation
			global::System.Collections.ObjectModel.ReadOnlyCollection<ManyToOneRelation> allManyToOneRelationInstances = ManyToOneRelation.GetLinksToTargets(element);
			if (!serializationContext.Result.Failed && allManyToOneRelationInstances.Count > 0)
			{
				writer.WriteStartElement("targets");
				foreach (ManyToOneRelation eachManyToOneRelationInstance in allManyToOneRelationInstances)
				{
					if (serializationContext.Result.Failed)
						break;
	
					DslModeling::DomainClassXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(eachManyToOneRelationInstance.GetDomainClass().Id);
					global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for " + eachManyToOneRelationInstance.GetDomainClass().Name + "!");
					relSerializer.Write(serializationContext, eachManyToOneRelationInstance, writer);
				}
				writer.WriteEndElement();
			}
	
			// ClassHasProperty
			global::System.Collections.ObjectModel.ReadOnlyCollection<ClassHasProperty> allClassHasPropertyInstances = ClassHasProperty.GetLinksToProperties(element);
			if (!serializationContext.Result.Failed && allClassHasPropertyInstances.Count > 0)
			{
				writer.WriteStartElement("properties");
				global::System.Type typeofClassHasProperty = typeof(ClassHasProperty);
				foreach (ClassHasProperty eachClassHasPropertyInstance in allClassHasPropertyInstances)
				{
					if (serializationContext.Result.Failed)
						break;
	
					if (eachClassHasPropertyInstance.GetType() != typeofClassHasProperty)
					{	// Derived relationships will be serialized in full-form.
						DslModeling::DomainClassXmlSerializer derivedRelSerializer = serializationContext.Directory.GetSerializer(eachClassHasPropertyInstance.GetDomainClass().Id);
						global::System.Diagnostics.Debug.Assert(derivedRelSerializer != null, "Cannot find serializer for " + eachClassHasPropertyInstance.GetDomainClass().Name + "!");			
						derivedRelSerializer.Write(serializationContext, eachClassHasPropertyInstance, writer);
					}
					else
					{	// No need to serialize the relationship itself, just serialize the role-player directly.
						DslModeling::ModelElement targetElement = eachClassHasPropertyInstance.Property;
						DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
						global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");			
						targetSerializer.Write(serializationContext, targetElement, writer);
					}
				}
				writer.WriteEndElement();
			}
	
			// ManyToManyRelation
			global::System.Collections.ObjectModel.ReadOnlyCollection<ManyToManyRelation> allManyToManyRelationInstances = ManyToManyRelation.GetLinksToManyToManyTargets(element);
			if (!serializationContext.Result.Failed && allManyToManyRelationInstances.Count > 0)
			{
				writer.WriteStartElement("manyToManyTargets");
				foreach (ManyToManyRelation eachManyToManyRelationInstance in allManyToManyRelationInstances)
				{
					if (serializationContext.Result.Failed)
						break;
	
					DslModeling::DomainClassXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(eachManyToManyRelationInstance.GetDomainClass().Id);
					global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for " + eachManyToManyRelationInstance.GetDomainClass().Name + "!");
					relSerializer.Write(serializationContext, eachManyToManyRelationInstance, writer);
				}
				writer.WriteEndElement();
			}
	
			// OneToOneRelation
			OneToOneRelation theOneToOneRelationInstance = OneToOneRelation.GetLinkToOneToOneTarget(element);
			if (!serializationContext.Result.Failed && theOneToOneRelationInstance != null)
			{
				writer.WriteStartElement("oneToOneTarget");
				DslModeling::DomainClassXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(theOneToOneRelationInstance.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for " + theOneToOneRelationInstance.GetDomainClass().Name + "!");
				relSerializer.Write(serializationContext, theOneToOneRelationInstance, writer);
				writer.WriteEndElement();
			}
	
			// InheritanceRelation
			global::System.Collections.ObjectModel.ReadOnlyCollection<InheritanceRelation> allInheritanceRelationInstances = InheritanceRelation.GetLinksToTargetModelClasses(element);
			if (!serializationContext.Result.Failed && allInheritanceRelationInstances.Count > 0)
			{
				DslModeling::DomainRelationshipXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(InheritanceRelation.DomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
				global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for InheritanceRelation!");
	
				writer.WriteStartElement("targetModelClasses");
				global::System.Type typeofInheritanceRelation = typeof(InheritanceRelation);
				foreach (InheritanceRelation eachInheritanceRelationInstance in allInheritanceRelationInstances)
				{
					if (serializationContext.Result.Failed)
						break;
	
					if (eachInheritanceRelationInstance.GetType() != typeofInheritanceRelation)
					{	// Derived relationships will be serialized in full-form.
						DslModeling::DomainClassXmlSerializer derivedRelSerializer = serializationContext.Directory.GetSerializer(eachInheritanceRelationInstance.GetDomainClass().Id);
						global::System.Diagnostics.Debug.Assert(derivedRelSerializer != null, "Cannot find serializer for " + eachInheritanceRelationInstance.GetDomainClass().Name + "!");			
						derivedRelSerializer.Write(serializationContext, eachInheritanceRelationInstance, writer);
					}
					else
					{	// No need to serialize the relationship itself, just serialize the role-player directly.
						DslModeling::ModelElement targetElement = eachInheritanceRelationInstance.TargetModelClass;
						DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
						global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");			
						targetSerializer.WriteMoniker(serializationContext, targetElement, writer, element, relSerializer);
					}
				}
				writer.WriteEndElement();
			}
	
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given ModelClass instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ModelClass instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the ModelClass instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ModelClass instance = element as ModelClass;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ModelClass!");
	
			string key = instance.Name;
			string containerMoniker = null;
			DslModeling::ModelElement container = instance.Model;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				containerMoniker = containerSerializer.CalculateQualifiedName(directory, container);
			}
			if (string.IsNullOrEmpty(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}", key);
			}
			else if (DslModeling::SimpleMonikerResolver.IsFullyQualified(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "{0}/{1}", containerMoniker, key);
			}
			else
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}/{1}", containerMoniker, key);
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ModelClass instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ModelClass instance = element as ModelClass;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ModelClass!");
			DslModeling::ModelElement container = instance.Model;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	}
}

namespace Castle.ActiveWriter
{
	/// <summary>
	/// Serializer ModelPropertySerializer for DomainClass ModelProperty.
	/// </summary>
	public partial class ModelPropertySerializer : ModelElementWithAccessSerializer
	{
		#region Constructor
		/// <summary>
		/// ModelPropertySerializer Constructor
		/// </summary>
		public ModelPropertySerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of ModelProperty.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"modelProperty"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of ModelProperty.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"modelPropertyMoniker"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of ModelProperty in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"name"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one ModelProperty instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the ModelProperty element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ModelProperty instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					ActiveWriterSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						base.ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							ActiveWriterSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ModelProperty instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			ModelProperty instanceOfModelProperty = element as ModelProperty;
			global::System.Diagnostics.Debug.Assert(instanceOfModelProperty != null, "Expecting an instance of ModelProperty");
	
			// Column
			if (!serializationContext.Result.Failed)
			{
				string attribColumn = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "column");
				if (attribColumn != null)
				{
					global::System.String valueOfColumn;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribColumn, out valueOfColumn))
					{
						instanceOfModelProperty.Column = valueOfColumn;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "column", typeof(global::System.String), attribColumn);
					}
				}
			}
			// ColumnType
			if (!serializationContext.Result.Failed)
			{
				string attribColumnType = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "columnType");
				if (attribColumnType != null)
				{
					NHibernateType valueOfColumnType;
					if (DslModeling::SerializationUtilities.TryGetValue<NHibernateType>(serializationContext, attribColumnType, out valueOfColumnType))
					{
						instanceOfModelProperty.ColumnType = valueOfColumnType;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "columnType", typeof(NHibernateType), attribColumnType);
					}
				}
			}
			// CustomColumnType
			if (!serializationContext.Result.Failed)
			{
				string attribCustomColumnType = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "customColumnType");
				if (attribCustomColumnType != null)
				{
					global::System.String valueOfCustomColumnType;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribCustomColumnType, out valueOfCustomColumnType))
					{
						instanceOfModelProperty.CustomColumnType = valueOfCustomColumnType;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "customColumnType", typeof(global::System.String), attribCustomColumnType);
					}
				}
			}
			// CustomMemberType
			if (!serializationContext.Result.Failed)
			{
				string attribCustomMemberType = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "customMemberType");
				if (attribCustomMemberType != null)
				{
					global::System.String valueOfCustomMemberType;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribCustomMemberType, out valueOfCustomMemberType))
					{
						instanceOfModelProperty.CustomMemberType = valueOfCustomMemberType;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "customMemberType", typeof(global::System.String), attribCustomMemberType);
					}
				}
			}
			// Formula
			if (!serializationContext.Result.Failed)
			{
				string attribFormula = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "formula");
				if (attribFormula != null)
				{
					global::System.String valueOfFormula;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribFormula, out valueOfFormula))
					{
						instanceOfModelProperty.Formula = valueOfFormula;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "formula", typeof(global::System.String), attribFormula);
					}
				}
			}
			// Insert
			if (!serializationContext.Result.Failed)
			{
				string attribInsert = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "insert");
				if (attribInsert != null)
				{
					global::System.Boolean valueOfInsert;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribInsert, out valueOfInsert))
					{
						instanceOfModelProperty.Insert = valueOfInsert;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "insert", typeof(global::System.Boolean), attribInsert);
					}
				}
			}
			// Length
			if (!serializationContext.Result.Failed)
			{
				string attribLength = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "length");
				if (attribLength != null)
				{
					global::System.Int32 valueOfLength;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Int32>(serializationContext, attribLength, out valueOfLength))
					{
						instanceOfModelProperty.Length = valueOfLength;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "length", typeof(global::System.Int32), attribLength);
					}
				}
			}
			// NotNull
			if (!serializationContext.Result.Failed)
			{
				string attribNotNull = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "notNull");
				if (attribNotNull != null)
				{
					global::System.Boolean valueOfNotNull;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribNotNull, out valueOfNotNull))
					{
						instanceOfModelProperty.NotNull = valueOfNotNull;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "notNull", typeof(global::System.Boolean), attribNotNull);
					}
				}
			}
			// Unique
			if (!serializationContext.Result.Failed)
			{
				string attribUnique = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "unique");
				if (attribUnique != null)
				{
					global::System.Boolean valueOfUnique;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribUnique, out valueOfUnique))
					{
						instanceOfModelProperty.Unique = valueOfUnique;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "unique", typeof(global::System.Boolean), attribUnique);
					}
				}
			}
			// UnsavedValue
			if (!serializationContext.Result.Failed)
			{
				string attribUnsavedValue = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "unsavedValue");
				if (attribUnsavedValue != null)
				{
					global::System.String valueOfUnsavedValue;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribUnsavedValue, out valueOfUnsavedValue))
					{
						instanceOfModelProperty.UnsavedValue = valueOfUnsavedValue;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "unsavedValue", typeof(global::System.String), attribUnsavedValue);
					}
				}
			}
			// Update
			if (!serializationContext.Result.Failed)
			{
				string attribUpdate = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "update");
				if (attribUpdate != null)
				{
					global::System.Boolean valueOfUpdate;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribUpdate, out valueOfUpdate))
					{
						instanceOfModelProperty.Update = valueOfUpdate;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "update", typeof(global::System.Boolean), attribUpdate);
					}
				}
			}
			// Generator
			if (!serializationContext.Result.Failed)
			{
				string attribGenerator = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "generator");
				if (attribGenerator != null)
				{
					PrimaryKeyType valueOfGenerator;
					if (DslModeling::SerializationUtilities.TryGetValue<PrimaryKeyType>(serializationContext, attribGenerator, out valueOfGenerator))
					{
						instanceOfModelProperty.Generator = valueOfGenerator;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "generator", typeof(PrimaryKeyType), attribGenerator);
					}
				}
			}
			// KeyType
			if (!serializationContext.Result.Failed)
			{
				string attribKeyType = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "keyType");
				if (attribKeyType != null)
				{
					KeyType valueOfKeyType;
					if (DslModeling::SerializationUtilities.TryGetValue<KeyType>(serializationContext, attribKeyType, out valueOfKeyType))
					{
						instanceOfModelProperty.KeyType = valueOfKeyType;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "keyType", typeof(KeyType), attribKeyType);
					}
				}
			}
			// Params
			if (!serializationContext.Result.Failed)
			{
				string attribParams = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "params");
				if (attribParams != null)
				{
					global::System.String valueOfParams;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribParams, out valueOfParams))
					{
						instanceOfModelProperty.Params = valueOfParams;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "params", typeof(global::System.String), attribParams);
					}
				}
			}
			// SequenceName
			if (!serializationContext.Result.Failed)
			{
				string attribSequenceName = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "sequenceName");
				if (attribSequenceName != null)
				{
					global::System.String valueOfSequenceName;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribSequenceName, out valueOfSequenceName))
					{
						instanceOfModelProperty.SequenceName = valueOfSequenceName;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sequenceName", typeof(global::System.String), attribSequenceName);
					}
				}
			}
			// Accessor
			if (!serializationContext.Result.Failed)
			{
				string attribAccessor = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "accessor");
				if (attribAccessor != null)
				{
					Accessor valueOfAccessor;
					if (DslModeling::SerializationUtilities.TryGetValue<Accessor>(serializationContext, attribAccessor, out valueOfAccessor))
					{
						instanceOfModelProperty.Accessor = valueOfAccessor;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "accessor", typeof(Accessor), attribAccessor);
					}
				}
			}
			// CompositeKeyName
			if (!serializationContext.Result.Failed)
			{
				string attribCompositeKeyName = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "compositeKeyName");
				if (attribCompositeKeyName != null)
				{
					global::System.String valueOfCompositeKeyName;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribCompositeKeyName, out valueOfCompositeKeyName))
					{
						instanceOfModelProperty.CompositeKeyName = valueOfCompositeKeyName;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "compositeKeyName", typeof(global::System.String), attribCompositeKeyName);
					}
				}
			}
			// PropertyType
			if (!serializationContext.Result.Failed)
			{
				string attribPropertyType = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "propertyType");
				if (attribPropertyType != null)
				{
					PropertyType valueOfPropertyType;
					if (DslModeling::SerializationUtilities.TryGetValue<PropertyType>(serializationContext, attribPropertyType, out valueOfPropertyType))
					{
						instanceOfModelProperty.PropertyType = valueOfPropertyType;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "propertyType", typeof(PropertyType), attribPropertyType);
					}
				}
			}
			// DebuggerDisplay
			if (!serializationContext.Result.Failed)
			{
				string attribDebuggerDisplay = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "debuggerDisplay");
				if (attribDebuggerDisplay != null)
				{
					global::System.Boolean valueOfDebuggerDisplay;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribDebuggerDisplay, out valueOfDebuggerDisplay))
					{
						instanceOfModelProperty.DebuggerDisplay = valueOfDebuggerDisplay;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "debuggerDisplay", typeof(global::System.Boolean), attribDebuggerDisplay);
					}
				}
			}
			// Validator
			if (!serializationContext.Result.Failed)
			{
				string attribValidator = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "validator");
				if (attribValidator != null)
				{
					global::System.String valueOfValidator;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribValidator, out valueOfValidator))
					{
						instanceOfModelProperty.Validator = valueOfValidator;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "validator", typeof(global::System.String), attribValidator);
					}
				}
			}
			// UniqueKey
			if (!serializationContext.Result.Failed)
			{
				string attribUniqueKey = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "uniqueKey");
				if (attribUniqueKey != null)
				{
					global::System.String valueOfUniqueKey;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribUniqueKey, out valueOfUniqueKey))
					{
						instanceOfModelProperty.UniqueKey = valueOfUniqueKey;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "uniqueKey", typeof(global::System.String), attribUniqueKey);
					}
				}
			}
			// Index
			if (!serializationContext.Result.Failed)
			{
				string attribIndex = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "index");
				if (attribIndex != null)
				{
					global::System.String valueOfIndex;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribIndex, out valueOfIndex))
					{
						instanceOfModelProperty.Index = valueOfIndex;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "index", typeof(global::System.String), attribIndex);
					}
				}
			}
			// SqlType
			if (!serializationContext.Result.Failed)
			{
				string attribSqlType = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "sqlType");
				if (attribSqlType != null)
				{
					global::System.String valueOfSqlType;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribSqlType, out valueOfSqlType))
					{
						instanceOfModelProperty.SqlType = valueOfSqlType;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sqlType", typeof(global::System.String), attribSqlType);
					}
				}
			}
			// Check
			if (!serializationContext.Result.Failed)
			{
				string attribCheck = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "check");
				if (attribCheck != null)
				{
					global::System.String valueOfCheck;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribCheck, out valueOfCheck))
					{
						instanceOfModelProperty.Check = valueOfCheck;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "check", typeof(global::System.String), attribCheck);
					}
				}
			}
			// DefaultMember
			if (!serializationContext.Result.Failed)
			{
				string attribDefaultMember = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "defaultMember");
				if (attribDefaultMember != null)
				{
					global::System.Boolean valueOfDefaultMember;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribDefaultMember, out valueOfDefaultMember))
					{
						instanceOfModelProperty.DefaultMember = valueOfDefaultMember;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "defaultMember", typeof(global::System.Boolean), attribDefaultMember);
					}
				}
			}
			// ColumnDefault
			if (!serializationContext.Result.Failed)
			{
				string attribColumnDefault = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "columnDefault");
				if (attribColumnDefault != null)
				{
					global::System.String valueOfColumnDefault;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribColumnDefault, out valueOfColumnDefault))
					{
						instanceOfModelProperty.ColumnDefault = valueOfColumnDefault;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "columnDefault", typeof(global::System.String), attribColumnDefault);
					}
				}
			}
		}
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of ModelProperty based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized ModelProperty, a new ModelProperty instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created ModelProperty instance, or null if the reader is not pointing to a serialized ModelProperty instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ModelProperty" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "ModelProperty".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						ModelPropertySerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ModelPropertySerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of ModelProperty based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of ModelProperty.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new ModelProperty instance should be created.</param>	
		/// <returns>Created ModelProperty instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (string.IsNullOrEmpty(idStr))
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					ActiveWriterSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				return new ModelProperty(partition, new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id));
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				ActiveWriterSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				ActiveWriterSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				ActiveWriterSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from ModelProperty, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from ModelProperty.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ModelProperty.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including ModelProperty itself) instance of ModelProperty based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ModelProperty" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "ModelProperty".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						ModelPropertySerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ModelPropertySerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of ModelProperty based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				ActiveWriterSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			DslModeling::DomainRelationshipXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(relDomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
			global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for DomainRelationship with Id " + relDomainClassId + "!");
			DslModeling::Moniker result = relSerializer.MonikerizeReference(serializationContext, sourceRolePlayer, ModelProperty.DomainClassId, monikerString, partition.Store);
			// Set location info if possible.
			result.Location = serializationContext.Location;
			global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
			if (xmlLineInfo != null)
			{
				result.Line = xmlLineInfo.LineNumber;
				result.Column = xmlLineInfo.LinePosition;
			}
			return result;
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from ModelProperty, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from ModelProperty.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ModelProperty.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized ModelProperty instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ModelProperty instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the ModelProperty instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the ModelProperty instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = relSerializer.SerializeReference(serializationContext, sourceRolePlayer, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one ModelProperty instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ModelProperty instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				ActiveWriterSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				base.WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ModelProperty instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			ModelProperty instanceOfModelProperty = element as ModelProperty;
			global::System.Diagnostics.Debug.Assert(instanceOfModelProperty != null, "Expecting an instance of ModelProperty");
	
			// Column
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModelProperty.Column;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "column", propValue);
	
				}
			}
			// ColumnType
			if (!serializationContext.Result.Failed)
			{
				NHibernateType propValue = instanceOfModelProperty.ColumnType;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<NHibernateType>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "String") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "columnType", serializedPropValue);
					}
				}
			}
			// CustomColumnType
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModelProperty.CustomColumnType;
				if (!serializationContext.Result.Failed)
				{
					if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, string.Empty) != 0))
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "customColumnType", propValue);
					}
				}
			}
			// CustomMemberType
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModelProperty.CustomMemberType;
				if (!serializationContext.Result.Failed)
				{
					if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, string.Empty) != 0))
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "customMemberType", propValue);
					}
				}
			}
			// Formula
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModelProperty.Formula;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "formula", propValue);
	
				}
			}
			// Insert
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfModelProperty.Insert;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "true") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "insert", serializedPropValue);
					}
				}
			}
			// Length
			if (!serializationContext.Result.Failed)
			{
				global::System.Int32 propValue = instanceOfModelProperty.Length;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Int32>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "length", serializedPropValue);
				}
			}
			// NotNull
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfModelProperty.NotNull;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "false") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "notNull", serializedPropValue);
					}
				}
			}
			// Unique
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfModelProperty.Unique;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "false") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "unique", serializedPropValue);
					}
				}
			}
			// UnsavedValue
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModelProperty.UnsavedValue;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "unsavedValue", propValue);
	
				}
			}
			// Update
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfModelProperty.Update;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "true") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "update", serializedPropValue);
					}
				}
			}
			// Generator
			if (!serializationContext.Result.Failed)
			{
				PrimaryKeyType propValue = instanceOfModelProperty.Generator;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<PrimaryKeyType>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Native") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "generator", serializedPropValue);
					}
				}
			}
			// KeyType
			if (!serializationContext.Result.Failed)
			{
				KeyType propValue = instanceOfModelProperty.KeyType;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<KeyType>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "None") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "keyType", serializedPropValue);
					}
				}
			}
			// Params
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModelProperty.Params;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "params", propValue);
	
				}
			}
			// SequenceName
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModelProperty.SequenceName;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "sequenceName", propValue);
	
				}
			}
			// Accessor
			if (!serializationContext.Result.Failed)
			{
				Accessor propValue = instanceOfModelProperty.Accessor;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<Accessor>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Public") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "accessor", serializedPropValue);
					}
				}
			}
			// CompositeKeyName
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModelProperty.CompositeKeyName;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "compositeKeyName", propValue);
	
				}
			}
			// PropertyType
			if (!serializationContext.Result.Failed)
			{
				PropertyType propValue = instanceOfModelProperty.PropertyType;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<PropertyType>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Property") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "propertyType", serializedPropValue);
					}
				}
			}
			// DebuggerDisplay
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfModelProperty.DebuggerDisplay;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "false") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "debuggerDisplay", serializedPropValue);
					}
				}
			}
			// Validator
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModelProperty.Validator;
				if (!serializationContext.Result.Failed)
				{
					if (propValue != null)
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "validator", propValue);
				}
			}
			// UniqueKey
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModelProperty.UniqueKey;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "uniqueKey", propValue);
	
				}
			}
			// Index
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModelProperty.Index;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "index", propValue);
	
				}
			}
			// SqlType
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModelProperty.SqlType;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "sqlType", propValue);
	
				}
			}
			// Check
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModelProperty.Check;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "check", propValue);
	
				}
			}
			// DefaultMember
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfModelProperty.DefaultMember;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "false") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "defaultMember", serializedPropValue);
					}
				}
			}
			// ColumnDefault
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModelProperty.ColumnDefault;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "columnDefault", propValue);
	
				}
			}
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given ModelProperty instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ModelProperty instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the ModelProperty instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ModelProperty instance = element as ModelProperty;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ModelProperty!");
	
			string key = instance.Name;
			string containerMoniker = null;
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				containerMoniker = containerSerializer.CalculateQualifiedName(directory, container);
			}
			if (string.IsNullOrEmpty(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}", key);
			}
			else if (DslModeling::SimpleMonikerResolver.IsFullyQualified(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "{0}/{1}", containerMoniker, key);
			}
			else
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}/{1}", containerMoniker, key);
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ModelProperty instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ModelProperty instance = element as ModelProperty;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ModelProperty!");
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	}
}

namespace Castle.ActiveWriter
{
	/// <summary>
	/// Serializer ModelElementWithAccessSerializer for DomainClass ModelElementWithAccess.
	/// </summary>
	public partial class ModelElementWithAccessSerializer : NamedElementSerializer
	{
		#region Constructor
		/// <summary>
		/// ModelElementWithAccessSerializer Constructor
		/// </summary>
		public ModelElementWithAccessSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// Cannot be serialized.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
	
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// ModelElementWithAccess is abstract and cannot be instantiated, so this method throws NotSupportedException.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the ModelElementWithAccess element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ModelElementWithAccess instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ModelElementWithAccess instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			ModelElementWithAccess instanceOfModelElementWithAccess = element as ModelElementWithAccess;
			global::System.Diagnostics.Debug.Assert(instanceOfModelElementWithAccess != null, "Expecting an instance of ModelElementWithAccess");
	
			// CustomAccess
			if (!serializationContext.Result.Failed)
			{
				string attribCustomAccess = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "customAccess");
				if (attribCustomAccess != null)
				{
					global::System.String valueOfCustomAccess;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribCustomAccess, out valueOfCustomAccess))
					{
						instanceOfModelElementWithAccess.CustomAccess = valueOfCustomAccess;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "customAccess", typeof(global::System.String), attribCustomAccess);
					}
				}
			}
			// Access
			if (!serializationContext.Result.Failed)
			{
				string attribAccess = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "access");
				if (attribAccess != null)
				{
					InheritablePropertyAccess valueOfAccess;
					if (DslModeling::SerializationUtilities.TryGetValue<InheritablePropertyAccess>(serializationContext, attribAccess, out valueOfAccess))
					{
						instanceOfModelElementWithAccess.Access = valueOfAccess;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "access", typeof(InheritablePropertyAccess), attribAccess);
					}
				}
			}
		}
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of ModelElementWithAccess based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized ModelElementWithAccess, a new ModelElementWithAccess instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created ModelElementWithAccess instance, or null if the reader is not pointing to a serialized ModelElementWithAccess instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				// Check for derived classes of "ModelElementWithAccess".
				if (this.derivedClasses == null)
					this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
				global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
				DslModeling::DomainClassInfo derivedClass = null;
				if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
				{	// New derived class instance.
					ModelElementWithAccessSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ModelElementWithAccessSerializer;
					global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
					result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of ModelElementWithAccess based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of ModelElementWithAccess.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new ModelElementWithAccess instance should be created.</param>	
		/// <returns>Created ModelElementWithAccess instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			// Abstract class, cannot be serialized.
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from ModelElementWithAccess, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from ModelElementWithAccess.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ModelElementWithAccess.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including ModelElementWithAccess itself) instance of ModelElementWithAccess based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				// Check for derived classes of "ModelElementWithAccess".
				if (this.derivedClassMonikers == null)
					this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
				global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
				DslModeling::DomainClassInfo derivedClass = null;
				if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
				{	// New derived class moniker instance.
					ModelElementWithAccessSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ModelElementWithAccessSerializer;
					global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
					result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of ModelElementWithAccess based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				ActiveWriterSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			DslModeling::DomainRelationshipXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(relDomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
			global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for DomainRelationship with Id " + relDomainClassId + "!");
			DslModeling::Moniker result = relSerializer.MonikerizeReference(serializationContext, sourceRolePlayer, ModelElementWithAccess.DomainClassId, monikerString, partition.Store);
			// Set location info if possible.
			result.Location = serializationContext.Location;
			global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
			if (xmlLineInfo != null)
			{
				result.Line = xmlLineInfo.LineNumber;
				result.Column = xmlLineInfo.LinePosition;
			}
			return result;
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from ModelElementWithAccess, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from ModelElementWithAccess.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ModelElementWithAccess.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized ModelElementWithAccess instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ModelElementWithAccess instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the ModelElementWithAccess instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the ModelElementWithAccess instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			// Instance of ModelElementWithAccess cannot be monikerized.
			ActiveWriterSerializationBehaviorSerializationMessages.CannotMonikerizeElement(serializationContext, "ModelElementWithAccess");
		}
		
		/// <summary>
		/// Public Write() method that serializes one ModelElementWithAccess instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ModelElementWithAccess instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ModelElementWithAccess instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			ModelElementWithAccess instanceOfModelElementWithAccess = element as ModelElementWithAccess;
			global::System.Diagnostics.Debug.Assert(instanceOfModelElementWithAccess != null, "Expecting an instance of ModelElementWithAccess");
	
			// CustomAccess
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModelElementWithAccess.CustomAccess;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "customAccess", propValue);
	
				}
			}
			// Access
			if (!serializationContext.Result.Failed)
			{
				InheritablePropertyAccess propValue = instanceOfModelElementWithAccess.Access;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<InheritablePropertyAccess>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Inherit") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "access", serializedPropValue);
					}
				}
			}
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given ModelElementWithAccess instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ModelElementWithAccess instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the ModelElementWithAccess instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ModelElementWithAccess instance = element as ModelElementWithAccess;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ModelElementWithAccess!");
	
			string key = instance.Name;
			string containerMoniker = null;
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				containerMoniker = containerSerializer.CalculateQualifiedName(directory, container);
			}
			if (string.IsNullOrEmpty(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}", key);
			}
			else if (DslModeling::SimpleMonikerResolver.IsFullyQualified(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "{0}/{1}", containerMoniker, key);
			}
			else
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}/{1}", containerMoniker, key);
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ModelElementWithAccess instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ModelElementWithAccess instance = element as ModelElementWithAccess;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ModelElementWithAccess!");
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	}
}

namespace Castle.ActiveWriter
{
	/// <summary>
	/// Serializer NamedElementSerializer for DomainClass NamedElement.
	/// </summary>
	public partial class NamedElementSerializer : DslModeling::DomainClassXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// NamedElementSerializer Constructor
		/// </summary>
		public NamedElementSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// Cannot be serialized.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
	
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// NamedElement is abstract and cannot be instantiated, so this method throws NotSupportedException.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the NamedElement element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory NamedElement instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory NamedElement instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			NamedElement instanceOfNamedElement = element as NamedElement;
			global::System.Diagnostics.Debug.Assert(instanceOfNamedElement != null, "Expecting an instance of NamedElement");
	
			// Name
			if (!serializationContext.Result.Failed)
			{
				string attribName = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "name");
				if (attribName != null)
				{
					global::System.String valueOfName;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribName, out valueOfName))
					{
						instanceOfNamedElement.Name = valueOfName;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "name", typeof(global::System.String), attribName);
					}
				}
			}
			// Description
			if (!serializationContext.Result.Failed)
			{
				string attribDescription = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "description");
				if (attribDescription != null)
				{
					global::System.String valueOfDescription;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribDescription, out valueOfDescription))
					{
						instanceOfNamedElement.Description = valueOfDescription;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "description", typeof(global::System.String), attribDescription);
					}
				}
			}
		}
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of NamedElement based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized NamedElement, a new NamedElement instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created NamedElement instance, or null if the reader is not pointing to a serialized NamedElement instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				// Check for derived classes of "NamedElement".
				if (this.derivedClasses == null)
					this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
				global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
				DslModeling::DomainClassInfo derivedClass = null;
				if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
				{	// New derived class instance.
					NamedElementSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as NamedElementSerializer;
					global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
					result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of NamedElement based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of NamedElement.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new NamedElement instance should be created.</param>	
		/// <returns>Created NamedElement instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			// Abstract class, cannot be serialized.
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from NamedElement, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from NamedElement.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(NamedElement.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including NamedElement itself) instance of NamedElement based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				// Check for derived classes of "NamedElement".
				if (this.derivedClassMonikers == null)
					this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
				global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
				DslModeling::DomainClassInfo derivedClass = null;
				if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
				{	// New derived class moniker instance.
					NamedElementSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as NamedElementSerializer;
					global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
					result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of NamedElement based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				ActiveWriterSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			DslModeling::DomainRelationshipXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(relDomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
			global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for DomainRelationship with Id " + relDomainClassId + "!");
			DslModeling::Moniker result = relSerializer.MonikerizeReference(serializationContext, sourceRolePlayer, NamedElement.DomainClassId, monikerString, partition.Store);
			// Set location info if possible.
			result.Location = serializationContext.Location;
			global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
			if (xmlLineInfo != null)
			{
				result.Line = xmlLineInfo.LineNumber;
				result.Column = xmlLineInfo.LinePosition;
			}
			return result;
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from NamedElement, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from NamedElement.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(NamedElement.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized NamedElement instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">NamedElement instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the NamedElement instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the NamedElement instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			// Instance of NamedElement cannot be monikerized.
			ActiveWriterSerializationBehaviorSerializationMessages.CannotMonikerizeElement(serializationContext, "NamedElement");
		}
		
		/// <summary>
		/// Public Write() method that serializes one NamedElement instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">NamedElement instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">NamedElement instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			NamedElement instanceOfNamedElement = element as NamedElement;
			global::System.Diagnostics.Debug.Assert(instanceOfNamedElement != null, "Expecting an instance of NamedElement");
	
			// Name
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfNamedElement.Name;
				if (!serializationContext.Result.Failed)
				{
					ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "name", propValue);
				}
			}
			// Description
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfNamedElement.Description;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "description", propValue);
	
				}
			}
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given NamedElement instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">NamedElement instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the NamedElement instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			NamedElement instance = element as NamedElement;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of NamedElement!");
	
			string key = instance.Name;
			string containerMoniker = null;
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				containerMoniker = containerSerializer.CalculateQualifiedName(directory, container);
			}
			if (string.IsNullOrEmpty(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}", key);
			}
			else if (DslModeling::SimpleMonikerResolver.IsFullyQualified(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "{0}/{1}", containerMoniker, key);
			}
			else
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}/{1}", containerMoniker, key);
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">NamedElement instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			NamedElement instance = element as NamedElement;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of NamedElement!");
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	}
}

namespace Castle.ActiveWriter
{
	/// <summary>
	/// Serializer NestedClassSerializer for DomainClass NestedClass.
	/// </summary>
	public partial class NestedClassSerializer : NamedElementSerializer
	{
		#region Constructor
		/// <summary>
		/// NestedClassSerializer Constructor
		/// </summary>
		public NestedClassSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of NestedClass.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"nestedClass"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of NestedClass.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"nestedClassMoniker"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of NestedClass in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"name"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one NestedClass instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the NestedClass element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory NestedClass instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					ActiveWriterSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							ActiveWriterSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory NestedClass instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			NestedClass instanceOfNestedClass = element as NestedClass;
			global::System.Diagnostics.Debug.Assert(instanceOfNestedClass != null, "Expecting an instance of NestedClass");
	
			// ImplementINotifyPropertyChanged
			if (!serializationContext.Result.Failed)
			{
				string attribImplementINotifyPropertyChanged = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "implementINotifyPropertyChanged");
				if (attribImplementINotifyPropertyChanged != null)
				{
					InheritableBoolean valueOfImplementINotifyPropertyChanged;
					if (DslModeling::SerializationUtilities.TryGetValue<InheritableBoolean>(serializationContext, attribImplementINotifyPropertyChanged, out valueOfImplementINotifyPropertyChanged))
					{
						instanceOfNestedClass.ImplementINotifyPropertyChanged = valueOfImplementINotifyPropertyChanged;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "implementINotifyPropertyChanged", typeof(InheritableBoolean), attribImplementINotifyPropertyChanged);
					}
				}
			}
			// ImplementINotifyPropertyChanging
			if (!serializationContext.Result.Failed)
			{
				string attribImplementINotifyPropertyChanging = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "implementINotifyPropertyChanging");
				if (attribImplementINotifyPropertyChanging != null)
				{
					InheritableBoolean valueOfImplementINotifyPropertyChanging;
					if (DslModeling::SerializationUtilities.TryGetValue<InheritableBoolean>(serializationContext, attribImplementINotifyPropertyChanging, out valueOfImplementINotifyPropertyChanging))
					{
						instanceOfNestedClass.ImplementINotifyPropertyChanging = valueOfImplementINotifyPropertyChanging;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "implementINotifyPropertyChanging", typeof(InheritableBoolean), attribImplementINotifyPropertyChanging);
					}
				}
			}
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory NestedClass instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadElements(serializationContext, element, reader);
	
			NestedClass instanceOfNestedClass = element as NestedClass;
			global::System.Diagnostics.Debug.Assert(instanceOfNestedClass != null, "Expecting an instance of NestedClass!");
	
			// Read child model elements (which are always serialized as nested XML elements).
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
				ReadChildElements(serializationContext, instanceOfNestedClass, reader);
		}
	
		/// <summary>
		/// This method deserializes all child model elements.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first child XML element to deserialized.
		/// This method will read as many child elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the 
		///    open tag of the unknown element. This implies that if the first child XML element is unknown, this method 
		///    should return immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="element">In-memory NestedClass instance that will get the deserialized data.</param>
		private static void ReadChildElements(DslModeling::SerializationContext serializationContext, NestedClass element, global::System.Xml.XmlReader reader)
		{
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
					case "properties":	// Relationship "NestedClassHasProperties"
						if (reader.IsEmptyElement)
						{	// No instance of this relationship, just skip
							DslModeling::SerializationUtilities.Skip(reader);
						}
						else
						{
							DslModeling::SerializationUtilities.SkipToFirstChild(reader);  // Skip the open tag of <properties>
							ReadNestedClassHasPropertiesInstances(serializationContext, element, reader);
							DslModeling::SerializationUtilities.Skip(reader);  // Skip the close tag of </properties>
						}
						break;
					case "modelClasses":	// Relationship "NestedClassReferencesModelClasses"
						if (reader.IsEmptyElement)
						{	// No instance of this relationship, just skip
							DslModeling::SerializationUtilities.Skip(reader);
						}
						else
						{
							DslModeling::SerializationUtilities.SkipToFirstChild(reader);  // Skip the open tag of <modelClasses>
							ReadNestedClassReferencesModelClassesInstances(serializationContext, element, reader);
							DslModeling::SerializationUtilities.Skip(reader);  // Skip the close tag of </modelClasses>
						}
						break;
					default:
						return;  // Don't know this element.
				}
			}
		}
	
		/// <summary>
		/// Reads all instances of relationship NestedClassHasProperties.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first XML element inside the relationship tag, so it can be
		/// either the first instance, or a bogus tag. This method will deserialize all instances and ignore all bogus tags. When the
		/// method returns, the reader will be positioned at the end tag of the relationship (or EOF if somehow that happens).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory NestedClass instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		private static void ReadNestedClassHasPropertiesInstances(DslModeling::SerializationContext serializationContext, NestedClass element, global::System.Xml.XmlReader reader)
		{
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				DslModeling::DomainClassXmlSerializer newModelPropertyOfNestedClassHasPropertiesSerializer = serializationContext.Directory.GetSerializer(ModelProperty.DomainClassId);
				global::System.Diagnostics.Debug.Assert(newModelPropertyOfNestedClassHasPropertiesSerializer != null, "Cannot find serializer for ModelProperty!");
				ModelProperty newModelPropertyOfNestedClassHasProperties = newModelPropertyOfNestedClassHasPropertiesSerializer.TryCreateInstance(serializationContext, reader, element.Partition) as ModelProperty;
				if (newModelPropertyOfNestedClassHasProperties != null)
				{
					element.Properties.Add(newModelPropertyOfNestedClassHasProperties);
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newModelPropertyOfNestedClassHasProperties.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newModelPropertyOfNestedClassHasProperties.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, newModelPropertyOfNestedClassHasProperties, reader);
				}
				else
				{
					global::System.Type typeofNestedClassHasProperties = typeof(NestedClassHasProperties);
					DslModeling::DomainRelationshipXmlSerializer newNestedClassHasPropertiesSerializer = serializationContext.Directory.GetSerializer(NestedClassHasProperties.DomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
					global::System.Diagnostics.Debug.Assert(newNestedClassHasPropertiesSerializer != null, "Cannot find serializer for NestedClassHasProperties!");
					NestedClassHasProperties newNestedClassHasProperties = newNestedClassHasPropertiesSerializer.TryCreateInstance (serializationContext, reader, element.Partition) as NestedClassHasProperties;
					if (newNestedClassHasProperties != null)
					{
						if (newNestedClassHasProperties.GetType() == typeofNestedClassHasProperties)
						{	// The relationship should be serialized in short-form.
							ActiveWriterSerializationBehaviorSerializationMessages.ExpectingShortFormRelationship(serializationContext, reader, typeof(NestedClassHasProperties));
						}
						DslModeling::DomainRoleInfo.SetRolePlayer (newNestedClassHasProperties, NestedClassHasProperties.NestedClassDomainRoleId, element);
						DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newNestedClassHasProperties.GetDomainClass().Id);	
						global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newNestedClassHasProperties.GetDomainClass().Name + "!");
						targetSerializer.Read(serializationContext, newNestedClassHasProperties, reader);
					}
					else
					{	// Unknown element, skip
						DslModeling::SerializationUtilities.Skip(reader);
					}
				}
			}
		}
	
		/// <summary>
		/// Reads all instances of relationship NestedClassReferencesModelClasses.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first XML element inside the relationship tag, so it can be
		/// either the first instance, or a bogus tag. This method will deserialize all instances and ignore all bogus tags. When the
		/// method returns, the reader will be positioned at the end tag of the relationship (or EOF if somehow that happens).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory NestedClass instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1806")]
		private static void ReadNestedClassReferencesModelClassesInstances(DslModeling::SerializationContext serializationContext, NestedClass element, global::System.Xml.XmlReader reader)
		{
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				DslModeling::DomainClassXmlSerializer newNestedClassReferencesModelClassesSerializer = serializationContext.Directory.GetSerializer(NestedClassReferencesModelClasses.DomainClassId);
				global::System.Diagnostics.Debug.Assert(newNestedClassReferencesModelClassesSerializer != null, "Cannot find serializer for NestedClassReferencesModelClasses!");
				NestedClassReferencesModelClasses newNestedClassReferencesModelClasses = newNestedClassReferencesModelClassesSerializer.TryCreateInstance (serializationContext, reader, element.Partition) as NestedClassReferencesModelClasses;
				if (newNestedClassReferencesModelClasses != null)
				{
					DslModeling::DomainRoleInfo.SetRolePlayer (newNestedClassReferencesModelClasses, NestedClassReferencesModelClasses.NestedClassDomainRoleId, element);
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newNestedClassReferencesModelClasses.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newNestedClassReferencesModelClasses.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, newNestedClassReferencesModelClasses, reader);
				}
				else
				{	// Maybe the relationship is serialized in short-form by mistake.
					DslModeling::DomainClassXmlSerializer newModelClassMonikerOfNestedClassReferencesModelClassesSerializer = serializationContext.Directory.GetSerializer(ModelClass.DomainClassId);
					global::System.Diagnostics.Debug.Assert(newModelClassMonikerOfNestedClassReferencesModelClassesSerializer != null, "Cannot find serializer for ModelClass!");
					DslModeling::Moniker newModelClassMonikerOfNestedClassReferencesModelClasses = newModelClassMonikerOfNestedClassReferencesModelClassesSerializer.TryCreateMonikerInstance(serializationContext, reader, element, NestedClassReferencesModelClasses.DomainClassId, element.Partition);
					if (newModelClassMonikerOfNestedClassReferencesModelClasses != null)
					{
						ActiveWriterSerializationBehaviorSerializationMessages.ExpectingFullFormRelationship(serializationContext, reader, typeof(NestedClassReferencesModelClasses));
						new NestedClassReferencesModelClasses(element.Partition, new DslModeling::RoleAssignment(NestedClassReferencesModelClasses.NestedClassDomainRoleId, element), new DslModeling::RoleAssignment(NestedClassReferencesModelClasses.ModelClassDomainRoleId, newModelClassMonikerOfNestedClassReferencesModelClasses));
						DslModeling::SerializationUtilities.Skip(reader);	// Moniker contains no child XML elements, so just skip.
					}
					else
					{	// Unknown element, skip.
						DslModeling::SerializationUtilities.Skip(reader);
					}
				}
			}
		}
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of NestedClass based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized NestedClass, a new NestedClass instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created NestedClass instance, or null if the reader is not pointing to a serialized NestedClass instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "NestedClass" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "NestedClass".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						NestedClassSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as NestedClassSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of NestedClass based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of NestedClass.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new NestedClass instance should be created.</param>	
		/// <returns>Created NestedClass instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			return new NestedClass(partition);
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from NestedClass, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from NestedClass.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(NestedClass.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including NestedClass itself) instance of NestedClass based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "NestedClass" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "NestedClass".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						NestedClassSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as NestedClassSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of NestedClass based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				ActiveWriterSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			DslModeling::DomainRelationshipXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(relDomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
			global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for DomainRelationship with Id " + relDomainClassId + "!");
			DslModeling::Moniker result = relSerializer.MonikerizeReference(serializationContext, sourceRolePlayer, NestedClass.DomainClassId, monikerString, partition.Store);
			// Set location info if possible.
			result.Location = serializationContext.Location;
			global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
			if (xmlLineInfo != null)
			{
				result.Line = xmlLineInfo.LineNumber;
				result.Column = xmlLineInfo.LinePosition;
			}
			return result;
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from NestedClass, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from NestedClass.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(NestedClass.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized NestedClass instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">NestedClass instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the NestedClass instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the NestedClass instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = relSerializer.SerializeReference(serializationContext, sourceRolePlayer, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one NestedClass instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">NestedClass instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				ActiveWriterSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">NestedClass instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			NestedClass instanceOfNestedClass = element as NestedClass;
			global::System.Diagnostics.Debug.Assert(instanceOfNestedClass != null, "Expecting an instance of NestedClass");
	
			// ImplementINotifyPropertyChanged
			if (!serializationContext.Result.Failed)
			{
				InheritableBoolean propValue = instanceOfNestedClass.ImplementINotifyPropertyChanged;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<InheritableBoolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Inherit") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "implementINotifyPropertyChanged", serializedPropValue);
					}
				}
			}
			// ImplementINotifyPropertyChanging
			if (!serializationContext.Result.Failed)
			{
				InheritableBoolean propValue = instanceOfNestedClass.ImplementINotifyPropertyChanging;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<InheritableBoolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Inherit") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "implementINotifyPropertyChanging", serializedPropValue);
					}
				}
			}
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">NestedClass instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WriteElements(serializationContext, element, writer);
	
			NestedClass instance = element as NestedClass;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of NestedClass!");
	
			// Write child model elements (which are always serialized as nested XML elements).
			if (!serializationContext.Result.Failed)
				WriteChildElements(serializationContext, instance, writer);
		}
		
	
		/// <summary>
		/// Serialize all child model elements.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">NestedClass instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Generated code.")]		
		private static void WriteChildElements(DslModeling::SerializationContext serializationContext, NestedClass element, global::System.Xml.XmlWriter writer)
		{
			// NestedClassHasProperties
			global::System.Collections.ObjectModel.ReadOnlyCollection<NestedClassHasProperties> allNestedClassHasPropertiesInstances = NestedClassHasProperties.GetLinksToProperties(element);
			if (!serializationContext.Result.Failed && allNestedClassHasPropertiesInstances.Count > 0)
			{
				writer.WriteStartElement("properties");
				global::System.Type typeofNestedClassHasProperties = typeof(NestedClassHasProperties);
				foreach (NestedClassHasProperties eachNestedClassHasPropertiesInstance in allNestedClassHasPropertiesInstances)
				{
					if (serializationContext.Result.Failed)
						break;
	
					if (eachNestedClassHasPropertiesInstance.GetType() != typeofNestedClassHasProperties)
					{	// Derived relationships will be serialized in full-form.
						DslModeling::DomainClassXmlSerializer derivedRelSerializer = serializationContext.Directory.GetSerializer(eachNestedClassHasPropertiesInstance.GetDomainClass().Id);
						global::System.Diagnostics.Debug.Assert(derivedRelSerializer != null, "Cannot find serializer for " + eachNestedClassHasPropertiesInstance.GetDomainClass().Name + "!");			
						derivedRelSerializer.Write(serializationContext, eachNestedClassHasPropertiesInstance, writer);
					}
					else
					{	// No need to serialize the relationship itself, just serialize the role-player directly.
						DslModeling::ModelElement targetElement = eachNestedClassHasPropertiesInstance.Property;
						DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
						global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");			
						targetSerializer.Write(serializationContext, targetElement, writer);
					}
				}
				writer.WriteEndElement();
			}
	
			// NestedClassReferencesModelClasses
			global::System.Collections.ObjectModel.ReadOnlyCollection<NestedClassReferencesModelClasses> allNestedClassReferencesModelClassesInstances = NestedClassReferencesModelClasses.GetLinksToModelClasses(element);
			if (!serializationContext.Result.Failed && allNestedClassReferencesModelClassesInstances.Count > 0)
			{
				writer.WriteStartElement("modelClasses");
				foreach (NestedClassReferencesModelClasses eachNestedClassReferencesModelClassesInstance in allNestedClassReferencesModelClassesInstances)
				{
					if (serializationContext.Result.Failed)
						break;
	
					DslModeling::DomainClassXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(eachNestedClassReferencesModelClassesInstance.GetDomainClass().Id);
					global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for " + eachNestedClassReferencesModelClassesInstance.GetDomainClass().Name + "!");
					relSerializer.Write(serializationContext, eachNestedClassReferencesModelClassesInstance, writer);
				}
				writer.WriteEndElement();
			}
	
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given NestedClass instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">NestedClass instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the NestedClass instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			NestedClass instance = element as NestedClass;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of NestedClass!");
	
			string key = instance.Name;
			string containerMoniker = null;
			DslModeling::ModelElement container = instance.Model;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				containerMoniker = containerSerializer.CalculateQualifiedName(directory, container);
			}
			if (string.IsNullOrEmpty(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}", key);
			}
			else if (DslModeling::SimpleMonikerResolver.IsFullyQualified(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "{0}/{1}", containerMoniker, key);
			}
			else
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}/{1}", containerMoniker, key);
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">NestedClass instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			NestedClass instance = element as NestedClass;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of NestedClass!");
			DslModeling::ModelElement container = instance.Model;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	}
}

namespace Castle.ActiveWriter
{
	/// <summary>
	/// Serializer ModelHasClassSerializer for DomainClass ModelHasClass.
	/// </summary>
	public partial class ModelHasClassSerializer : DslModeling::DomainRelationshipXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// ModelHasClassSerializer Constructor
		/// </summary>
		public ModelHasClassSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of ModelHasClass.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"modelHasClass"; }
		}
	
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one ModelHasClass instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the ModelHasClass element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ModelHasClass instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
				
			// Read nested XML elements, which include at least the instance of target role-player Class
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					ActiveWriterSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read target role-player Class.
					ReadTargetRolePlayer(serializationContext, element, reader);
	
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							ActiveWriterSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
				else
				{
					ActiveWriterSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "ModelHasClass");
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		/// <summary>
		/// This method reads the target role player Class.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at the open tag of the first child XML element.
		/// This method will read only one target role player instance. The method will skip any child XML element it encounters until it reaches:
		/// 1) The open tag of the target role player.
		/// 2) The end tag of the parent element (dangling relationship).
		/// 3) EOF (dangling relationship).
		/// After the call, the reader is positioned at:
		/// 1) The open tag of the next child element after the target role player.
		/// 2) The end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ModelHasClass instance that will link to the target ModelClass instance.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadTargetRolePlayer(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
	
			// Read the instance of target role-player Class
			DslModeling::ModelElement targetRolePlayer = null;
			DslModeling::DomainClassXmlSerializer targetRoleSerializer = serializationContext.Directory.GetSerializer(ModelClass.DomainClassId);
			global::System.Diagnostics.Debug.Assert(targetRoleSerializer != null, "Cannot find serializer for ModelClass!");
	
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				targetRolePlayer = targetRoleSerializer.TryCreateInstance(serializationContext, reader, element.Partition);
				if (targetRolePlayer != null)
				{
					// Attach the target role-player.
					DslModeling::DomainRoleInfo.SetRolePlayer(element as DslModeling::ElementLink, ModelHasClass.ClassDomainRoleId, targetRolePlayer);
					// Read target role-player.
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (targetRolePlayer.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + targetRolePlayer.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, targetRolePlayer, reader);
					break;
				}
				// Encountered one unknown XML element, skip it and keep reading.
				ActiveWriterSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
				DslModeling::SerializationUtilities.Skip(reader);
			}
			if (targetRolePlayer == null)
			{
				ActiveWriterSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "ModelHasClass");
			}
		}
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ModelHasClass instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// There is no property to read; do nothing
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ModelHasClass instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadElements(serializationContext, element, reader);
	
		}
	
		#region TryCreateInstance & TryCreateDerivedInstance
		/// <summary>
		/// This method creates a correct instance of ModelHasClass based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized ModelHasClass, a new ModelHasClass instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created ModelHasClass instance, or null if the reader is not pointing to a serialized ModelHasClass instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, false /* include the type itself */);
		}
	
		/// <summary>
		/// This method creates a correct derived instance of ModelHasClass based on the tag currently pointed by the reader.
		/// Note that the difference between this method and the above one is that this method will never create an instance of the
		/// ModelHasClass type itself, only derived types are checked.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <returns>Created instance that derives from ModelHasClass, or null if the reader is not pointing to such a serialized instance.</returns>
		public override DslModeling::ElementLink TryCreateDerivedInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, true /* derived types only */) as DslModeling::ElementLink;
		}
	
		/// <summary>
		/// Internal helper method for TryCreateInstance() and TryCreateDerivedInstance().
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <param name="derivedTypesOnly">If true, this method will only check derived types, but not the domain class iitself.</param>
		private DslModeling::ModelElement InternalTryCreateInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition, bool derivedTypesOnly)
		{
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (!derivedTypesOnly && string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ModelHasClass" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "ModelHasClass".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived relationship instance.
						ModelHasClassSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ModelHasClassSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of ModelHasClass based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of ModelHasClass.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new ModelHasClass instance should be created.</param>	
		/// <returns>Created ModelHasClass instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			// Create the link with place-holder role-players.
			return new ModelHasClass(
				partition,
				DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (ModelHasClass.ModelDomainRoleId), 
				DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (ModelHasClass.ClassDomainRoleId)
			);
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from ModelHasClass, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from ModelHasClass.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ModelHasClass.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including ModelHasClass itself) instance of ModelHasClass based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ModelHasClass" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "ModelHasClass".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						ModelHasClassSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ModelHasClassSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of ModelHasClass based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			// Cannot be monikerized.
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from ModelHasClass, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from ModelHasClass.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ModelHasClass.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized ModelHasClass instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ModelHasClass instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the ModelHasClass instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the ModelHasClass instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			// Instance of ModelHasClass cannot be monikerized.
			ActiveWriterSerializationBehaviorSerializationMessages.CannotMonikerizeElement(serializationContext, "ModelHasClass");
		}
		
		/// <summary>
		/// Public Write() method that serializes one ModelHasClass instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ModelHasClass instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ModelHasClass instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// There are no properties; do nothing
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ModelHasClass instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WriteElements(serializationContext, element, writer);
	
		}
		
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given ModelHasClass instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ModelHasClass instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the ModelHasClass instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ModelHasClass instance = element as ModelHasClass;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ModelHasClass!");
	
			DslModeling::ModelElement container = instance.Model;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.CalculateQualifiedName(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ModelHasClass instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ModelHasClass instance = element as ModelHasClass;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ModelHasClass!");
			DslModeling::ModelElement container = instance.Model;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
		
		#region Overrides to provide metadata at runtime
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing Id.
		/// </summary>
		public override bool SerializesId
		{
			get
			{
				return false;
			}
		}
	
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing this relationship in full form.
		/// </summary>
		public override bool UsesFullForm
		{
			get
			{
				return false;
			}
		}
		#endregion
	}
}

namespace Castle.ActiveWriter
{
	/// <summary>
	/// Serializer ManyToOneRelationSerializer for DomainClass ManyToOneRelation.
	/// </summary>
	public partial class ManyToOneRelationSerializer : DslModeling::DomainRelationshipXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// ManyToOneRelationSerializer Constructor
		/// </summary>
		public ManyToOneRelationSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of ManyToOneRelation.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"manyToOneRelation"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of ManyToOneRelation.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"manyToOneRelationMoniker"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of ManyToOneRelation in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"Id"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one ManyToOneRelation instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the ManyToOneRelation element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ManyToOneRelation instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements, which include at least the monikerized instance of target role-player Target
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					ActiveWriterSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read target role-player Target.
					ReadTargetRolePlayer(serializationContext, element, reader);
	
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							ActiveWriterSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
				else
				{
					ActiveWriterSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "ManyToOneRelation");
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		/// <summary>
		/// This method reads the target role player Target.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at the open tag of the first child XML element.
		/// This method will read only one target role player instance. The method will skip any child XML element it encounters until it reaches:
		/// 1) The open tag of the target role player.
		/// 2) The end tag of the parent element (dangling relationship).
		/// 3) EOF (dangling relationship).
		/// After the call, the reader is positioned at:
		/// 1) The open tag of the next child element after the target role player.
		/// 2) The end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ManyToOneRelation instance that will link to the target ModelClass instance.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadTargetRolePlayer(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
	
			// Read the monikerized instance of target role-player Target
			DslModeling::Moniker targetRoleMoniker = null;
			DslModeling::DomainClassXmlSerializer targetRoleSerializer = serializationContext.Directory.GetSerializer(ModelClass.DomainClassId);
			global::System.Diagnostics.Debug.Assert(targetRoleSerializer != null, "Cannot find serializer for ModelClass!");
	
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				targetRoleMoniker = targetRoleSerializer.TryCreateMonikerInstance(serializationContext, reader, ((ManyToOneRelation)element).Source, ManyToOneRelation.DomainClassId, element.Partition);
				if (targetRoleMoniker != null)
				{
					// Attach the target role-player moniker.
					DslModeling::DomainRoleInfo.SetRolePlayerMoniker (element as DslModeling::ElementLink, ManyToOneRelation.TargetDomainRoleId, targetRoleMoniker);
					// Moniker tag has no child XML elements in it, so just skip to the next element.
					DslModeling::SerializationUtilities.Skip(reader);
					break;
				}
				// Encountered one unknown XML element, skip it and keep reading.
				ActiveWriterSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
				DslModeling::SerializationUtilities.Skip(reader);
			}
			if (targetRoleMoniker == null)
			{
				ActiveWriterSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "ManyToOneRelation");
			}
		}
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ManyToOneRelation instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			ManyToOneRelation instanceOfManyToOneRelation = element as ManyToOneRelation;
			global::System.Diagnostics.Debug.Assert(instanceOfManyToOneRelation != null, "Expecting an instance of ManyToOneRelation");
	
			// TargetCache
			if (!serializationContext.Result.Failed)
			{
				string attribTargetCache = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "targetCache");
				if (attribTargetCache != null)
				{
					CacheEnum valueOfTargetCache;
					if (DslModeling::SerializationUtilities.TryGetValue<CacheEnum>(serializationContext, attribTargetCache, out valueOfTargetCache))
					{
						instanceOfManyToOneRelation.TargetCache = valueOfTargetCache;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetCache", typeof(CacheEnum), attribTargetCache);
					}
				}
			}
			// TargetCascade
			if (!serializationContext.Result.Failed)
			{
				string attribTargetCascade = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "targetCascade");
				if (attribTargetCascade != null)
				{
					ManyRelationCascadeEnum valueOfTargetCascade;
					if (DslModeling::SerializationUtilities.TryGetValue<ManyRelationCascadeEnum>(serializationContext, attribTargetCascade, out valueOfTargetCascade))
					{
						instanceOfManyToOneRelation.TargetCascade = valueOfTargetCascade;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetCascade", typeof(ManyRelationCascadeEnum), attribTargetCascade);
					}
				}
			}
			// TargetColumnKey
			if (!serializationContext.Result.Failed)
			{
				string attribTargetColumnKey = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "targetColumnKey");
				if (attribTargetColumnKey != null)
				{
					global::System.String valueOfTargetColumnKey;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribTargetColumnKey, out valueOfTargetColumnKey))
					{
						instanceOfManyToOneRelation.TargetColumnKey = valueOfTargetColumnKey;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetColumnKey", typeof(global::System.String), attribTargetColumnKey);
					}
				}
			}
			// TargetCustomAccess
			if (!serializationContext.Result.Failed)
			{
				string attribTargetCustomAccess = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "targetCustomAccess");
				if (attribTargetCustomAccess != null)
				{
					global::System.String valueOfTargetCustomAccess;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribTargetCustomAccess, out valueOfTargetCustomAccess))
					{
						instanceOfManyToOneRelation.TargetCustomAccess = valueOfTargetCustomAccess;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetCustomAccess", typeof(global::System.String), attribTargetCustomAccess);
					}
				}
			}
			// TargetInverse
			if (!serializationContext.Result.Failed)
			{
				string attribTargetInverse = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "targetInverse");
				if (attribTargetInverse != null)
				{
					global::System.Boolean valueOfTargetInverse;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribTargetInverse, out valueOfTargetInverse))
					{
						instanceOfManyToOneRelation.TargetInverse = valueOfTargetInverse;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetInverse", typeof(global::System.Boolean), attribTargetInverse);
					}
				}
			}
			// TargetLazy
			if (!serializationContext.Result.Failed)
			{
				string attribTargetLazy = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "targetLazy");
				if (attribTargetLazy != null)
				{
					global::System.Boolean valueOfTargetLazy;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribTargetLazy, out valueOfTargetLazy))
					{
						instanceOfManyToOneRelation.TargetLazy = valueOfTargetLazy;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetLazy", typeof(global::System.Boolean), attribTargetLazy);
					}
				}
			}
			// TargetMapType
			if (!serializationContext.Result.Failed)
			{
				string attribTargetMapType = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "targetMapType");
				if (attribTargetMapType != null)
				{
					global::System.String valueOfTargetMapType;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribTargetMapType, out valueOfTargetMapType))
					{
						instanceOfManyToOneRelation.TargetMapType = valueOfTargetMapType;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetMapType", typeof(global::System.String), attribTargetMapType);
					}
				}
			}
			// TargetOrderBy
			if (!serializationContext.Result.Failed)
			{
				string attribTargetOrderBy = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "targetOrderBy");
				if (attribTargetOrderBy != null)
				{
					global::System.String valueOfTargetOrderBy;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribTargetOrderBy, out valueOfTargetOrderBy))
					{
						instanceOfManyToOneRelation.TargetOrderBy = valueOfTargetOrderBy;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetOrderBy", typeof(global::System.String), attribTargetOrderBy);
					}
				}
			}
			// TargetRelationType
			if (!serializationContext.Result.Failed)
			{
				string attribTargetRelationType = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "targetRelationType");
				if (attribTargetRelationType != null)
				{
					InheritedRelationType valueOfTargetRelationType;
					if (DslModeling::SerializationUtilities.TryGetValue<InheritedRelationType>(serializationContext, attribTargetRelationType, out valueOfTargetRelationType))
					{
						instanceOfManyToOneRelation.TargetRelationType = valueOfTargetRelationType;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetRelationType", typeof(InheritedRelationType), attribTargetRelationType);
					}
				}
			}
			// TargetSchema
			if (!serializationContext.Result.Failed)
			{
				string attribTargetSchema = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "targetSchema");
				if (attribTargetSchema != null)
				{
					global::System.String valueOfTargetSchema;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribTargetSchema, out valueOfTargetSchema))
					{
						instanceOfManyToOneRelation.TargetSchema = valueOfTargetSchema;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetSchema", typeof(global::System.String), attribTargetSchema);
					}
				}
			}
			// TargetSort
			if (!serializationContext.Result.Failed)
			{
				string attribTargetSort = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "targetSort");
				if (attribTargetSort != null)
				{
					global::System.String valueOfTargetSort;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribTargetSort, out valueOfTargetSort))
					{
						instanceOfManyToOneRelation.TargetSort = valueOfTargetSort;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetSort", typeof(global::System.String), attribTargetSort);
					}
				}
			}
			// TargetTable
			if (!serializationContext.Result.Failed)
			{
				string attribTargetTable = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "targetTable");
				if (attribTargetTable != null)
				{
					global::System.String valueOfTargetTable;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribTargetTable, out valueOfTargetTable))
					{
						instanceOfManyToOneRelation.TargetTable = valueOfTargetTable;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetTable", typeof(global::System.String), attribTargetTable);
					}
				}
			}
			// TargetWhere
			if (!serializationContext.Result.Failed)
			{
				string attribTargetWhere = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "targetWhere");
				if (attribTargetWhere != null)
				{
					global::System.String valueOfTargetWhere;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribTargetWhere, out valueOfTargetWhere))
					{
						instanceOfManyToOneRelation.TargetWhere = valueOfTargetWhere;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetWhere", typeof(global::System.String), attribTargetWhere);
					}
				}
			}
			// TargetDescription
			if (!serializationContext.Result.Failed)
			{
				string attribTargetDescription = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "targetDescription");
				if (attribTargetDescription != null)
				{
					global::System.String valueOfTargetDescription;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribTargetDescription, out valueOfTargetDescription))
					{
						instanceOfManyToOneRelation.TargetDescription = valueOfTargetDescription;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetDescription", typeof(global::System.String), attribTargetDescription);
					}
				}
			}
			// TargetPropertyName
			if (!serializationContext.Result.Failed)
			{
				string attribTargetPropertyName = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "targetPropertyName");
				if (attribTargetPropertyName != null)
				{
					global::System.String valueOfTargetPropertyName;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribTargetPropertyName, out valueOfTargetPropertyName))
					{
						instanceOfManyToOneRelation.TargetPropertyName = valueOfTargetPropertyName;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetPropertyName", typeof(global::System.String), attribTargetPropertyName);
					}
				}
			}
			// TargetPropertyType
			if (!serializationContext.Result.Failed)
			{
				string attribTargetPropertyType = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "targetPropertyType");
				if (attribTargetPropertyType != null)
				{
					global::System.String valueOfTargetPropertyType;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribTargetPropertyType, out valueOfTargetPropertyType))
					{
						instanceOfManyToOneRelation.TargetPropertyType = valueOfTargetPropertyType;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetPropertyType", typeof(global::System.String), attribTargetPropertyType);
					}
				}
			}
			// SourceCascade
			if (!serializationContext.Result.Failed)
			{
				string attribSourceCascade = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "sourceCascade");
				if (attribSourceCascade != null)
				{
					CascadeEnum valueOfSourceCascade;
					if (DslModeling::SerializationUtilities.TryGetValue<CascadeEnum>(serializationContext, attribSourceCascade, out valueOfSourceCascade))
					{
						instanceOfManyToOneRelation.SourceCascade = valueOfSourceCascade;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceCascade", typeof(CascadeEnum), attribSourceCascade);
					}
				}
			}
			// SourceColumn
			if (!serializationContext.Result.Failed)
			{
				string attribSourceColumn = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "sourceColumn");
				if (attribSourceColumn != null)
				{
					global::System.String valueOfSourceColumn;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribSourceColumn, out valueOfSourceColumn))
					{
						instanceOfManyToOneRelation.SourceColumn = valueOfSourceColumn;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceColumn", typeof(global::System.String), attribSourceColumn);
					}
				}
			}
			// SourceCustomAccess
			if (!serializationContext.Result.Failed)
			{
				string attribSourceCustomAccess = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "sourceCustomAccess");
				if (attribSourceCustomAccess != null)
				{
					global::System.String valueOfSourceCustomAccess;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribSourceCustomAccess, out valueOfSourceCustomAccess))
					{
						instanceOfManyToOneRelation.SourceCustomAccess = valueOfSourceCustomAccess;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceCustomAccess", typeof(global::System.String), attribSourceCustomAccess);
					}
				}
			}
			// SourceInsert
			if (!serializationContext.Result.Failed)
			{
				string attribSourceInsert = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "sourceInsert");
				if (attribSourceInsert != null)
				{
					global::System.Boolean valueOfSourceInsert;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribSourceInsert, out valueOfSourceInsert))
					{
						instanceOfManyToOneRelation.SourceInsert = valueOfSourceInsert;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceInsert", typeof(global::System.Boolean), attribSourceInsert);
					}
				}
			}
			// SourceNotNull
			if (!serializationContext.Result.Failed)
			{
				string attribSourceNotNull = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "sourceNotNull");
				if (attribSourceNotNull != null)
				{
					global::System.Boolean valueOfSourceNotNull;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribSourceNotNull, out valueOfSourceNotNull))
					{
						instanceOfManyToOneRelation.SourceNotNull = valueOfSourceNotNull;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceNotNull", typeof(global::System.Boolean), attribSourceNotNull);
					}
				}
			}
			// SourceOuterJoin
			if (!serializationContext.Result.Failed)
			{
				string attribSourceOuterJoin = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "sourceOuterJoin");
				if (attribSourceOuterJoin != null)
				{
					OuterJoinEnum valueOfSourceOuterJoin;
					if (DslModeling::SerializationUtilities.TryGetValue<OuterJoinEnum>(serializationContext, attribSourceOuterJoin, out valueOfSourceOuterJoin))
					{
						instanceOfManyToOneRelation.SourceOuterJoin = valueOfSourceOuterJoin;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceOuterJoin", typeof(OuterJoinEnum), attribSourceOuterJoin);
					}
				}
			}
			// SourceType
			if (!serializationContext.Result.Failed)
			{
				string attribSourceType = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "sourceType");
				if (attribSourceType != null)
				{
					global::System.String valueOfSourceType;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribSourceType, out valueOfSourceType))
					{
						instanceOfManyToOneRelation.SourceType = valueOfSourceType;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceType", typeof(global::System.String), attribSourceType);
					}
				}
			}
			// SourceUnique
			if (!serializationContext.Result.Failed)
			{
				string attribSourceUnique = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "sourceUnique");
				if (attribSourceUnique != null)
				{
					global::System.Boolean valueOfSourceUnique;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribSourceUnique, out valueOfSourceUnique))
					{
						instanceOfManyToOneRelation.SourceUnique = valueOfSourceUnique;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceUnique", typeof(global::System.Boolean), attribSourceUnique);
					}
				}
			}
			// SourceUpdate
			if (!serializationContext.Result.Failed)
			{
				string attribSourceUpdate = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "sourceUpdate");
				if (attribSourceUpdate != null)
				{
					global::System.Boolean valueOfSourceUpdate;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribSourceUpdate, out valueOfSourceUpdate))
					{
						instanceOfManyToOneRelation.SourceUpdate = valueOfSourceUpdate;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceUpdate", typeof(global::System.Boolean), attribSourceUpdate);
					}
				}
			}
			// SourceDescription
			if (!serializationContext.Result.Failed)
			{
				string attribSourceDescription = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "sourceDescription");
				if (attribSourceDescription != null)
				{
					global::System.String valueOfSourceDescription;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribSourceDescription, out valueOfSourceDescription))
					{
						instanceOfManyToOneRelation.SourceDescription = valueOfSourceDescription;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceDescription", typeof(global::System.String), attribSourceDescription);
					}
				}
			}
			// TargetAccess
			if (!serializationContext.Result.Failed)
			{
				string attribTargetAccess = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "targetAccess");
				if (attribTargetAccess != null)
				{
					InheritablePropertyAccess valueOfTargetAccess;
					if (DslModeling::SerializationUtilities.TryGetValue<InheritablePropertyAccess>(serializationContext, attribTargetAccess, out valueOfTargetAccess))
					{
						instanceOfManyToOneRelation.TargetAccess = valueOfTargetAccess;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetAccess", typeof(InheritablePropertyAccess), attribTargetAccess);
					}
				}
			}
			// SourcePropertyName
			if (!serializationContext.Result.Failed)
			{
				string attribSourcePropertyName = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "sourcePropertyName");
				if (attribSourcePropertyName != null)
				{
					global::System.String valueOfSourcePropertyName;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribSourcePropertyName, out valueOfSourcePropertyName))
					{
						instanceOfManyToOneRelation.SourcePropertyName = valueOfSourcePropertyName;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourcePropertyName", typeof(global::System.String), attribSourcePropertyName);
					}
				}
			}
			// SourceNotFoundBehaviour
			if (!serializationContext.Result.Failed)
			{
				string attribSourceNotFoundBehaviour = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "sourceNotFoundBehaviour");
				if (attribSourceNotFoundBehaviour != null)
				{
					NotFoundBehaviour valueOfSourceNotFoundBehaviour;
					if (DslModeling::SerializationUtilities.TryGetValue<NotFoundBehaviour>(serializationContext, attribSourceNotFoundBehaviour, out valueOfSourceNotFoundBehaviour))
					{
						instanceOfManyToOneRelation.SourceNotFoundBehaviour = valueOfSourceNotFoundBehaviour;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceNotFoundBehaviour", typeof(NotFoundBehaviour), attribSourceNotFoundBehaviour);
					}
				}
			}
			// TargetNotFoundBehaviour
			if (!serializationContext.Result.Failed)
			{
				string attribTargetNotFoundBehaviour = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "targetNotFoundBehaviour");
				if (attribTargetNotFoundBehaviour != null)
				{
					NotFoundBehaviour valueOfTargetNotFoundBehaviour;
					if (DslModeling::SerializationUtilities.TryGetValue<NotFoundBehaviour>(serializationContext, attribTargetNotFoundBehaviour, out valueOfTargetNotFoundBehaviour))
					{
						instanceOfManyToOneRelation.TargetNotFoundBehaviour = valueOfTargetNotFoundBehaviour;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetNotFoundBehaviour", typeof(NotFoundBehaviour), attribTargetNotFoundBehaviour);
					}
				}
			}
			// TargetElement
			if (!serializationContext.Result.Failed)
			{
				string attribTargetElement = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "targetElement");
				if (attribTargetElement != null)
				{
					global::System.String valueOfTargetElement;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribTargetElement, out valueOfTargetElement))
					{
						instanceOfManyToOneRelation.TargetElement = valueOfTargetElement;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetElement", typeof(global::System.String), attribTargetElement);
					}
				}
			}
			// TargetIndexType
			if (!serializationContext.Result.Failed)
			{
				string attribTargetIndexType = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "targetIndexType");
				if (attribTargetIndexType != null)
				{
					global::System.String valueOfTargetIndexType;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribTargetIndexType, out valueOfTargetIndexType))
					{
						instanceOfManyToOneRelation.TargetIndexType = valueOfTargetIndexType;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetIndexType", typeof(global::System.String), attribTargetIndexType);
					}
				}
			}
			// TargetIndex
			if (!serializationContext.Result.Failed)
			{
				string attribTargetIndex = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "targetIndex");
				if (attribTargetIndex != null)
				{
					global::System.String valueOfTargetIndex;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribTargetIndex, out valueOfTargetIndex))
					{
						instanceOfManyToOneRelation.TargetIndex = valueOfTargetIndex;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetIndex", typeof(global::System.String), attribTargetIndex);
					}
				}
			}
			// TargetFetch
			if (!serializationContext.Result.Failed)
			{
				string attribTargetFetch = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "targetFetch");
				if (attribTargetFetch != null)
				{
					FetchEnum valueOfTargetFetch;
					if (DslModeling::SerializationUtilities.TryGetValue<FetchEnum>(serializationContext, attribTargetFetch, out valueOfTargetFetch))
					{
						instanceOfManyToOneRelation.TargetFetch = valueOfTargetFetch;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetFetch", typeof(FetchEnum), attribTargetFetch);
					}
				}
			}
			// TargetIUserCollectionType
			if (!serializationContext.Result.Failed)
			{
				string attribTargetIUserCollectionType = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "targetIUserCollectionType");
				if (attribTargetIUserCollectionType != null)
				{
					global::System.String valueOfTargetIUserCollectionType;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribTargetIUserCollectionType, out valueOfTargetIUserCollectionType))
					{
						instanceOfManyToOneRelation.TargetIUserCollectionType = valueOfTargetIUserCollectionType;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetIUserCollectionType", typeof(global::System.String), attribTargetIUserCollectionType);
					}
				}
			}
			// TargetPropertyGenerated
			if (!serializationContext.Result.Failed)
			{
				string attribTargetPropertyGenerated = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "targetPropertyGenerated");
				if (attribTargetPropertyGenerated != null)
				{
					global::System.Boolean valueOfTargetPropertyGenerated;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribTargetPropertyGenerated, out valueOfTargetPropertyGenerated))
					{
						instanceOfManyToOneRelation.TargetPropertyGenerated = valueOfTargetPropertyGenerated;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetPropertyGenerated", typeof(global::System.Boolean), attribTargetPropertyGenerated);
					}
				}
			}
			// SourcePropertyGenerated
			if (!serializationContext.Result.Failed)
			{
				string attribSourcePropertyGenerated = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "sourcePropertyGenerated");
				if (attribSourcePropertyGenerated != null)
				{
					global::System.Boolean valueOfSourcePropertyGenerated;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribSourcePropertyGenerated, out valueOfSourcePropertyGenerated))
					{
						instanceOfManyToOneRelation.SourcePropertyGenerated = valueOfSourcePropertyGenerated;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourcePropertyGenerated", typeof(global::System.Boolean), attribSourcePropertyGenerated);
					}
				}
			}
			// SourceAccess
			if (!serializationContext.Result.Failed)
			{
				string attribSourceAccess = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "sourceAccess");
				if (attribSourceAccess != null)
				{
					InheritablePropertyAccess valueOfSourceAccess;
					if (DslModeling::SerializationUtilities.TryGetValue<InheritablePropertyAccess>(serializationContext, attribSourceAccess, out valueOfSourceAccess))
					{
						instanceOfManyToOneRelation.SourceAccess = valueOfSourceAccess;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceAccess", typeof(InheritablePropertyAccess), attribSourceAccess);
					}
				}
			}
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ManyToOneRelation instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadElements(serializationContext, element, reader);
	
		}
	
		#region TryCreateInstance & TryCreateDerivedInstance
		/// <summary>
		/// This method creates a correct instance of ManyToOneRelation based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized ManyToOneRelation, a new ManyToOneRelation instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created ManyToOneRelation instance, or null if the reader is not pointing to a serialized ManyToOneRelation instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, false /* include the type itself */);
		}
	
		/// <summary>
		/// This method creates a correct derived instance of ManyToOneRelation based on the tag currently pointed by the reader.
		/// Note that the difference between this method and the above one is that this method will never create an instance of the
		/// ManyToOneRelation type itself, only derived types are checked.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <returns>Created instance that derives from ManyToOneRelation, or null if the reader is not pointing to such a serialized instance.</returns>
		public override DslModeling::ElementLink TryCreateDerivedInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, true /* derived types only */) as DslModeling::ElementLink;
		}
	
		/// <summary>
		/// Internal helper method for TryCreateInstance() and TryCreateDerivedInstance().
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <param name="derivedTypesOnly">If true, this method will only check derived types, but not the domain class iitself.</param>
		private DslModeling::ModelElement InternalTryCreateInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition, bool derivedTypesOnly)
		{
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (!derivedTypesOnly && string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ManyToOneRelation" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "ManyToOneRelation".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived relationship instance.
						ManyToOneRelationSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ManyToOneRelationSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of ManyToOneRelation based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of ManyToOneRelation.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new ManyToOneRelation instance should be created.</param>	
		/// <returns>Created ManyToOneRelation instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (string.IsNullOrEmpty(idStr))
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					ActiveWriterSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				// Create the link with place-holder role-players.
				return new ManyToOneRelation(
					partition,
					new DslModeling::RoleAssignment[] {
						DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (ManyToOneRelation.SourceDomainRoleId), 
						DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (ManyToOneRelation.TargetDomainRoleId)
					},
					new DslModeling::PropertyAssignment[] {
						new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id)
					}
				);
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				ActiveWriterSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				ActiveWriterSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				ActiveWriterSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from ManyToOneRelation, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from ManyToOneRelation.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ManyToOneRelation.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including ManyToOneRelation itself) instance of ManyToOneRelation based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ManyToOneRelation" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "ManyToOneRelation".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						ManyToOneRelationSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ManyToOneRelationSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of ManyToOneRelation based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				ActiveWriterSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			try
			{	// Normalize the Id.
				global::System.Guid id = new global::System.Guid(monikerString);
				monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
				DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, ManyToOneRelation.DomainClassId, partition.Store), partition.Store);
				// Set location info if possible.
				result.Location = serializationContext.Location;
				global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
				if (xmlLineInfo != null)
				{
					result.Line = xmlLineInfo.LineNumber;
					result.Column = xmlLineInfo.LinePosition;
				}
				return result;
			}
			catch (global::System.FormatException /* fEx */)
			{
				ActiveWriterSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
			catch (global::System.OverflowException /* oEx */)
			{	
				ActiveWriterSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from ManyToOneRelation, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from ManyToOneRelation.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ManyToOneRelation.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized ManyToOneRelation instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ManyToOneRelation instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the ManyToOneRelation instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the ManyToOneRelation instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one ManyToOneRelation instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ManyToOneRelation instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				ActiveWriterSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			// Write the target role-player instance.
			ManyToOneRelation instance = element as ManyToOneRelation;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ManyToOneRelation!");
	
			DslModeling::ModelElement targetElement = instance.Target;
			DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
			global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");
			targetSerializer.WriteMoniker(serializationContext, targetElement, writer, instance.Source, this);
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ManyToOneRelation instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			ManyToOneRelation instanceOfManyToOneRelation = element as ManyToOneRelation;
			global::System.Diagnostics.Debug.Assert(instanceOfManyToOneRelation != null, "Expecting an instance of ManyToOneRelation");
	
			// TargetCache
			if (!serializationContext.Result.Failed)
			{
				CacheEnum propValue = instanceOfManyToOneRelation.TargetCache;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<CacheEnum>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Undefined") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "targetCache", serializedPropValue);
					}
				}
			}
			// TargetCascade
			if (!serializationContext.Result.Failed)
			{
				ManyRelationCascadeEnum propValue = instanceOfManyToOneRelation.TargetCascade;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<ManyRelationCascadeEnum>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "None") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "targetCascade", serializedPropValue);
					}
				}
			}
			// TargetColumnKey
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToOneRelation.TargetColumnKey;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "targetColumnKey", propValue);
	
				}
			}
			// TargetCustomAccess
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToOneRelation.TargetCustomAccess;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "targetCustomAccess", propValue);
	
				}
			}
			// TargetInverse
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfManyToOneRelation.TargetInverse;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "false") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "targetInverse", serializedPropValue);
					}
				}
			}
			// TargetLazy
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfManyToOneRelation.TargetLazy;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "false") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "targetLazy", serializedPropValue);
					}
				}
			}
			// TargetMapType
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToOneRelation.TargetMapType;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "targetMapType", propValue);
	
				}
			}
			// TargetOrderBy
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToOneRelation.TargetOrderBy;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "targetOrderBy", propValue);
	
				}
			}
			// TargetRelationType
			if (!serializationContext.Result.Failed)
			{
				InheritedRelationType propValue = instanceOfManyToOneRelation.TargetRelationType;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<InheritedRelationType>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Inherited") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "targetRelationType", serializedPropValue);
					}
				}
			}
			// TargetSchema
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToOneRelation.TargetSchema;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "targetSchema", propValue);
	
				}
			}
			// TargetSort
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToOneRelation.TargetSort;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "targetSort", propValue);
	
				}
			}
			// TargetTable
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToOneRelation.TargetTable;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "targetTable", propValue);
	
				}
			}
			// TargetWhere
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToOneRelation.TargetWhere;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "targetWhere", propValue);
	
				}
			}
			// TargetDescription
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToOneRelation.TargetDescription;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "targetDescription", propValue);
	
				}
			}
			// TargetPropertyName
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToOneRelation.TargetPropertyName;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "targetPropertyName", propValue);
	
				}
			}
			// TargetPropertyType
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToOneRelation.TargetPropertyType;
				if (!serializationContext.Result.Failed)
				{
					if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, string.Empty) != 0))
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "targetPropertyType", propValue);
					}
				}
			}
			// SourceCascade
			if (!serializationContext.Result.Failed)
			{
				CascadeEnum propValue = instanceOfManyToOneRelation.SourceCascade;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<CascadeEnum>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "None") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "sourceCascade", serializedPropValue);
					}
				}
			}
			// SourceColumn
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToOneRelation.SourceColumn;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "sourceColumn", propValue);
	
				}
			}
			// SourceCustomAccess
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToOneRelation.SourceCustomAccess;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "sourceCustomAccess", propValue);
	
				}
			}
			// SourceInsert
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfManyToOneRelation.SourceInsert;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "true") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "sourceInsert", serializedPropValue);
					}
				}
			}
			// SourceNotNull
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfManyToOneRelation.SourceNotNull;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "false") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "sourceNotNull", serializedPropValue);
					}
				}
			}
			// SourceOuterJoin
			if (!serializationContext.Result.Failed)
			{
				OuterJoinEnum propValue = instanceOfManyToOneRelation.SourceOuterJoin;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<OuterJoinEnum>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Auto") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "sourceOuterJoin", serializedPropValue);
					}
				}
			}
			// SourceType
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToOneRelation.SourceType;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "sourceType", propValue);
	
				}
			}
			// SourceUnique
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfManyToOneRelation.SourceUnique;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "false") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "sourceUnique", serializedPropValue);
					}
				}
			}
			// SourceUpdate
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfManyToOneRelation.SourceUpdate;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "true") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "sourceUpdate", serializedPropValue);
					}
				}
			}
			// SourceDescription
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToOneRelation.SourceDescription;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "sourceDescription", propValue);
	
				}
			}
			// TargetAccess
			if (!serializationContext.Result.Failed)
			{
				InheritablePropertyAccess propValue = instanceOfManyToOneRelation.TargetAccess;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<InheritablePropertyAccess>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Inherit") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "targetAccess", serializedPropValue);
					}
				}
			}
			// SourcePropertyName
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToOneRelation.SourcePropertyName;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "sourcePropertyName", propValue);
	
				}
			}
			// SourceNotFoundBehaviour
			if (!serializationContext.Result.Failed)
			{
				NotFoundBehaviour propValue = instanceOfManyToOneRelation.SourceNotFoundBehaviour;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<NotFoundBehaviour>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Default") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "sourceNotFoundBehaviour", serializedPropValue);
					}
				}
			}
			// TargetNotFoundBehaviour
			if (!serializationContext.Result.Failed)
			{
				NotFoundBehaviour propValue = instanceOfManyToOneRelation.TargetNotFoundBehaviour;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<NotFoundBehaviour>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Default") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "targetNotFoundBehaviour", serializedPropValue);
					}
				}
			}
			// TargetElement
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToOneRelation.TargetElement;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "targetElement", propValue);
	
				}
			}
			// TargetIndexType
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToOneRelation.TargetIndexType;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "targetIndexType", propValue);
	
				}
			}
			// TargetIndex
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToOneRelation.TargetIndex;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "targetIndex", propValue);
	
				}
			}
			// TargetFetch
			if (!serializationContext.Result.Failed)
			{
				FetchEnum propValue = instanceOfManyToOneRelation.TargetFetch;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<FetchEnum>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Unspecified") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "targetFetch", serializedPropValue);
					}
				}
			}
			// TargetIUserCollectionType
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToOneRelation.TargetIUserCollectionType;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "targetIUserCollectionType", propValue);
	
				}
			}
			// TargetPropertyGenerated
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfManyToOneRelation.TargetPropertyGenerated;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "true") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "targetPropertyGenerated", serializedPropValue);
					}
				}
			}
			// SourcePropertyGenerated
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfManyToOneRelation.SourcePropertyGenerated;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "true") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "sourcePropertyGenerated", serializedPropValue);
					}
				}
			}
			// SourceAccess
			if (!serializationContext.Result.Failed)
			{
				InheritablePropertyAccess propValue = instanceOfManyToOneRelation.SourceAccess;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<InheritablePropertyAccess>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Inherit") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "sourceAccess", serializedPropValue);
					}
				}
			}
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ManyToOneRelation instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WriteElements(serializationContext, element, writer);
	
		}
		
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given ManyToOneRelation instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ManyToOneRelation instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the ManyToOneRelation instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ManyToOneRelation instance = element as ManyToOneRelation;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ManyToOneRelation!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ManyToOneRelation instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	
		#region Monikerization Support
		/// <summary>
		/// Calculates a Moniker, given a reference to a ModelClass
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="sourceElement">Instance of ModelClass that contains the given serialized reference</param>
		/// <param name="domainClassId">DomainClassId of the model element that the given moniker string will be resolved to.</param>
		/// <param name="monikerString">Serialized string reference to an instance of ModelClass</param>
		/// <param name="store">Store where the Moniker will be created</param>
		/// <returns>A Moniker encapsulating the serialized string reference of ModelClass instance</returns>
		public override DslModeling::Moniker MonikerizeReference(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement sourceElement, global::System.Guid domainClassId, string monikerString, DslModeling::Store store)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(sourceElement != null);
			if (sourceElement == null)
				throw new global::System.ArgumentNullException ("sourceElement");
			global::System.Diagnostics.Debug.Assert (sourceElement is ModelClass, "Expecting an instance of ModelClass!");
			global::System.Diagnostics.Debug.Assert (!string.IsNullOrEmpty (monikerString));
			if (string.IsNullOrEmpty (monikerString))
				throw new global::System.ArgumentNullException ("monikerString");
			global::System.Diagnostics.Debug.Assert(store != null);
			if (store == null)
				throw new global::System.ArgumentNullException ("store");
			#endregion
			
			DslModeling::MonikerKey key = null;
			if (DslModeling::SimpleMonikerResolver.IsFullyQualified(monikerString))
			{
				key = new DslModeling::MonikerKey(monikerString, ManyToOneRelation.DomainClassId, domainClassId, store);
			}
			else
			{
				DslModeling::DomainClassXmlSerializer sourceSerializer = serializationContext.Directory.GetSerializer(sourceElement.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(sourceSerializer != null, "Cannot find serializer for " + sourceElement.GetDomainClass().Name + "!");
				string sourceQualifier = sourceSerializer.GetMonikerQualifier(serializationContext.Directory, sourceElement);
				key = new DslModeling::MonikerKey(string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "{0}/{1}", sourceQualifier, monikerString), ManyToOneRelation.DomainClassId, domainClassId, store);
			}
			return new DslModeling::Moniker(key, store);
		}
	
		/// <summary>
		/// Calculates a monikerized string reference to a ModelClass.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="sourceElement">Source side of reference relationship. The referenced target element will be serialized.</param>
		/// <param name="targetElement">Target side of relationship that will be serialized.</param>
		/// <returns>A monikerized string reference to target element.</returns>		
		public override string SerializeReference(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement sourceElement, DslModeling::ModelElement targetElement)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(sourceElement != null);
			if (sourceElement == null)
				throw new global::System.ArgumentNullException ("sourceElement");
			global::System.Diagnostics.Debug.Assert (sourceElement is ModelClass, "Expecting an instance of ModelClass!");
			global::System.Diagnostics.Debug.Assert(targetElement != null);
			if (targetElement == null)
				throw new global::System.ArgumentNullException ("targetElement");
			global::System.Diagnostics.Debug.Assert (targetElement is ModelClass, "Expecting an instance of ModelClass!");
			#endregion
			
			// full form reference
			DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
			global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");
			string targetMoniker = targetSerializer.CalculateQualifiedName(serializationContext.Directory, targetElement);
			string targetQualifier = targetSerializer.GetMonikerQualifier(serializationContext.Directory, targetElement);
			
			if (!string.IsNullOrEmpty(targetQualifier))
			{
				DslModeling::DomainClassXmlSerializer sourceSerializer = serializationContext.Directory.GetSerializer(sourceElement.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(sourceSerializer != null, "Cannot find serializer for " + sourceElement.GetDomainClass().Name + "!");
				string sourceQualifier = sourceSerializer.GetMonikerQualifier(serializationContext.Directory, sourceElement);
				if (string.Compare(targetQualifier, sourceQualifier, global::System.StringComparison.CurrentCulture) == 0)
				{
					// See if we can create a short form reference by omitting the qualifier
					global::System.Diagnostics.Debug.Assert(targetMoniker.StartsWith(targetQualifier + "/", global::System.StringComparison.CurrentCulture));
					string shortFormTargetMoniker = targetMoniker.Substring(targetQualifier.Length + 1);
					if (!DslModeling::SimpleMonikerResolver.IsFullyQualified(shortFormTargetMoniker))
						targetMoniker = shortFormTargetMoniker;
				}
			}
	
			return targetMoniker;
		}
		#endregion
		
		#region Overrides to provide metadata at runtime
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing Id.
		/// </summary>
		public override bool SerializesId
		{
			get
			{
				return true;
			}
		}
	
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing this relationship in full form.
		/// </summary>
		public override bool UsesFullForm
		{
			get
			{
				return true;
			}
		}
		#endregion
	}
}

namespace Castle.ActiveWriter
{
	/// <summary>
	/// Serializer ClassHasPropertySerializer for DomainClass ClassHasProperty.
	/// </summary>
	public partial class ClassHasPropertySerializer : DslModeling::DomainRelationshipXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// ClassHasPropertySerializer Constructor
		/// </summary>
		public ClassHasPropertySerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of ClassHasProperty.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"classHasProperty"; }
		}
	
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one ClassHasProperty instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the ClassHasProperty element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ClassHasProperty instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
				
			// Read nested XML elements, which include at least the instance of target role-player Property
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					ActiveWriterSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read target role-player Property.
					ReadTargetRolePlayer(serializationContext, element, reader);
	
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							ActiveWriterSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
				else
				{
					ActiveWriterSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "ClassHasProperty");
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		/// <summary>
		/// This method reads the target role player Property.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at the open tag of the first child XML element.
		/// This method will read only one target role player instance. The method will skip any child XML element it encounters until it reaches:
		/// 1) The open tag of the target role player.
		/// 2) The end tag of the parent element (dangling relationship).
		/// 3) EOF (dangling relationship).
		/// After the call, the reader is positioned at:
		/// 1) The open tag of the next child element after the target role player.
		/// 2) The end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ClassHasProperty instance that will link to the target ModelProperty instance.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadTargetRolePlayer(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
	
			// Read the instance of target role-player Property
			DslModeling::ModelElement targetRolePlayer = null;
			DslModeling::DomainClassXmlSerializer targetRoleSerializer = serializationContext.Directory.GetSerializer(ModelProperty.DomainClassId);
			global::System.Diagnostics.Debug.Assert(targetRoleSerializer != null, "Cannot find serializer for ModelProperty!");
	
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				targetRolePlayer = targetRoleSerializer.TryCreateInstance(serializationContext, reader, element.Partition);
				if (targetRolePlayer != null)
				{
					// Attach the target role-player.
					DslModeling::DomainRoleInfo.SetRolePlayer(element as DslModeling::ElementLink, ClassHasProperty.PropertyDomainRoleId, targetRolePlayer);
					// Read target role-player.
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (targetRolePlayer.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + targetRolePlayer.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, targetRolePlayer, reader);
					break;
				}
				// Encountered one unknown XML element, skip it and keep reading.
				ActiveWriterSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
				DslModeling::SerializationUtilities.Skip(reader);
			}
			if (targetRolePlayer == null)
			{
				ActiveWriterSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "ClassHasProperty");
			}
		}
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ClassHasProperty instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// There is no property to read; do nothing
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ClassHasProperty instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadElements(serializationContext, element, reader);
	
		}
	
		#region TryCreateInstance & TryCreateDerivedInstance
		/// <summary>
		/// This method creates a correct instance of ClassHasProperty based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized ClassHasProperty, a new ClassHasProperty instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created ClassHasProperty instance, or null if the reader is not pointing to a serialized ClassHasProperty instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, false /* include the type itself */);
		}
	
		/// <summary>
		/// This method creates a correct derived instance of ClassHasProperty based on the tag currently pointed by the reader.
		/// Note that the difference between this method and the above one is that this method will never create an instance of the
		/// ClassHasProperty type itself, only derived types are checked.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <returns>Created instance that derives from ClassHasProperty, or null if the reader is not pointing to such a serialized instance.</returns>
		public override DslModeling::ElementLink TryCreateDerivedInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, true /* derived types only */) as DslModeling::ElementLink;
		}
	
		/// <summary>
		/// Internal helper method for TryCreateInstance() and TryCreateDerivedInstance().
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <param name="derivedTypesOnly">If true, this method will only check derived types, but not the domain class iitself.</param>
		private DslModeling::ModelElement InternalTryCreateInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition, bool derivedTypesOnly)
		{
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (!derivedTypesOnly && string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ClassHasProperty" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "ClassHasProperty".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived relationship instance.
						ClassHasPropertySerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ClassHasPropertySerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of ClassHasProperty based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of ClassHasProperty.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new ClassHasProperty instance should be created.</param>	
		/// <returns>Created ClassHasProperty instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			// Create the link with place-holder role-players.
			return new ClassHasProperty(
				partition,
				DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (ClassHasProperty.ModelClassDomainRoleId), 
				DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (ClassHasProperty.PropertyDomainRoleId)
			);
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from ClassHasProperty, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from ClassHasProperty.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ClassHasProperty.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including ClassHasProperty itself) instance of ClassHasProperty based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ClassHasProperty" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "ClassHasProperty".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						ClassHasPropertySerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ClassHasPropertySerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of ClassHasProperty based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			// Cannot be monikerized.
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from ClassHasProperty, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from ClassHasProperty.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ClassHasProperty.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized ClassHasProperty instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ClassHasProperty instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the ClassHasProperty instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the ClassHasProperty instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			// Instance of ClassHasProperty cannot be monikerized.
			ActiveWriterSerializationBehaviorSerializationMessages.CannotMonikerizeElement(serializationContext, "ClassHasProperty");
		}
		
		/// <summary>
		/// Public Write() method that serializes one ClassHasProperty instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ClassHasProperty instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ClassHasProperty instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// There are no properties; do nothing
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ClassHasProperty instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WriteElements(serializationContext, element, writer);
	
		}
		
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given ClassHasProperty instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ClassHasProperty instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the ClassHasProperty instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ClassHasProperty instance = element as ClassHasProperty;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ClassHasProperty!");
	
			DslModeling::ModelElement container = instance.ModelClass;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.CalculateQualifiedName(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ClassHasProperty instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ClassHasProperty instance = element as ClassHasProperty;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ClassHasProperty!");
			DslModeling::ModelElement container = instance.ModelClass;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
		
		#region Overrides to provide metadata at runtime
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing Id.
		/// </summary>
		public override bool SerializesId
		{
			get
			{
				return false;
			}
		}
	
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing this relationship in full form.
		/// </summary>
		public override bool UsesFullForm
		{
			get
			{
				return false;
			}
		}
		#endregion
	}
}

namespace Castle.ActiveWriter
{
	/// <summary>
	/// Serializer ManyToManyRelationSerializer for DomainClass ManyToManyRelation.
	/// </summary>
	public partial class ManyToManyRelationSerializer : DslModeling::DomainRelationshipXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// ManyToManyRelationSerializer Constructor
		/// </summary>
		public ManyToManyRelationSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of ManyToManyRelation.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"manyToManyRelation"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of ManyToManyRelation.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"manyToManyRelationMoniker"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of ManyToManyRelation in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"Id"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one ManyToManyRelation instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the ManyToManyRelation element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ManyToManyRelation instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements, which include at least the monikerized instance of target role-player Target
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					ActiveWriterSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read target role-player Target.
					ReadTargetRolePlayer(serializationContext, element, reader);
	
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							ActiveWriterSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
				else
				{
					ActiveWriterSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "ManyToManyRelation");
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		/// <summary>
		/// This method reads the target role player Target.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at the open tag of the first child XML element.
		/// This method will read only one target role player instance. The method will skip any child XML element it encounters until it reaches:
		/// 1) The open tag of the target role player.
		/// 2) The end tag of the parent element (dangling relationship).
		/// 3) EOF (dangling relationship).
		/// After the call, the reader is positioned at:
		/// 1) The open tag of the next child element after the target role player.
		/// 2) The end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ManyToManyRelation instance that will link to the target ModelClass instance.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadTargetRolePlayer(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
	
			// Read the monikerized instance of target role-player Target
			DslModeling::Moniker targetRoleMoniker = null;
			DslModeling::DomainClassXmlSerializer targetRoleSerializer = serializationContext.Directory.GetSerializer(ModelClass.DomainClassId);
			global::System.Diagnostics.Debug.Assert(targetRoleSerializer != null, "Cannot find serializer for ModelClass!");
	
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				targetRoleMoniker = targetRoleSerializer.TryCreateMonikerInstance(serializationContext, reader, ((ManyToManyRelation)element).Source, ManyToManyRelation.DomainClassId, element.Partition);
				if (targetRoleMoniker != null)
				{
					// Attach the target role-player moniker.
					DslModeling::DomainRoleInfo.SetRolePlayerMoniker (element as DslModeling::ElementLink, ManyToManyRelation.TargetDomainRoleId, targetRoleMoniker);
					// Moniker tag has no child XML elements in it, so just skip to the next element.
					DslModeling::SerializationUtilities.Skip(reader);
					break;
				}
				// Encountered one unknown XML element, skip it and keep reading.
				ActiveWriterSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
				DslModeling::SerializationUtilities.Skip(reader);
			}
			if (targetRoleMoniker == null)
			{
				ActiveWriterSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "ManyToManyRelation");
			}
		}
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ManyToManyRelation instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			ManyToManyRelation instanceOfManyToManyRelation = element as ManyToManyRelation;
			global::System.Diagnostics.Debug.Assert(instanceOfManyToManyRelation != null, "Expecting an instance of ManyToManyRelation");
	
			// SourceCache
			if (!serializationContext.Result.Failed)
			{
				string attribSourceCache = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "sourceCache");
				if (attribSourceCache != null)
				{
					CacheEnum valueOfSourceCache;
					if (DslModeling::SerializationUtilities.TryGetValue<CacheEnum>(serializationContext, attribSourceCache, out valueOfSourceCache))
					{
						instanceOfManyToManyRelation.SourceCache = valueOfSourceCache;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceCache", typeof(CacheEnum), attribSourceCache);
					}
				}
			}
			// SourceCascade
			if (!serializationContext.Result.Failed)
			{
				string attribSourceCascade = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "sourceCascade");
				if (attribSourceCascade != null)
				{
					ManyRelationCascadeEnum valueOfSourceCascade;
					if (DslModeling::SerializationUtilities.TryGetValue<ManyRelationCascadeEnum>(serializationContext, attribSourceCascade, out valueOfSourceCascade))
					{
						instanceOfManyToManyRelation.SourceCascade = valueOfSourceCascade;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceCascade", typeof(ManyRelationCascadeEnum), attribSourceCascade);
					}
				}
			}
			// SourceColumn
			if (!serializationContext.Result.Failed)
			{
				string attribSourceColumn = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "sourceColumn");
				if (attribSourceColumn != null)
				{
					global::System.String valueOfSourceColumn;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribSourceColumn, out valueOfSourceColumn))
					{
						instanceOfManyToManyRelation.SourceColumn = valueOfSourceColumn;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceColumn", typeof(global::System.String), attribSourceColumn);
					}
				}
			}
			// SourceCustomAccess
			if (!serializationContext.Result.Failed)
			{
				string attribSourceCustomAccess = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "sourceCustomAccess");
				if (attribSourceCustomAccess != null)
				{
					global::System.String valueOfSourceCustomAccess;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribSourceCustomAccess, out valueOfSourceCustomAccess))
					{
						instanceOfManyToManyRelation.SourceCustomAccess = valueOfSourceCustomAccess;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceCustomAccess", typeof(global::System.String), attribSourceCustomAccess);
					}
				}
			}
			// SourceInverse
			if (!serializationContext.Result.Failed)
			{
				string attribSourceInverse = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "sourceInverse");
				if (attribSourceInverse != null)
				{
					global::System.Boolean valueOfSourceInverse;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribSourceInverse, out valueOfSourceInverse))
					{
						instanceOfManyToManyRelation.SourceInverse = valueOfSourceInverse;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceInverse", typeof(global::System.Boolean), attribSourceInverse);
					}
				}
			}
			// SourceLazy
			if (!serializationContext.Result.Failed)
			{
				string attribSourceLazy = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "sourceLazy");
				if (attribSourceLazy != null)
				{
					global::System.Boolean valueOfSourceLazy;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribSourceLazy, out valueOfSourceLazy))
					{
						instanceOfManyToManyRelation.SourceLazy = valueOfSourceLazy;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceLazy", typeof(global::System.Boolean), attribSourceLazy);
					}
				}
			}
			// SourceMapType
			if (!serializationContext.Result.Failed)
			{
				string attribSourceMapType = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "sourceMapType");
				if (attribSourceMapType != null)
				{
					global::System.String valueOfSourceMapType;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribSourceMapType, out valueOfSourceMapType))
					{
						instanceOfManyToManyRelation.SourceMapType = valueOfSourceMapType;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceMapType", typeof(global::System.String), attribSourceMapType);
					}
				}
			}
			// SourceOrderBy
			if (!serializationContext.Result.Failed)
			{
				string attribSourceOrderBy = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "sourceOrderBy");
				if (attribSourceOrderBy != null)
				{
					global::System.String valueOfSourceOrderBy;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribSourceOrderBy, out valueOfSourceOrderBy))
					{
						instanceOfManyToManyRelation.SourceOrderBy = valueOfSourceOrderBy;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceOrderBy", typeof(global::System.String), attribSourceOrderBy);
					}
				}
			}
			// SourceRelationType
			if (!serializationContext.Result.Failed)
			{
				string attribSourceRelationType = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "sourceRelationType");
				if (attribSourceRelationType != null)
				{
					InheritedRelationType valueOfSourceRelationType;
					if (DslModeling::SerializationUtilities.TryGetValue<InheritedRelationType>(serializationContext, attribSourceRelationType, out valueOfSourceRelationType))
					{
						instanceOfManyToManyRelation.SourceRelationType = valueOfSourceRelationType;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceRelationType", typeof(InheritedRelationType), attribSourceRelationType);
					}
				}
			}
			// Schema
			if (!serializationContext.Result.Failed)
			{
				string attribSchema = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "schema");
				if (attribSchema != null)
				{
					global::System.String valueOfSchema;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribSchema, out valueOfSchema))
					{
						instanceOfManyToManyRelation.Schema = valueOfSchema;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "schema", typeof(global::System.String), attribSchema);
					}
				}
			}
			// SourceSort
			if (!serializationContext.Result.Failed)
			{
				string attribSourceSort = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "sourceSort");
				if (attribSourceSort != null)
				{
					global::System.String valueOfSourceSort;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribSourceSort, out valueOfSourceSort))
					{
						instanceOfManyToManyRelation.SourceSort = valueOfSourceSort;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceSort", typeof(global::System.String), attribSourceSort);
					}
				}
			}
			// Table
			if (!serializationContext.Result.Failed)
			{
				string attribTable = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "table");
				if (attribTable != null)
				{
					global::System.String valueOfTable;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribTable, out valueOfTable))
					{
						instanceOfManyToManyRelation.Table = valueOfTable;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "table", typeof(global::System.String), attribTable);
					}
				}
			}
			// SourceWhere
			if (!serializationContext.Result.Failed)
			{
				string attribSourceWhere = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "sourceWhere");
				if (attribSourceWhere != null)
				{
					global::System.String valueOfSourceWhere;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribSourceWhere, out valueOfSourceWhere))
					{
						instanceOfManyToManyRelation.SourceWhere = valueOfSourceWhere;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceWhere", typeof(global::System.String), attribSourceWhere);
					}
				}
			}
			// TargetCache
			if (!serializationContext.Result.Failed)
			{
				string attribTargetCache = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "targetCache");
				if (attribTargetCache != null)
				{
					CacheEnum valueOfTargetCache;
					if (DslModeling::SerializationUtilities.TryGetValue<CacheEnum>(serializationContext, attribTargetCache, out valueOfTargetCache))
					{
						instanceOfManyToManyRelation.TargetCache = valueOfTargetCache;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetCache", typeof(CacheEnum), attribTargetCache);
					}
				}
			}
			// TargetCascade
			if (!serializationContext.Result.Failed)
			{
				string attribTargetCascade = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "targetCascade");
				if (attribTargetCascade != null)
				{
					ManyRelationCascadeEnum valueOfTargetCascade;
					if (DslModeling::SerializationUtilities.TryGetValue<ManyRelationCascadeEnum>(serializationContext, attribTargetCascade, out valueOfTargetCascade))
					{
						instanceOfManyToManyRelation.TargetCascade = valueOfTargetCascade;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetCascade", typeof(ManyRelationCascadeEnum), attribTargetCascade);
					}
				}
			}
			// TargetColumn
			if (!serializationContext.Result.Failed)
			{
				string attribTargetColumn = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "targetColumn");
				if (attribTargetColumn != null)
				{
					global::System.String valueOfTargetColumn;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribTargetColumn, out valueOfTargetColumn))
					{
						instanceOfManyToManyRelation.TargetColumn = valueOfTargetColumn;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetColumn", typeof(global::System.String), attribTargetColumn);
					}
				}
			}
			// TargetCustomAccess
			if (!serializationContext.Result.Failed)
			{
				string attribTargetCustomAccess = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "targetCustomAccess");
				if (attribTargetCustomAccess != null)
				{
					global::System.String valueOfTargetCustomAccess;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribTargetCustomAccess, out valueOfTargetCustomAccess))
					{
						instanceOfManyToManyRelation.TargetCustomAccess = valueOfTargetCustomAccess;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetCustomAccess", typeof(global::System.String), attribTargetCustomAccess);
					}
				}
			}
			// TargetInverse
			if (!serializationContext.Result.Failed)
			{
				string attribTargetInverse = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "targetInverse");
				if (attribTargetInverse != null)
				{
					global::System.Boolean valueOfTargetInverse;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribTargetInverse, out valueOfTargetInverse))
					{
						instanceOfManyToManyRelation.TargetInverse = valueOfTargetInverse;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetInverse", typeof(global::System.Boolean), attribTargetInverse);
					}
				}
			}
			// TargetLazy
			if (!serializationContext.Result.Failed)
			{
				string attribTargetLazy = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "targetLazy");
				if (attribTargetLazy != null)
				{
					global::System.Boolean valueOfTargetLazy;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribTargetLazy, out valueOfTargetLazy))
					{
						instanceOfManyToManyRelation.TargetLazy = valueOfTargetLazy;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetLazy", typeof(global::System.Boolean), attribTargetLazy);
					}
				}
			}
			// TargetMapType
			if (!serializationContext.Result.Failed)
			{
				string attribTargetMapType = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "targetMapType");
				if (attribTargetMapType != null)
				{
					global::System.String valueOfTargetMapType;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribTargetMapType, out valueOfTargetMapType))
					{
						instanceOfManyToManyRelation.TargetMapType = valueOfTargetMapType;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetMapType", typeof(global::System.String), attribTargetMapType);
					}
				}
			}
			// TargetOrderBy
			if (!serializationContext.Result.Failed)
			{
				string attribTargetOrderBy = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "targetOrderBy");
				if (attribTargetOrderBy != null)
				{
					global::System.String valueOfTargetOrderBy;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribTargetOrderBy, out valueOfTargetOrderBy))
					{
						instanceOfManyToManyRelation.TargetOrderBy = valueOfTargetOrderBy;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetOrderBy", typeof(global::System.String), attribTargetOrderBy);
					}
				}
			}
			// TargetRelationType
			if (!serializationContext.Result.Failed)
			{
				string attribTargetRelationType = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "targetRelationType");
				if (attribTargetRelationType != null)
				{
					InheritedRelationType valueOfTargetRelationType;
					if (DslModeling::SerializationUtilities.TryGetValue<InheritedRelationType>(serializationContext, attribTargetRelationType, out valueOfTargetRelationType))
					{
						instanceOfManyToManyRelation.TargetRelationType = valueOfTargetRelationType;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetRelationType", typeof(InheritedRelationType), attribTargetRelationType);
					}
				}
			}
			// TargetSort
			if (!serializationContext.Result.Failed)
			{
				string attribTargetSort = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "targetSort");
				if (attribTargetSort != null)
				{
					global::System.String valueOfTargetSort;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribTargetSort, out valueOfTargetSort))
					{
						instanceOfManyToManyRelation.TargetSort = valueOfTargetSort;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetSort", typeof(global::System.String), attribTargetSort);
					}
				}
			}
			// TargetWhere
			if (!serializationContext.Result.Failed)
			{
				string attribTargetWhere = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "targetWhere");
				if (attribTargetWhere != null)
				{
					global::System.String valueOfTargetWhere;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribTargetWhere, out valueOfTargetWhere))
					{
						instanceOfManyToManyRelation.TargetWhere = valueOfTargetWhere;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetWhere", typeof(global::System.String), attribTargetWhere);
					}
				}
			}
			// SourceDescription
			if (!serializationContext.Result.Failed)
			{
				string attribSourceDescription = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "sourceDescription");
				if (attribSourceDescription != null)
				{
					global::System.String valueOfSourceDescription;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribSourceDescription, out valueOfSourceDescription))
					{
						instanceOfManyToManyRelation.SourceDescription = valueOfSourceDescription;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceDescription", typeof(global::System.String), attribSourceDescription);
					}
				}
			}
			// TargetDescription
			if (!serializationContext.Result.Failed)
			{
				string attribTargetDescription = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "targetDescription");
				if (attribTargetDescription != null)
				{
					global::System.String valueOfTargetDescription;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribTargetDescription, out valueOfTargetDescription))
					{
						instanceOfManyToManyRelation.TargetDescription = valueOfTargetDescription;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetDescription", typeof(global::System.String), attribTargetDescription);
					}
				}
			}
			// SourceAccess
			if (!serializationContext.Result.Failed)
			{
				string attribSourceAccess = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "sourceAccess");
				if (attribSourceAccess != null)
				{
					InheritablePropertyAccess valueOfSourceAccess;
					if (DslModeling::SerializationUtilities.TryGetValue<InheritablePropertyAccess>(serializationContext, attribSourceAccess, out valueOfSourceAccess))
					{
						instanceOfManyToManyRelation.SourceAccess = valueOfSourceAccess;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceAccess", typeof(InheritablePropertyAccess), attribSourceAccess);
					}
				}
			}
			// TargetAccess
			if (!serializationContext.Result.Failed)
			{
				string attribTargetAccess = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "targetAccess");
				if (attribTargetAccess != null)
				{
					InheritablePropertyAccess valueOfTargetAccess;
					if (DslModeling::SerializationUtilities.TryGetValue<InheritablePropertyAccess>(serializationContext, attribTargetAccess, out valueOfTargetAccess))
					{
						instanceOfManyToManyRelation.TargetAccess = valueOfTargetAccess;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetAccess", typeof(InheritablePropertyAccess), attribTargetAccess);
					}
				}
			}
			// SourcePropertyType
			if (!serializationContext.Result.Failed)
			{
				string attribSourcePropertyType = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "sourcePropertyType");
				if (attribSourcePropertyType != null)
				{
					global::System.String valueOfSourcePropertyType;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribSourcePropertyType, out valueOfSourcePropertyType))
					{
						instanceOfManyToManyRelation.SourcePropertyType = valueOfSourcePropertyType;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourcePropertyType", typeof(global::System.String), attribSourcePropertyType);
					}
				}
			}
			// TargetPropertyType
			if (!serializationContext.Result.Failed)
			{
				string attribTargetPropertyType = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "targetPropertyType");
				if (attribTargetPropertyType != null)
				{
					global::System.String valueOfTargetPropertyType;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribTargetPropertyType, out valueOfTargetPropertyType))
					{
						instanceOfManyToManyRelation.TargetPropertyType = valueOfTargetPropertyType;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetPropertyType", typeof(global::System.String), attribTargetPropertyType);
					}
				}
			}
			// SourcePropertyName
			if (!serializationContext.Result.Failed)
			{
				string attribSourcePropertyName = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "sourcePropertyName");
				if (attribSourcePropertyName != null)
				{
					global::System.String valueOfSourcePropertyName;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribSourcePropertyName, out valueOfSourcePropertyName))
					{
						instanceOfManyToManyRelation.SourcePropertyName = valueOfSourcePropertyName;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourcePropertyName", typeof(global::System.String), attribSourcePropertyName);
					}
				}
			}
			// TargetPropertyName
			if (!serializationContext.Result.Failed)
			{
				string attribTargetPropertyName = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "targetPropertyName");
				if (attribTargetPropertyName != null)
				{
					global::System.String valueOfTargetPropertyName;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribTargetPropertyName, out valueOfTargetPropertyName))
					{
						instanceOfManyToManyRelation.TargetPropertyName = valueOfTargetPropertyName;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetPropertyName", typeof(global::System.String), attribTargetPropertyName);
					}
				}
			}
			// TargetNotFoundBehaviour
			if (!serializationContext.Result.Failed)
			{
				string attribTargetNotFoundBehaviour = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "targetNotFoundBehaviour");
				if (attribTargetNotFoundBehaviour != null)
				{
					NotFoundBehaviour valueOfTargetNotFoundBehaviour;
					if (DslModeling::SerializationUtilities.TryGetValue<NotFoundBehaviour>(serializationContext, attribTargetNotFoundBehaviour, out valueOfTargetNotFoundBehaviour))
					{
						instanceOfManyToManyRelation.TargetNotFoundBehaviour = valueOfTargetNotFoundBehaviour;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetNotFoundBehaviour", typeof(NotFoundBehaviour), attribTargetNotFoundBehaviour);
					}
				}
			}
			// SourceNotFoundBehaviour
			if (!serializationContext.Result.Failed)
			{
				string attribSourceNotFoundBehaviour = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "sourceNotFoundBehaviour");
				if (attribSourceNotFoundBehaviour != null)
				{
					NotFoundBehaviour valueOfSourceNotFoundBehaviour;
					if (DslModeling::SerializationUtilities.TryGetValue<NotFoundBehaviour>(serializationContext, attribSourceNotFoundBehaviour, out valueOfSourceNotFoundBehaviour))
					{
						instanceOfManyToManyRelation.SourceNotFoundBehaviour = valueOfSourceNotFoundBehaviour;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceNotFoundBehaviour", typeof(NotFoundBehaviour), attribSourceNotFoundBehaviour);
					}
				}
			}
			// SourceIUserCollectionType
			if (!serializationContext.Result.Failed)
			{
				string attribSourceIUserCollectionType = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "sourceIUserCollectionType");
				if (attribSourceIUserCollectionType != null)
				{
					global::System.String valueOfSourceIUserCollectionType;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribSourceIUserCollectionType, out valueOfSourceIUserCollectionType))
					{
						instanceOfManyToManyRelation.SourceIUserCollectionType = valueOfSourceIUserCollectionType;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceIUserCollectionType", typeof(global::System.String), attribSourceIUserCollectionType);
					}
				}
			}
			// TargetIUserCollectionType
			if (!serializationContext.Result.Failed)
			{
				string attribTargetIUserCollectionType = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "targetIUserCollectionType");
				if (attribTargetIUserCollectionType != null)
				{
					global::System.String valueOfTargetIUserCollectionType;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribTargetIUserCollectionType, out valueOfTargetIUserCollectionType))
					{
						instanceOfManyToManyRelation.TargetIUserCollectionType = valueOfTargetIUserCollectionType;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetIUserCollectionType", typeof(global::System.String), attribTargetIUserCollectionType);
					}
				}
			}
			// CollectionIDColumn
			if (!serializationContext.Result.Failed)
			{
				string attribCollectionIDColumn = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "collectionIDColumn");
				if (attribCollectionIDColumn != null)
				{
					global::System.String valueOfCollectionIDColumn;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribCollectionIDColumn, out valueOfCollectionIDColumn))
					{
						instanceOfManyToManyRelation.CollectionIDColumn = valueOfCollectionIDColumn;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "collectionIDColumn", typeof(global::System.String), attribCollectionIDColumn);
					}
				}
			}
			// CollectionIDColumnType
			if (!serializationContext.Result.Failed)
			{
				string attribCollectionIDColumnType = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "collectionIDColumnType");
				if (attribCollectionIDColumnType != null)
				{
					NHibernateType valueOfCollectionIDColumnType;
					if (DslModeling::SerializationUtilities.TryGetValue<NHibernateType>(serializationContext, attribCollectionIDColumnType, out valueOfCollectionIDColumnType))
					{
						instanceOfManyToManyRelation.CollectionIDColumnType = valueOfCollectionIDColumnType;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "collectionIDColumnType", typeof(NHibernateType), attribCollectionIDColumnType);
					}
				}
			}
			// CollectionIDGenerator
			if (!serializationContext.Result.Failed)
			{
				string attribCollectionIDGenerator = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "collectionIDGenerator");
				if (attribCollectionIDGenerator != null)
				{
					PrimaryKeyType valueOfCollectionIDGenerator;
					if (DslModeling::SerializationUtilities.TryGetValue<PrimaryKeyType>(serializationContext, attribCollectionIDGenerator, out valueOfCollectionIDGenerator))
					{
						instanceOfManyToManyRelation.CollectionIDGenerator = valueOfCollectionIDGenerator;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "collectionIDGenerator", typeof(PrimaryKeyType), attribCollectionIDGenerator);
					}
				}
			}
			// TargetPropertyGenerated
			if (!serializationContext.Result.Failed)
			{
				string attribTargetPropertyGenerated = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "targetPropertyGenerated");
				if (attribTargetPropertyGenerated != null)
				{
					global::System.Boolean valueOfTargetPropertyGenerated;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribTargetPropertyGenerated, out valueOfTargetPropertyGenerated))
					{
						instanceOfManyToManyRelation.TargetPropertyGenerated = valueOfTargetPropertyGenerated;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetPropertyGenerated", typeof(global::System.Boolean), attribTargetPropertyGenerated);
					}
				}
			}
			// SourcePropertyGenerated
			if (!serializationContext.Result.Failed)
			{
				string attribSourcePropertyGenerated = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "sourcePropertyGenerated");
				if (attribSourcePropertyGenerated != null)
				{
					global::System.Boolean valueOfSourcePropertyGenerated;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribSourcePropertyGenerated, out valueOfSourcePropertyGenerated))
					{
						instanceOfManyToManyRelation.SourcePropertyGenerated = valueOfSourcePropertyGenerated;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourcePropertyGenerated", typeof(global::System.Boolean), attribSourcePropertyGenerated);
					}
				}
			}
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ManyToManyRelation instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadElements(serializationContext, element, reader);
	
		}
	
		#region TryCreateInstance & TryCreateDerivedInstance
		/// <summary>
		/// This method creates a correct instance of ManyToManyRelation based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized ManyToManyRelation, a new ManyToManyRelation instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created ManyToManyRelation instance, or null if the reader is not pointing to a serialized ManyToManyRelation instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, false /* include the type itself */);
		}
	
		/// <summary>
		/// This method creates a correct derived instance of ManyToManyRelation based on the tag currently pointed by the reader.
		/// Note that the difference between this method and the above one is that this method will never create an instance of the
		/// ManyToManyRelation type itself, only derived types are checked.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <returns>Created instance that derives from ManyToManyRelation, or null if the reader is not pointing to such a serialized instance.</returns>
		public override DslModeling::ElementLink TryCreateDerivedInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, true /* derived types only */) as DslModeling::ElementLink;
		}
	
		/// <summary>
		/// Internal helper method for TryCreateInstance() and TryCreateDerivedInstance().
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <param name="derivedTypesOnly">If true, this method will only check derived types, but not the domain class iitself.</param>
		private DslModeling::ModelElement InternalTryCreateInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition, bool derivedTypesOnly)
		{
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (!derivedTypesOnly && string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ManyToManyRelation" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "ManyToManyRelation".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived relationship instance.
						ManyToManyRelationSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ManyToManyRelationSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of ManyToManyRelation based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of ManyToManyRelation.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new ManyToManyRelation instance should be created.</param>	
		/// <returns>Created ManyToManyRelation instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (string.IsNullOrEmpty(idStr))
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					ActiveWriterSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				// Create the link with place-holder role-players.
				return new ManyToManyRelation(
					partition,
					new DslModeling::RoleAssignment[] {
						DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (ManyToManyRelation.SourceDomainRoleId), 
						DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (ManyToManyRelation.TargetDomainRoleId)
					},
					new DslModeling::PropertyAssignment[] {
						new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id)
					}
				);
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				ActiveWriterSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				ActiveWriterSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				ActiveWriterSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from ManyToManyRelation, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from ManyToManyRelation.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ManyToManyRelation.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including ManyToManyRelation itself) instance of ManyToManyRelation based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ManyToManyRelation" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "ManyToManyRelation".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						ManyToManyRelationSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ManyToManyRelationSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of ManyToManyRelation based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				ActiveWriterSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			try
			{	// Normalize the Id.
				global::System.Guid id = new global::System.Guid(monikerString);
				monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
				DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, ManyToManyRelation.DomainClassId, partition.Store), partition.Store);
				// Set location info if possible.
				result.Location = serializationContext.Location;
				global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
				if (xmlLineInfo != null)
				{
					result.Line = xmlLineInfo.LineNumber;
					result.Column = xmlLineInfo.LinePosition;
				}
				return result;
			}
			catch (global::System.FormatException /* fEx */)
			{
				ActiveWriterSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
			catch (global::System.OverflowException /* oEx */)
			{	
				ActiveWriterSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from ManyToManyRelation, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from ManyToManyRelation.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ManyToManyRelation.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized ManyToManyRelation instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ManyToManyRelation instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the ManyToManyRelation instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the ManyToManyRelation instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one ManyToManyRelation instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ManyToManyRelation instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				ActiveWriterSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			// Write the target role-player instance.
			ManyToManyRelation instance = element as ManyToManyRelation;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ManyToManyRelation!");
	
			DslModeling::ModelElement targetElement = instance.Target;
			DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
			global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");
			targetSerializer.WriteMoniker(serializationContext, targetElement, writer, instance.Source, this);
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ManyToManyRelation instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			ManyToManyRelation instanceOfManyToManyRelation = element as ManyToManyRelation;
			global::System.Diagnostics.Debug.Assert(instanceOfManyToManyRelation != null, "Expecting an instance of ManyToManyRelation");
	
			// SourceCache
			if (!serializationContext.Result.Failed)
			{
				CacheEnum propValue = instanceOfManyToManyRelation.SourceCache;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<CacheEnum>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Undefined") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "sourceCache", serializedPropValue);
					}
				}
			}
			// SourceCascade
			if (!serializationContext.Result.Failed)
			{
				ManyRelationCascadeEnum propValue = instanceOfManyToManyRelation.SourceCascade;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<ManyRelationCascadeEnum>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "None") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "sourceCascade", serializedPropValue);
					}
				}
			}
			// SourceColumn
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToManyRelation.SourceColumn;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "sourceColumn", propValue);
	
				}
			}
			// SourceCustomAccess
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToManyRelation.SourceCustomAccess;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "sourceCustomAccess", propValue);
	
				}
			}
			// SourceInverse
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfManyToManyRelation.SourceInverse;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "false") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "sourceInverse", serializedPropValue);
					}
				}
			}
			// SourceLazy
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfManyToManyRelation.SourceLazy;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "false") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "sourceLazy", serializedPropValue);
					}
				}
			}
			// SourceMapType
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToManyRelation.SourceMapType;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "sourceMapType", propValue);
	
				}
			}
			// SourceOrderBy
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToManyRelation.SourceOrderBy;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "sourceOrderBy", propValue);
	
				}
			}
			// SourceRelationType
			if (!serializationContext.Result.Failed)
			{
				InheritedRelationType propValue = instanceOfManyToManyRelation.SourceRelationType;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<InheritedRelationType>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Inherited") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "sourceRelationType", serializedPropValue);
					}
				}
			}
			// Schema
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToManyRelation.Schema;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "schema", propValue);
	
				}
			}
			// SourceSort
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToManyRelation.SourceSort;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "sourceSort", propValue);
	
				}
			}
			// Table
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToManyRelation.Table;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "table", propValue);
	
				}
			}
			// SourceWhere
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToManyRelation.SourceWhere;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "sourceWhere", propValue);
	
				}
			}
			// TargetCache
			if (!serializationContext.Result.Failed)
			{
				CacheEnum propValue = instanceOfManyToManyRelation.TargetCache;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<CacheEnum>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Undefined") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "targetCache", serializedPropValue);
					}
				}
			}
			// TargetCascade
			if (!serializationContext.Result.Failed)
			{
				ManyRelationCascadeEnum propValue = instanceOfManyToManyRelation.TargetCascade;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<ManyRelationCascadeEnum>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "None") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "targetCascade", serializedPropValue);
					}
				}
			}
			// TargetColumn
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToManyRelation.TargetColumn;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "targetColumn", propValue);
	
				}
			}
			// TargetCustomAccess
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToManyRelation.TargetCustomAccess;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "targetCustomAccess", propValue);
	
				}
			}
			// TargetInverse
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfManyToManyRelation.TargetInverse;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "false") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "targetInverse", serializedPropValue);
					}
				}
			}
			// TargetLazy
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfManyToManyRelation.TargetLazy;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "false") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "targetLazy", serializedPropValue);
					}
				}
			}
			// TargetMapType
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToManyRelation.TargetMapType;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "targetMapType", propValue);
	
				}
			}
			// TargetOrderBy
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToManyRelation.TargetOrderBy;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "targetOrderBy", propValue);
	
				}
			}
			// TargetRelationType
			if (!serializationContext.Result.Failed)
			{
				InheritedRelationType propValue = instanceOfManyToManyRelation.TargetRelationType;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<InheritedRelationType>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Inherited") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "targetRelationType", serializedPropValue);
					}
				}
			}
			// TargetSort
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToManyRelation.TargetSort;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "targetSort", propValue);
	
				}
			}
			// TargetWhere
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToManyRelation.TargetWhere;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "targetWhere", propValue);
	
				}
			}
			// SourceDescription
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToManyRelation.SourceDescription;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "sourceDescription", propValue);
	
				}
			}
			// TargetDescription
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToManyRelation.TargetDescription;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "targetDescription", propValue);
	
				}
			}
			// SourceAccess
			if (!serializationContext.Result.Failed)
			{
				InheritablePropertyAccess propValue = instanceOfManyToManyRelation.SourceAccess;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<InheritablePropertyAccess>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Inherit") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "sourceAccess", serializedPropValue);
					}
				}
			}
			// TargetAccess
			if (!serializationContext.Result.Failed)
			{
				InheritablePropertyAccess propValue = instanceOfManyToManyRelation.TargetAccess;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<InheritablePropertyAccess>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Inherit") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "targetAccess", serializedPropValue);
					}
				}
			}
			// SourcePropertyType
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToManyRelation.SourcePropertyType;
				if (!serializationContext.Result.Failed)
				{
					if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, string.Empty) != 0))
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "sourcePropertyType", propValue);
					}
				}
			}
			// TargetPropertyType
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToManyRelation.TargetPropertyType;
				if (!serializationContext.Result.Failed)
				{
					if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, string.Empty) != 0))
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "targetPropertyType", propValue);
					}
				}
			}
			// SourcePropertyName
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToManyRelation.SourcePropertyName;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "sourcePropertyName", propValue);
	
				}
			}
			// TargetPropertyName
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToManyRelation.TargetPropertyName;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "targetPropertyName", propValue);
	
				}
			}
			// TargetNotFoundBehaviour
			if (!serializationContext.Result.Failed)
			{
				NotFoundBehaviour propValue = instanceOfManyToManyRelation.TargetNotFoundBehaviour;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<NotFoundBehaviour>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Default") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "targetNotFoundBehaviour", serializedPropValue);
					}
				}
			}
			// SourceNotFoundBehaviour
			if (!serializationContext.Result.Failed)
			{
				NotFoundBehaviour propValue = instanceOfManyToManyRelation.SourceNotFoundBehaviour;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<NotFoundBehaviour>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Default") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "sourceNotFoundBehaviour", serializedPropValue);
					}
				}
			}
			// SourceIUserCollectionType
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToManyRelation.SourceIUserCollectionType;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "sourceIUserCollectionType", propValue);
	
				}
			}
			// TargetIUserCollectionType
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToManyRelation.TargetIUserCollectionType;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "targetIUserCollectionType", propValue);
	
				}
			}
			// CollectionIDColumn
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToManyRelation.CollectionIDColumn;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "collectionIDColumn", propValue);
	
				}
			}
			// CollectionIDColumnType
			if (!serializationContext.Result.Failed)
			{
				NHibernateType propValue = instanceOfManyToManyRelation.CollectionIDColumnType;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<NHibernateType>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "collectionIDColumnType", serializedPropValue);
				}
			}
			// CollectionIDGenerator
			if (!serializationContext.Result.Failed)
			{
				PrimaryKeyType propValue = instanceOfManyToManyRelation.CollectionIDGenerator;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<PrimaryKeyType>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "collectionIDGenerator", serializedPropValue);
				}
			}
			// TargetPropertyGenerated
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfManyToManyRelation.TargetPropertyGenerated;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "true") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "targetPropertyGenerated", serializedPropValue);
					}
				}
			}
			// SourcePropertyGenerated
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfManyToManyRelation.SourcePropertyGenerated;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "true") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "sourcePropertyGenerated", serializedPropValue);
					}
				}
			}
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ManyToManyRelation instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WriteElements(serializationContext, element, writer);
	
		}
		
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given ManyToManyRelation instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ManyToManyRelation instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the ManyToManyRelation instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ManyToManyRelation instance = element as ManyToManyRelation;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ManyToManyRelation!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ManyToManyRelation instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	
		#region Monikerization Support
		/// <summary>
		/// Calculates a Moniker, given a reference to a ModelClass
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="sourceElement">Instance of ModelClass that contains the given serialized reference</param>
		/// <param name="domainClassId">DomainClassId of the model element that the given moniker string will be resolved to.</param>
		/// <param name="monikerString">Serialized string reference to an instance of ModelClass</param>
		/// <param name="store">Store where the Moniker will be created</param>
		/// <returns>A Moniker encapsulating the serialized string reference of ModelClass instance</returns>
		public override DslModeling::Moniker MonikerizeReference(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement sourceElement, global::System.Guid domainClassId, string monikerString, DslModeling::Store store)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(sourceElement != null);
			if (sourceElement == null)
				throw new global::System.ArgumentNullException ("sourceElement");
			global::System.Diagnostics.Debug.Assert (sourceElement is ModelClass, "Expecting an instance of ModelClass!");
			global::System.Diagnostics.Debug.Assert (!string.IsNullOrEmpty (monikerString));
			if (string.IsNullOrEmpty (monikerString))
				throw new global::System.ArgumentNullException ("monikerString");
			global::System.Diagnostics.Debug.Assert(store != null);
			if (store == null)
				throw new global::System.ArgumentNullException ("store");
			#endregion
			
			DslModeling::MonikerKey key = null;
			if (DslModeling::SimpleMonikerResolver.IsFullyQualified(monikerString))
			{
				key = new DslModeling::MonikerKey(monikerString, ManyToManyRelation.DomainClassId, domainClassId, store);
			}
			else
			{
				DslModeling::DomainClassXmlSerializer sourceSerializer = serializationContext.Directory.GetSerializer(sourceElement.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(sourceSerializer != null, "Cannot find serializer for " + sourceElement.GetDomainClass().Name + "!");
				string sourceQualifier = sourceSerializer.GetMonikerQualifier(serializationContext.Directory, sourceElement);
				key = new DslModeling::MonikerKey(string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "{0}/{1}", sourceQualifier, monikerString), ManyToManyRelation.DomainClassId, domainClassId, store);
			}
			return new DslModeling::Moniker(key, store);
		}
	
		/// <summary>
		/// Calculates a monikerized string reference to a ModelClass.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="sourceElement">Source side of reference relationship. The referenced target element will be serialized.</param>
		/// <param name="targetElement">Target side of relationship that will be serialized.</param>
		/// <returns>A monikerized string reference to target element.</returns>		
		public override string SerializeReference(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement sourceElement, DslModeling::ModelElement targetElement)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(sourceElement != null);
			if (sourceElement == null)
				throw new global::System.ArgumentNullException ("sourceElement");
			global::System.Diagnostics.Debug.Assert (sourceElement is ModelClass, "Expecting an instance of ModelClass!");
			global::System.Diagnostics.Debug.Assert(targetElement != null);
			if (targetElement == null)
				throw new global::System.ArgumentNullException ("targetElement");
			global::System.Diagnostics.Debug.Assert (targetElement is ModelClass, "Expecting an instance of ModelClass!");
			#endregion
			
			// full form reference
			DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
			global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");
			string targetMoniker = targetSerializer.CalculateQualifiedName(serializationContext.Directory, targetElement);
			string targetQualifier = targetSerializer.GetMonikerQualifier(serializationContext.Directory, targetElement);
			
			if (!string.IsNullOrEmpty(targetQualifier))
			{
				DslModeling::DomainClassXmlSerializer sourceSerializer = serializationContext.Directory.GetSerializer(sourceElement.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(sourceSerializer != null, "Cannot find serializer for " + sourceElement.GetDomainClass().Name + "!");
				string sourceQualifier = sourceSerializer.GetMonikerQualifier(serializationContext.Directory, sourceElement);
				if (string.Compare(targetQualifier, sourceQualifier, global::System.StringComparison.CurrentCulture) == 0)
				{
					// See if we can create a short form reference by omitting the qualifier
					global::System.Diagnostics.Debug.Assert(targetMoniker.StartsWith(targetQualifier + "/", global::System.StringComparison.CurrentCulture));
					string shortFormTargetMoniker = targetMoniker.Substring(targetQualifier.Length + 1);
					if (!DslModeling::SimpleMonikerResolver.IsFullyQualified(shortFormTargetMoniker))
						targetMoniker = shortFormTargetMoniker;
				}
			}
	
			return targetMoniker;
		}
		#endregion
		
		#region Overrides to provide metadata at runtime
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing Id.
		/// </summary>
		public override bool SerializesId
		{
			get
			{
				return true;
			}
		}
	
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing this relationship in full form.
		/// </summary>
		public override bool UsesFullForm
		{
			get
			{
				return true;
			}
		}
		#endregion
	}
}

namespace Castle.ActiveWriter
{
	/// <summary>
	/// Serializer OneToOneRelationSerializer for DomainClass OneToOneRelation.
	/// </summary>
	public partial class OneToOneRelationSerializer : DslModeling::DomainRelationshipXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// OneToOneRelationSerializer Constructor
		/// </summary>
		public OneToOneRelationSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of OneToOneRelation.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"oneToOneRelation"; }
		}
	
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one OneToOneRelation instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the OneToOneRelation element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory OneToOneRelation instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements, which include at least the monikerized instance of target role-player Target
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					ActiveWriterSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read target role-player Target.
					ReadTargetRolePlayer(serializationContext, element, reader);
	
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							ActiveWriterSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
				else
				{
					ActiveWriterSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "OneToOneRelation");
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		/// <summary>
		/// This method reads the target role player Target.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at the open tag of the first child XML element.
		/// This method will read only one target role player instance. The method will skip any child XML element it encounters until it reaches:
		/// 1) The open tag of the target role player.
		/// 2) The end tag of the parent element (dangling relationship).
		/// 3) EOF (dangling relationship).
		/// After the call, the reader is positioned at:
		/// 1) The open tag of the next child element after the target role player.
		/// 2) The end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory OneToOneRelation instance that will link to the target ModelClass instance.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadTargetRolePlayer(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
	
			// Read the monikerized instance of target role-player Target
			DslModeling::Moniker targetRoleMoniker = null;
			DslModeling::DomainClassXmlSerializer targetRoleSerializer = serializationContext.Directory.GetSerializer(ModelClass.DomainClassId);
			global::System.Diagnostics.Debug.Assert(targetRoleSerializer != null, "Cannot find serializer for ModelClass!");
	
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				targetRoleMoniker = targetRoleSerializer.TryCreateMonikerInstance(serializationContext, reader, ((OneToOneRelation)element).Source, OneToOneRelation.DomainClassId, element.Partition);
				if (targetRoleMoniker != null)
				{
					// Attach the target role-player moniker.
					DslModeling::DomainRoleInfo.SetRolePlayerMoniker (element as DslModeling::ElementLink, OneToOneRelation.TargetDomainRoleId, targetRoleMoniker);
					// Moniker tag has no child XML elements in it, so just skip to the next element.
					DslModeling::SerializationUtilities.Skip(reader);
					break;
				}
				// Encountered one unknown XML element, skip it and keep reading.
				ActiveWriterSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
				DslModeling::SerializationUtilities.Skip(reader);
			}
			if (targetRoleMoniker == null)
			{
				ActiveWriterSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "OneToOneRelation");
			}
		}
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory OneToOneRelation instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			OneToOneRelation instanceOfOneToOneRelation = element as OneToOneRelation;
			global::System.Diagnostics.Debug.Assert(instanceOfOneToOneRelation != null, "Expecting an instance of OneToOneRelation");
	
			// SourceAccess
			if (!serializationContext.Result.Failed)
			{
				string attribSourceAccess = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "sourceAccess");
				if (attribSourceAccess != null)
				{
					InheritablePropertyAccess valueOfSourceAccess;
					if (DslModeling::SerializationUtilities.TryGetValue<InheritablePropertyAccess>(serializationContext, attribSourceAccess, out valueOfSourceAccess))
					{
						instanceOfOneToOneRelation.SourceAccess = valueOfSourceAccess;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceAccess", typeof(InheritablePropertyAccess), attribSourceAccess);
					}
				}
			}
			// SourceCascade
			if (!serializationContext.Result.Failed)
			{
				string attribSourceCascade = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "sourceCascade");
				if (attribSourceCascade != null)
				{
					CascadeEnum valueOfSourceCascade;
					if (DslModeling::SerializationUtilities.TryGetValue<CascadeEnum>(serializationContext, attribSourceCascade, out valueOfSourceCascade))
					{
						instanceOfOneToOneRelation.SourceCascade = valueOfSourceCascade;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceCascade", typeof(CascadeEnum), attribSourceCascade);
					}
				}
			}
			// SourceConstrained
			if (!serializationContext.Result.Failed)
			{
				string attribSourceConstrained = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "sourceConstrained");
				if (attribSourceConstrained != null)
				{
					global::System.Boolean valueOfSourceConstrained;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribSourceConstrained, out valueOfSourceConstrained))
					{
						instanceOfOneToOneRelation.SourceConstrained = valueOfSourceConstrained;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceConstrained", typeof(global::System.Boolean), attribSourceConstrained);
					}
				}
			}
			// SourceCustomAccess
			if (!serializationContext.Result.Failed)
			{
				string attribSourceCustomAccess = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "sourceCustomAccess");
				if (attribSourceCustomAccess != null)
				{
					global::System.String valueOfSourceCustomAccess;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribSourceCustomAccess, out valueOfSourceCustomAccess))
					{
						instanceOfOneToOneRelation.SourceCustomAccess = valueOfSourceCustomAccess;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceCustomAccess", typeof(global::System.String), attribSourceCustomAccess);
					}
				}
			}
			// SourceOuterJoin
			if (!serializationContext.Result.Failed)
			{
				string attribSourceOuterJoin = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "sourceOuterJoin");
				if (attribSourceOuterJoin != null)
				{
					OuterJoinEnum valueOfSourceOuterJoin;
					if (DslModeling::SerializationUtilities.TryGetValue<OuterJoinEnum>(serializationContext, attribSourceOuterJoin, out valueOfSourceOuterJoin))
					{
						instanceOfOneToOneRelation.SourceOuterJoin = valueOfSourceOuterJoin;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceOuterJoin", typeof(OuterJoinEnum), attribSourceOuterJoin);
					}
				}
			}
			// TargetAccess
			if (!serializationContext.Result.Failed)
			{
				string attribTargetAccess = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "targetAccess");
				if (attribTargetAccess != null)
				{
					InheritablePropertyAccess valueOfTargetAccess;
					if (DslModeling::SerializationUtilities.TryGetValue<InheritablePropertyAccess>(serializationContext, attribTargetAccess, out valueOfTargetAccess))
					{
						instanceOfOneToOneRelation.TargetAccess = valueOfTargetAccess;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetAccess", typeof(InheritablePropertyAccess), attribTargetAccess);
					}
				}
			}
			// TargetCascade
			if (!serializationContext.Result.Failed)
			{
				string attribTargetCascade = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "targetCascade");
				if (attribTargetCascade != null)
				{
					CascadeEnum valueOfTargetCascade;
					if (DslModeling::SerializationUtilities.TryGetValue<CascadeEnum>(serializationContext, attribTargetCascade, out valueOfTargetCascade))
					{
						instanceOfOneToOneRelation.TargetCascade = valueOfTargetCascade;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetCascade", typeof(CascadeEnum), attribTargetCascade);
					}
				}
			}
			// TargetConstrained
			if (!serializationContext.Result.Failed)
			{
				string attribTargetConstrained = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "targetConstrained");
				if (attribTargetConstrained != null)
				{
					global::System.Boolean valueOfTargetConstrained;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribTargetConstrained, out valueOfTargetConstrained))
					{
						instanceOfOneToOneRelation.TargetConstrained = valueOfTargetConstrained;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetConstrained", typeof(global::System.Boolean), attribTargetConstrained);
					}
				}
			}
			// TargetCustomAccess
			if (!serializationContext.Result.Failed)
			{
				string attribTargetCustomAccess = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "targetCustomAccess");
				if (attribTargetCustomAccess != null)
				{
					global::System.String valueOfTargetCustomAccess;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribTargetCustomAccess, out valueOfTargetCustomAccess))
					{
						instanceOfOneToOneRelation.TargetCustomAccess = valueOfTargetCustomAccess;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetCustomAccess", typeof(global::System.String), attribTargetCustomAccess);
					}
				}
			}
			// TargetOuterJoin
			if (!serializationContext.Result.Failed)
			{
				string attribTargetOuterJoin = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "targetOuterJoin");
				if (attribTargetOuterJoin != null)
				{
					OuterJoinEnum valueOfTargetOuterJoin;
					if (DslModeling::SerializationUtilities.TryGetValue<OuterJoinEnum>(serializationContext, attribTargetOuterJoin, out valueOfTargetOuterJoin))
					{
						instanceOfOneToOneRelation.TargetOuterJoin = valueOfTargetOuterJoin;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetOuterJoin", typeof(OuterJoinEnum), attribTargetOuterJoin);
					}
				}
			}
			// SourceDescription
			if (!serializationContext.Result.Failed)
			{
				string attribSourceDescription = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "sourceDescription");
				if (attribSourceDescription != null)
				{
					global::System.String valueOfSourceDescription;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribSourceDescription, out valueOfSourceDescription))
					{
						instanceOfOneToOneRelation.SourceDescription = valueOfSourceDescription;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceDescription", typeof(global::System.String), attribSourceDescription);
					}
				}
			}
			// TargetDescription
			if (!serializationContext.Result.Failed)
			{
				string attribTargetDescription = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "targetDescription");
				if (attribTargetDescription != null)
				{
					global::System.String valueOfTargetDescription;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribTargetDescription, out valueOfTargetDescription))
					{
						instanceOfOneToOneRelation.TargetDescription = valueOfTargetDescription;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetDescription", typeof(global::System.String), attribTargetDescription);
					}
				}
			}
			// Lazy
			if (!serializationContext.Result.Failed)
			{
				string attribLazy = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "lazy");
				if (attribLazy != null)
				{
					global::System.Boolean valueOfLazy;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribLazy, out valueOfLazy))
					{
						instanceOfOneToOneRelation.Lazy = valueOfLazy;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "lazy", typeof(global::System.Boolean), attribLazy);
					}
				}
			}
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory OneToOneRelation instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadElements(serializationContext, element, reader);
	
		}
	
		#region TryCreateInstance & TryCreateDerivedInstance
		/// <summary>
		/// This method creates a correct instance of OneToOneRelation based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized OneToOneRelation, a new OneToOneRelation instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created OneToOneRelation instance, or null if the reader is not pointing to a serialized OneToOneRelation instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, false /* include the type itself */);
		}
	
		/// <summary>
		/// This method creates a correct derived instance of OneToOneRelation based on the tag currently pointed by the reader.
		/// Note that the difference between this method and the above one is that this method will never create an instance of the
		/// OneToOneRelation type itself, only derived types are checked.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <returns>Created instance that derives from OneToOneRelation, or null if the reader is not pointing to such a serialized instance.</returns>
		public override DslModeling::ElementLink TryCreateDerivedInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, true /* derived types only */) as DslModeling::ElementLink;
		}
	
		/// <summary>
		/// Internal helper method for TryCreateInstance() and TryCreateDerivedInstance().
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <param name="derivedTypesOnly">If true, this method will only check derived types, but not the domain class iitself.</param>
		private DslModeling::ModelElement InternalTryCreateInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition, bool derivedTypesOnly)
		{
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (!derivedTypesOnly && string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "OneToOneRelation" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "OneToOneRelation".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived relationship instance.
						OneToOneRelationSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as OneToOneRelationSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of OneToOneRelation based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of OneToOneRelation.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new OneToOneRelation instance should be created.</param>	
		/// <returns>Created OneToOneRelation instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			// Create the link with place-holder role-players.
			return new OneToOneRelation(
				partition,
				DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (OneToOneRelation.SourceDomainRoleId), 
				DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (OneToOneRelation.TargetDomainRoleId)
			);
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from OneToOneRelation, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from OneToOneRelation.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(OneToOneRelation.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including OneToOneRelation itself) instance of OneToOneRelation based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "OneToOneRelation" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "OneToOneRelation".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						OneToOneRelationSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as OneToOneRelationSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of OneToOneRelation based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			// Cannot be monikerized.
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from OneToOneRelation, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from OneToOneRelation.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(OneToOneRelation.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized OneToOneRelation instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">OneToOneRelation instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the OneToOneRelation instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the OneToOneRelation instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			// Instance of OneToOneRelation cannot be monikerized.
			ActiveWriterSerializationBehaviorSerializationMessages.CannotMonikerizeElement(serializationContext, "OneToOneRelation");
		}
		
		/// <summary>
		/// Public Write() method that serializes one OneToOneRelation instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">OneToOneRelation instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				ActiveWriterSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			// Write the target role-player instance.
			OneToOneRelation instance = element as OneToOneRelation;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of OneToOneRelation!");
	
			DslModeling::ModelElement targetElement = instance.Target;
			DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
			global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");
			targetSerializer.WriteMoniker(serializationContext, targetElement, writer, instance.Source, this);
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">OneToOneRelation instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			OneToOneRelation instanceOfOneToOneRelation = element as OneToOneRelation;
			global::System.Diagnostics.Debug.Assert(instanceOfOneToOneRelation != null, "Expecting an instance of OneToOneRelation");
	
			// SourceAccess
			if (!serializationContext.Result.Failed)
			{
				InheritablePropertyAccess propValue = instanceOfOneToOneRelation.SourceAccess;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<InheritablePropertyAccess>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Inherit") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "sourceAccess", serializedPropValue);
					}
				}
			}
			// SourceCascade
			if (!serializationContext.Result.Failed)
			{
				CascadeEnum propValue = instanceOfOneToOneRelation.SourceCascade;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<CascadeEnum>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "None") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "sourceCascade", serializedPropValue);
					}
				}
			}
			// SourceConstrained
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfOneToOneRelation.SourceConstrained;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "false") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "sourceConstrained", serializedPropValue);
					}
				}
			}
			// SourceCustomAccess
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfOneToOneRelation.SourceCustomAccess;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "sourceCustomAccess", propValue);
	
				}
			}
			// SourceOuterJoin
			if (!serializationContext.Result.Failed)
			{
				OuterJoinEnum propValue = instanceOfOneToOneRelation.SourceOuterJoin;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<OuterJoinEnum>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Auto") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "sourceOuterJoin", serializedPropValue);
					}
				}
			}
			// TargetAccess
			if (!serializationContext.Result.Failed)
			{
				InheritablePropertyAccess propValue = instanceOfOneToOneRelation.TargetAccess;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<InheritablePropertyAccess>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Inherit") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "targetAccess", serializedPropValue);
					}
				}
			}
			// TargetCascade
			if (!serializationContext.Result.Failed)
			{
				CascadeEnum propValue = instanceOfOneToOneRelation.TargetCascade;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<CascadeEnum>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "None") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "targetCascade", serializedPropValue);
					}
				}
			}
			// TargetConstrained
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfOneToOneRelation.TargetConstrained;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "false") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "targetConstrained", serializedPropValue);
					}
				}
			}
			// TargetCustomAccess
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfOneToOneRelation.TargetCustomAccess;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "targetCustomAccess", propValue);
	
				}
			}
			// TargetOuterJoin
			if (!serializationContext.Result.Failed)
			{
				OuterJoinEnum propValue = instanceOfOneToOneRelation.TargetOuterJoin;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<OuterJoinEnum>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Auto") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "targetOuterJoin", serializedPropValue);
					}
				}
			}
			// SourceDescription
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfOneToOneRelation.SourceDescription;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "sourceDescription", propValue);
	
				}
			}
			// TargetDescription
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfOneToOneRelation.TargetDescription;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "targetDescription", propValue);
	
				}
			}
			// Lazy
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfOneToOneRelation.Lazy;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "false") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "lazy", serializedPropValue);
					}
				}
			}
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">OneToOneRelation instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WriteElements(serializationContext, element, writer);
	
		}
		
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given OneToOneRelation instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">OneToOneRelation instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the OneToOneRelation instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			OneToOneRelation instance = element as OneToOneRelation;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of OneToOneRelation!");
	
			DslModeling::ModelElement container = instance.Source;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.CalculateQualifiedName(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">OneToOneRelation instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			OneToOneRelation instance = element as OneToOneRelation;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of OneToOneRelation!");
			DslModeling::ModelElement container = instance.Source;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	
		#region Monikerization Support
		/// <summary>
		/// Calculates a Moniker, given a reference to a ModelClass
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="sourceElement">Instance of ModelClass that contains the given serialized reference</param>
		/// <param name="domainClassId">DomainClassId of the model element that the given moniker string will be resolved to.</param>
		/// <param name="monikerString">Serialized string reference to an instance of ModelClass</param>
		/// <param name="store">Store where the Moniker will be created</param>
		/// <returns>A Moniker encapsulating the serialized string reference of ModelClass instance</returns>
		public override DslModeling::Moniker MonikerizeReference(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement sourceElement, global::System.Guid domainClassId, string monikerString, DslModeling::Store store)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(sourceElement != null);
			if (sourceElement == null)
				throw new global::System.ArgumentNullException ("sourceElement");
			global::System.Diagnostics.Debug.Assert (sourceElement is ModelClass, "Expecting an instance of ModelClass!");
			global::System.Diagnostics.Debug.Assert (!string.IsNullOrEmpty (monikerString));
			if (string.IsNullOrEmpty (monikerString))
				throw new global::System.ArgumentNullException ("monikerString");
			global::System.Diagnostics.Debug.Assert(store != null);
			if (store == null)
				throw new global::System.ArgumentNullException ("store");
			#endregion
			
			DslModeling::MonikerKey key = null;
			if (DslModeling::SimpleMonikerResolver.IsFullyQualified(monikerString))
			{
				key = new DslModeling::MonikerKey(monikerString, OneToOneRelation.DomainClassId, domainClassId, store);
			}
			else
			{
				DslModeling::DomainClassXmlSerializer sourceSerializer = serializationContext.Directory.GetSerializer(sourceElement.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(sourceSerializer != null, "Cannot find serializer for " + sourceElement.GetDomainClass().Name + "!");
				string sourceQualifier = sourceSerializer.GetMonikerQualifier(serializationContext.Directory, sourceElement);
				key = new DslModeling::MonikerKey(string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "{0}/{1}", sourceQualifier, monikerString), OneToOneRelation.DomainClassId, domainClassId, store);
			}
			return new DslModeling::Moniker(key, store);
		}
	
		/// <summary>
		/// Calculates a monikerized string reference to a ModelClass.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="sourceElement">Source side of reference relationship. The referenced target element will be serialized.</param>
		/// <param name="targetElement">Target side of relationship that will be serialized.</param>
		/// <returns>A monikerized string reference to target element.</returns>		
		public override string SerializeReference(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement sourceElement, DslModeling::ModelElement targetElement)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(sourceElement != null);
			if (sourceElement == null)
				throw new global::System.ArgumentNullException ("sourceElement");
			global::System.Diagnostics.Debug.Assert (sourceElement is ModelClass, "Expecting an instance of ModelClass!");
			global::System.Diagnostics.Debug.Assert(targetElement != null);
			if (targetElement == null)
				throw new global::System.ArgumentNullException ("targetElement");
			global::System.Diagnostics.Debug.Assert (targetElement is ModelClass, "Expecting an instance of ModelClass!");
			#endregion
			
			// full form reference
			DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
			global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");
			string targetMoniker = targetSerializer.CalculateQualifiedName(serializationContext.Directory, targetElement);
			string targetQualifier = targetSerializer.GetMonikerQualifier(serializationContext.Directory, targetElement);
			
			if (!string.IsNullOrEmpty(targetQualifier))
			{
				DslModeling::DomainClassXmlSerializer sourceSerializer = serializationContext.Directory.GetSerializer(sourceElement.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(sourceSerializer != null, "Cannot find serializer for " + sourceElement.GetDomainClass().Name + "!");
				string sourceQualifier = sourceSerializer.GetMonikerQualifier(serializationContext.Directory, sourceElement);
				if (string.Compare(targetQualifier, sourceQualifier, global::System.StringComparison.CurrentCulture) == 0)
				{
					// See if we can create a short form reference by omitting the qualifier
					global::System.Diagnostics.Debug.Assert(targetMoniker.StartsWith(targetQualifier + "/", global::System.StringComparison.CurrentCulture));
					string shortFormTargetMoniker = targetMoniker.Substring(targetQualifier.Length + 1);
					if (!DslModeling::SimpleMonikerResolver.IsFullyQualified(shortFormTargetMoniker))
						targetMoniker = shortFormTargetMoniker;
				}
			}
	
			return targetMoniker;
		}
		#endregion
		
		#region Overrides to provide metadata at runtime
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing Id.
		/// </summary>
		public override bool SerializesId
		{
			get
			{
				return false;
			}
		}
	
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing this relationship in full form.
		/// </summary>
		public override bool UsesFullForm
		{
			get
			{
				return true;
			}
		}
		#endregion
	}
}

namespace Castle.ActiveWriter
{
	/// <summary>
	/// Serializer ModelHasNestedClassesSerializer for DomainClass ModelHasNestedClasses.
	/// </summary>
	public partial class ModelHasNestedClassesSerializer : DslModeling::DomainRelationshipXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// ModelHasNestedClassesSerializer Constructor
		/// </summary>
		public ModelHasNestedClassesSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of ModelHasNestedClasses.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"modelHasNestedClasses"; }
		}
	
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one ModelHasNestedClasses instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the ModelHasNestedClasses element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ModelHasNestedClasses instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
				
			// Read nested XML elements, which include at least the instance of target role-player NestedClass
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					ActiveWriterSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read target role-player NestedClass.
					ReadTargetRolePlayer(serializationContext, element, reader);
	
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							ActiveWriterSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
				else
				{
					ActiveWriterSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "ModelHasNestedClasses");
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		/// <summary>
		/// This method reads the target role player NestedClass.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at the open tag of the first child XML element.
		/// This method will read only one target role player instance. The method will skip any child XML element it encounters until it reaches:
		/// 1) The open tag of the target role player.
		/// 2) The end tag of the parent element (dangling relationship).
		/// 3) EOF (dangling relationship).
		/// After the call, the reader is positioned at:
		/// 1) The open tag of the next child element after the target role player.
		/// 2) The end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ModelHasNestedClasses instance that will link to the target NestedClass instance.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadTargetRolePlayer(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
	
			// Read the instance of target role-player NestedClass
			DslModeling::ModelElement targetRolePlayer = null;
			DslModeling::DomainClassXmlSerializer targetRoleSerializer = serializationContext.Directory.GetSerializer(NestedClass.DomainClassId);
			global::System.Diagnostics.Debug.Assert(targetRoleSerializer != null, "Cannot find serializer for NestedClass!");
	
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				targetRolePlayer = targetRoleSerializer.TryCreateInstance(serializationContext, reader, element.Partition);
				if (targetRolePlayer != null)
				{
					// Attach the target role-player.
					DslModeling::DomainRoleInfo.SetRolePlayer(element as DslModeling::ElementLink, ModelHasNestedClasses.NestedClassDomainRoleId, targetRolePlayer);
					// Read target role-player.
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (targetRolePlayer.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + targetRolePlayer.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, targetRolePlayer, reader);
					break;
				}
				// Encountered one unknown XML element, skip it and keep reading.
				ActiveWriterSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
				DslModeling::SerializationUtilities.Skip(reader);
			}
			if (targetRolePlayer == null)
			{
				ActiveWriterSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "ModelHasNestedClasses");
			}
		}
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ModelHasNestedClasses instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// There is no property to read; do nothing
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ModelHasNestedClasses instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadElements(serializationContext, element, reader);
	
		}
	
		#region TryCreateInstance & TryCreateDerivedInstance
		/// <summary>
		/// This method creates a correct instance of ModelHasNestedClasses based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized ModelHasNestedClasses, a new ModelHasNestedClasses instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created ModelHasNestedClasses instance, or null if the reader is not pointing to a serialized ModelHasNestedClasses instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, false /* include the type itself */);
		}
	
		/// <summary>
		/// This method creates a correct derived instance of ModelHasNestedClasses based on the tag currently pointed by the reader.
		/// Note that the difference between this method and the above one is that this method will never create an instance of the
		/// ModelHasNestedClasses type itself, only derived types are checked.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <returns>Created instance that derives from ModelHasNestedClasses, or null if the reader is not pointing to such a serialized instance.</returns>
		public override DslModeling::ElementLink TryCreateDerivedInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, true /* derived types only */) as DslModeling::ElementLink;
		}
	
		/// <summary>
		/// Internal helper method for TryCreateInstance() and TryCreateDerivedInstance().
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <param name="derivedTypesOnly">If true, this method will only check derived types, but not the domain class iitself.</param>
		private DslModeling::ModelElement InternalTryCreateInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition, bool derivedTypesOnly)
		{
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (!derivedTypesOnly && string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ModelHasNestedClasses" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "ModelHasNestedClasses".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived relationship instance.
						ModelHasNestedClassesSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ModelHasNestedClassesSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of ModelHasNestedClasses based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of ModelHasNestedClasses.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new ModelHasNestedClasses instance should be created.</param>	
		/// <returns>Created ModelHasNestedClasses instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			// Create the link with place-holder role-players.
			return new ModelHasNestedClasses(
				partition,
				DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (ModelHasNestedClasses.ModelDomainRoleId), 
				DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (ModelHasNestedClasses.NestedClassDomainRoleId)
			);
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from ModelHasNestedClasses, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from ModelHasNestedClasses.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ModelHasNestedClasses.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including ModelHasNestedClasses itself) instance of ModelHasNestedClasses based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ModelHasNestedClasses" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "ModelHasNestedClasses".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						ModelHasNestedClassesSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ModelHasNestedClassesSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of ModelHasNestedClasses based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			// Cannot be monikerized.
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from ModelHasNestedClasses, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from ModelHasNestedClasses.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ModelHasNestedClasses.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized ModelHasNestedClasses instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ModelHasNestedClasses instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the ModelHasNestedClasses instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the ModelHasNestedClasses instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			// Instance of ModelHasNestedClasses cannot be monikerized.
			ActiveWriterSerializationBehaviorSerializationMessages.CannotMonikerizeElement(serializationContext, "ModelHasNestedClasses");
		}
		
		/// <summary>
		/// Public Write() method that serializes one ModelHasNestedClasses instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ModelHasNestedClasses instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ModelHasNestedClasses instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// There are no properties; do nothing
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ModelHasNestedClasses instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WriteElements(serializationContext, element, writer);
	
		}
		
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given ModelHasNestedClasses instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ModelHasNestedClasses instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the ModelHasNestedClasses instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ModelHasNestedClasses instance = element as ModelHasNestedClasses;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ModelHasNestedClasses!");
	
			DslModeling::ModelElement container = instance.Model;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.CalculateQualifiedName(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ModelHasNestedClasses instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ModelHasNestedClasses instance = element as ModelHasNestedClasses;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ModelHasNestedClasses!");
			DslModeling::ModelElement container = instance.Model;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
		
		#region Overrides to provide metadata at runtime
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing Id.
		/// </summary>
		public override bool SerializesId
		{
			get
			{
				return false;
			}
		}
	
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing this relationship in full form.
		/// </summary>
		public override bool UsesFullForm
		{
			get
			{
				return false;
			}
		}
		#endregion
	}
}

namespace Castle.ActiveWriter
{
	/// <summary>
	/// Serializer NestedClassHasPropertiesSerializer for DomainClass NestedClassHasProperties.
	/// </summary>
	public partial class NestedClassHasPropertiesSerializer : DslModeling::DomainRelationshipXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// NestedClassHasPropertiesSerializer Constructor
		/// </summary>
		public NestedClassHasPropertiesSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of NestedClassHasProperties.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"nestedClassHasProperties"; }
		}
	
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one NestedClassHasProperties instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the NestedClassHasProperties element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory NestedClassHasProperties instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
				
			// Read nested XML elements, which include at least the instance of target role-player Property
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					ActiveWriterSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read target role-player Property.
					ReadTargetRolePlayer(serializationContext, element, reader);
	
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							ActiveWriterSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
				else
				{
					ActiveWriterSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "NestedClassHasProperties");
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		/// <summary>
		/// This method reads the target role player Property.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at the open tag of the first child XML element.
		/// This method will read only one target role player instance. The method will skip any child XML element it encounters until it reaches:
		/// 1) The open tag of the target role player.
		/// 2) The end tag of the parent element (dangling relationship).
		/// 3) EOF (dangling relationship).
		/// After the call, the reader is positioned at:
		/// 1) The open tag of the next child element after the target role player.
		/// 2) The end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory NestedClassHasProperties instance that will link to the target ModelProperty instance.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadTargetRolePlayer(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
	
			// Read the instance of target role-player Property
			DslModeling::ModelElement targetRolePlayer = null;
			DslModeling::DomainClassXmlSerializer targetRoleSerializer = serializationContext.Directory.GetSerializer(ModelProperty.DomainClassId);
			global::System.Diagnostics.Debug.Assert(targetRoleSerializer != null, "Cannot find serializer for ModelProperty!");
	
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				targetRolePlayer = targetRoleSerializer.TryCreateInstance(serializationContext, reader, element.Partition);
				if (targetRolePlayer != null)
				{
					// Attach the target role-player.
					DslModeling::DomainRoleInfo.SetRolePlayer(element as DslModeling::ElementLink, NestedClassHasProperties.PropertyDomainRoleId, targetRolePlayer);
					// Read target role-player.
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (targetRolePlayer.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + targetRolePlayer.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, targetRolePlayer, reader);
					break;
				}
				// Encountered one unknown XML element, skip it and keep reading.
				ActiveWriterSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
				DslModeling::SerializationUtilities.Skip(reader);
			}
			if (targetRolePlayer == null)
			{
				ActiveWriterSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "NestedClassHasProperties");
			}
		}
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory NestedClassHasProperties instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// There is no property to read; do nothing
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory NestedClassHasProperties instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadElements(serializationContext, element, reader);
	
		}
	
		#region TryCreateInstance & TryCreateDerivedInstance
		/// <summary>
		/// This method creates a correct instance of NestedClassHasProperties based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized NestedClassHasProperties, a new NestedClassHasProperties instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created NestedClassHasProperties instance, or null if the reader is not pointing to a serialized NestedClassHasProperties instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, false /* include the type itself */);
		}
	
		/// <summary>
		/// This method creates a correct derived instance of NestedClassHasProperties based on the tag currently pointed by the reader.
		/// Note that the difference between this method and the above one is that this method will never create an instance of the
		/// NestedClassHasProperties type itself, only derived types are checked.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <returns>Created instance that derives from NestedClassHasProperties, or null if the reader is not pointing to such a serialized instance.</returns>
		public override DslModeling::ElementLink TryCreateDerivedInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, true /* derived types only */) as DslModeling::ElementLink;
		}
	
		/// <summary>
		/// Internal helper method for TryCreateInstance() and TryCreateDerivedInstance().
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <param name="derivedTypesOnly">If true, this method will only check derived types, but not the domain class iitself.</param>
		private DslModeling::ModelElement InternalTryCreateInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition, bool derivedTypesOnly)
		{
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (!derivedTypesOnly && string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "NestedClassHasProperties" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "NestedClassHasProperties".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived relationship instance.
						NestedClassHasPropertiesSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as NestedClassHasPropertiesSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of NestedClassHasProperties based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of NestedClassHasProperties.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new NestedClassHasProperties instance should be created.</param>	
		/// <returns>Created NestedClassHasProperties instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			// Create the link with place-holder role-players.
			return new NestedClassHasProperties(
				partition,
				DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (NestedClassHasProperties.NestedClassDomainRoleId), 
				DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (NestedClassHasProperties.PropertyDomainRoleId)
			);
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from NestedClassHasProperties, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from NestedClassHasProperties.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(NestedClassHasProperties.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including NestedClassHasProperties itself) instance of NestedClassHasProperties based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "NestedClassHasProperties" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "NestedClassHasProperties".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						NestedClassHasPropertiesSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as NestedClassHasPropertiesSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of NestedClassHasProperties based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			// Cannot be monikerized.
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from NestedClassHasProperties, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from NestedClassHasProperties.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(NestedClassHasProperties.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized NestedClassHasProperties instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">NestedClassHasProperties instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the NestedClassHasProperties instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the NestedClassHasProperties instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			// Instance of NestedClassHasProperties cannot be monikerized.
			ActiveWriterSerializationBehaviorSerializationMessages.CannotMonikerizeElement(serializationContext, "NestedClassHasProperties");
		}
		
		/// <summary>
		/// Public Write() method that serializes one NestedClassHasProperties instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">NestedClassHasProperties instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">NestedClassHasProperties instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// There are no properties; do nothing
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">NestedClassHasProperties instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WriteElements(serializationContext, element, writer);
	
		}
		
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given NestedClassHasProperties instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">NestedClassHasProperties instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the NestedClassHasProperties instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			NestedClassHasProperties instance = element as NestedClassHasProperties;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of NestedClassHasProperties!");
	
			DslModeling::ModelElement container = instance.NestedClass;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.CalculateQualifiedName(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">NestedClassHasProperties instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			NestedClassHasProperties instance = element as NestedClassHasProperties;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of NestedClassHasProperties!");
			DslModeling::ModelElement container = instance.NestedClass;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
		
		#region Overrides to provide metadata at runtime
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing Id.
		/// </summary>
		public override bool SerializesId
		{
			get
			{
				return false;
			}
		}
	
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing this relationship in full form.
		/// </summary>
		public override bool UsesFullForm
		{
			get
			{
				return false;
			}
		}
		#endregion
	}
}

namespace Castle.ActiveWriter
{
	/// <summary>
	/// Serializer NestedClassReferencesModelClassesSerializer for DomainClass NestedClassReferencesModelClasses.
	/// </summary>
	public partial class NestedClassReferencesModelClassesSerializer : DslModeling::DomainRelationshipXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// NestedClassReferencesModelClassesSerializer Constructor
		/// </summary>
		public NestedClassReferencesModelClassesSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of NestedClassReferencesModelClasses.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"nestedClassReferencesModelClasses"; }
		}
	
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one NestedClassReferencesModelClasses instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the NestedClassReferencesModelClasses element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory NestedClassReferencesModelClasses instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements, which include at least the monikerized instance of target role-player ModelClass
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					ActiveWriterSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read target role-player ModelClass.
					ReadTargetRolePlayer(serializationContext, element, reader);
	
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							ActiveWriterSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
				else
				{
					ActiveWriterSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "NestedClassReferencesModelClasses");
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		/// <summary>
		/// This method reads the target role player ModelClass.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at the open tag of the first child XML element.
		/// This method will read only one target role player instance. The method will skip any child XML element it encounters until it reaches:
		/// 1) The open tag of the target role player.
		/// 2) The end tag of the parent element (dangling relationship).
		/// 3) EOF (dangling relationship).
		/// After the call, the reader is positioned at:
		/// 1) The open tag of the next child element after the target role player.
		/// 2) The end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory NestedClassReferencesModelClasses instance that will link to the target ModelClass instance.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadTargetRolePlayer(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
	
			// Read the monikerized instance of target role-player ModelClass
			DslModeling::Moniker targetRoleMoniker = null;
			DslModeling::DomainClassXmlSerializer targetRoleSerializer = serializationContext.Directory.GetSerializer(ModelClass.DomainClassId);
			global::System.Diagnostics.Debug.Assert(targetRoleSerializer != null, "Cannot find serializer for ModelClass!");
	
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				targetRoleMoniker = targetRoleSerializer.TryCreateMonikerInstance(serializationContext, reader, ((NestedClassReferencesModelClasses)element).NestedClass, NestedClassReferencesModelClasses.DomainClassId, element.Partition);
				if (targetRoleMoniker != null)
				{
					// Attach the target role-player moniker.
					DslModeling::DomainRoleInfo.SetRolePlayerMoniker (element as DslModeling::ElementLink, NestedClassReferencesModelClasses.ModelClassDomainRoleId, targetRoleMoniker);
					// Moniker tag has no child XML elements in it, so just skip to the next element.
					DslModeling::SerializationUtilities.Skip(reader);
					break;
				}
				// Encountered one unknown XML element, skip it and keep reading.
				ActiveWriterSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
				DslModeling::SerializationUtilities.Skip(reader);
			}
			if (targetRoleMoniker == null)
			{
				ActiveWriterSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "NestedClassReferencesModelClasses");
			}
		}
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory NestedClassReferencesModelClasses instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			NestedClassReferencesModelClasses instanceOfNestedClassReferencesModelClasses = element as NestedClassReferencesModelClasses;
			global::System.Diagnostics.Debug.Assert(instanceOfNestedClassReferencesModelClasses != null, "Expecting an instance of NestedClassReferencesModelClasses");
	
			// MapType
			if (!serializationContext.Result.Failed)
			{
				string attribMapType = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "mapType");
				if (attribMapType != null)
				{
					global::System.String valueOfMapType;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribMapType, out valueOfMapType))
					{
						instanceOfNestedClassReferencesModelClasses.MapType = valueOfMapType;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "mapType", typeof(global::System.String), attribMapType);
					}
				}
			}
			// Insert
			if (!serializationContext.Result.Failed)
			{
				string attribInsert = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "insert");
				if (attribInsert != null)
				{
					global::System.Boolean valueOfInsert;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribInsert, out valueOfInsert))
					{
						instanceOfNestedClassReferencesModelClasses.Insert = valueOfInsert;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "insert", typeof(global::System.Boolean), attribInsert);
					}
				}
			}
			// Update
			if (!serializationContext.Result.Failed)
			{
				string attribUpdate = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "update");
				if (attribUpdate != null)
				{
					global::System.Boolean valueOfUpdate;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribUpdate, out valueOfUpdate))
					{
						instanceOfNestedClassReferencesModelClasses.Update = valueOfUpdate;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "update", typeof(global::System.Boolean), attribUpdate);
					}
				}
			}
			// ColumnPrefix
			if (!serializationContext.Result.Failed)
			{
				string attribColumnPrefix = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "columnPrefix");
				if (attribColumnPrefix != null)
				{
					global::System.String valueOfColumnPrefix;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribColumnPrefix, out valueOfColumnPrefix))
					{
						instanceOfNestedClassReferencesModelClasses.ColumnPrefix = valueOfColumnPrefix;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "columnPrefix", typeof(global::System.String), attribColumnPrefix);
					}
				}
			}
			// Description
			if (!serializationContext.Result.Failed)
			{
				string attribDescription = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "description");
				if (attribDescription != null)
				{
					global::System.String valueOfDescription;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribDescription, out valueOfDescription))
					{
						instanceOfNestedClassReferencesModelClasses.Description = valueOfDescription;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "description", typeof(global::System.String), attribDescription);
					}
				}
			}
			// PropertyName
			if (!serializationContext.Result.Failed)
			{
				string attribPropertyName = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "propertyName");
				if (attribPropertyName != null)
				{
					global::System.String valueOfPropertyName;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribPropertyName, out valueOfPropertyName))
					{
						instanceOfNestedClassReferencesModelClasses.PropertyName = valueOfPropertyName;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "propertyName", typeof(global::System.String), attribPropertyName);
					}
				}
			}
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory NestedClassReferencesModelClasses instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadElements(serializationContext, element, reader);
	
		}
	
		#region TryCreateInstance & TryCreateDerivedInstance
		/// <summary>
		/// This method creates a correct instance of NestedClassReferencesModelClasses based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized NestedClassReferencesModelClasses, a new NestedClassReferencesModelClasses instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created NestedClassReferencesModelClasses instance, or null if the reader is not pointing to a serialized NestedClassReferencesModelClasses instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, false /* include the type itself */);
		}
	
		/// <summary>
		/// This method creates a correct derived instance of NestedClassReferencesModelClasses based on the tag currently pointed by the reader.
		/// Note that the difference between this method and the above one is that this method will never create an instance of the
		/// NestedClassReferencesModelClasses type itself, only derived types are checked.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <returns>Created instance that derives from NestedClassReferencesModelClasses, or null if the reader is not pointing to such a serialized instance.</returns>
		public override DslModeling::ElementLink TryCreateDerivedInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, true /* derived types only */) as DslModeling::ElementLink;
		}
	
		/// <summary>
		/// Internal helper method for TryCreateInstance() and TryCreateDerivedInstance().
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <param name="derivedTypesOnly">If true, this method will only check derived types, but not the domain class iitself.</param>
		private DslModeling::ModelElement InternalTryCreateInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition, bool derivedTypesOnly)
		{
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (!derivedTypesOnly && string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "NestedClassReferencesModelClasses" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "NestedClassReferencesModelClasses".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived relationship instance.
						NestedClassReferencesModelClassesSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as NestedClassReferencesModelClassesSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of NestedClassReferencesModelClasses based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of NestedClassReferencesModelClasses.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new NestedClassReferencesModelClasses instance should be created.</param>	
		/// <returns>Created NestedClassReferencesModelClasses instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			// Create the link with place-holder role-players.
			return new NestedClassReferencesModelClasses(
				partition,
				DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (NestedClassReferencesModelClasses.NestedClassDomainRoleId), 
				DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (NestedClassReferencesModelClasses.ModelClassDomainRoleId)
			);
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from NestedClassReferencesModelClasses, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from NestedClassReferencesModelClasses.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(NestedClassReferencesModelClasses.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including NestedClassReferencesModelClasses itself) instance of NestedClassReferencesModelClasses based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "NestedClassReferencesModelClasses" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "NestedClassReferencesModelClasses".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						NestedClassReferencesModelClassesSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as NestedClassReferencesModelClassesSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of NestedClassReferencesModelClasses based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			// Cannot be monikerized.
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from NestedClassReferencesModelClasses, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from NestedClassReferencesModelClasses.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(NestedClassReferencesModelClasses.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized NestedClassReferencesModelClasses instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">NestedClassReferencesModelClasses instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the NestedClassReferencesModelClasses instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the NestedClassReferencesModelClasses instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			// Instance of NestedClassReferencesModelClasses cannot be monikerized.
			ActiveWriterSerializationBehaviorSerializationMessages.CannotMonikerizeElement(serializationContext, "NestedClassReferencesModelClasses");
		}
		
		/// <summary>
		/// Public Write() method that serializes one NestedClassReferencesModelClasses instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">NestedClassReferencesModelClasses instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				ActiveWriterSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			// Write the target role-player instance.
			NestedClassReferencesModelClasses instance = element as NestedClassReferencesModelClasses;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of NestedClassReferencesModelClasses!");
	
			DslModeling::ModelElement targetElement = instance.ModelClass;
			DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
			global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");
			targetSerializer.WriteMoniker(serializationContext, targetElement, writer, instance.NestedClass, this);
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">NestedClassReferencesModelClasses instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			NestedClassReferencesModelClasses instanceOfNestedClassReferencesModelClasses = element as NestedClassReferencesModelClasses;
			global::System.Diagnostics.Debug.Assert(instanceOfNestedClassReferencesModelClasses != null, "Expecting an instance of NestedClassReferencesModelClasses");
	
			// MapType
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfNestedClassReferencesModelClasses.MapType;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "mapType", propValue);
	
				}
			}
			// Insert
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfNestedClassReferencesModelClasses.Insert;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "true") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "insert", serializedPropValue);
					}
				}
			}
			// Update
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfNestedClassReferencesModelClasses.Update;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "true") != 0)
					{	// No need to write the value out if it's the same as default value.
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "update", serializedPropValue);
					}
				}
			}
			// ColumnPrefix
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfNestedClassReferencesModelClasses.ColumnPrefix;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "columnPrefix", propValue);
	
				}
			}
			// Description
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfNestedClassReferencesModelClasses.Description;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "description", propValue);
	
				}
			}
			// PropertyName
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfNestedClassReferencesModelClasses.PropertyName;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "propertyName", propValue);
	
				}
			}
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">NestedClassReferencesModelClasses instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WriteElements(serializationContext, element, writer);
	
		}
		
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given NestedClassReferencesModelClasses instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">NestedClassReferencesModelClasses instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the NestedClassReferencesModelClasses instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			NestedClassReferencesModelClasses instance = element as NestedClassReferencesModelClasses;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of NestedClassReferencesModelClasses!");
	
			DslModeling::ModelElement container = instance.NestedClass;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.CalculateQualifiedName(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">NestedClassReferencesModelClasses instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			NestedClassReferencesModelClasses instance = element as NestedClassReferencesModelClasses;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of NestedClassReferencesModelClasses!");
			DslModeling::ModelElement container = instance.NestedClass;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	
		#region Monikerization Support
		/// <summary>
		/// Calculates a Moniker, given a reference to a ModelClass
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="sourceElement">Instance of NestedClass that contains the given serialized reference</param>
		/// <param name="domainClassId">DomainClassId of the model element that the given moniker string will be resolved to.</param>
		/// <param name="monikerString">Serialized string reference to an instance of ModelClass</param>
		/// <param name="store">Store where the Moniker will be created</param>
		/// <returns>A Moniker encapsulating the serialized string reference of ModelClass instance</returns>
		public override DslModeling::Moniker MonikerizeReference(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement sourceElement, global::System.Guid domainClassId, string monikerString, DslModeling::Store store)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(sourceElement != null);
			if (sourceElement == null)
				throw new global::System.ArgumentNullException ("sourceElement");
			global::System.Diagnostics.Debug.Assert (sourceElement is NestedClass, "Expecting an instance of NestedClass!");
			global::System.Diagnostics.Debug.Assert (!string.IsNullOrEmpty (monikerString));
			if (string.IsNullOrEmpty (monikerString))
				throw new global::System.ArgumentNullException ("monikerString");
			global::System.Diagnostics.Debug.Assert(store != null);
			if (store == null)
				throw new global::System.ArgumentNullException ("store");
			#endregion
			
			DslModeling::MonikerKey key = null;
			if (DslModeling::SimpleMonikerResolver.IsFullyQualified(monikerString))
			{
				key = new DslModeling::MonikerKey(monikerString, NestedClassReferencesModelClasses.DomainClassId, domainClassId, store);
			}
			else
			{
				DslModeling::DomainClassXmlSerializer sourceSerializer = serializationContext.Directory.GetSerializer(sourceElement.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(sourceSerializer != null, "Cannot find serializer for " + sourceElement.GetDomainClass().Name + "!");
				string sourceQualifier = sourceSerializer.GetMonikerQualifier(serializationContext.Directory, sourceElement);
				key = new DslModeling::MonikerKey(string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "{0}/{1}", sourceQualifier, monikerString), NestedClassReferencesModelClasses.DomainClassId, domainClassId, store);
			}
			return new DslModeling::Moniker(key, store);
		}
	
		/// <summary>
		/// Calculates a monikerized string reference to a ModelClass.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="sourceElement">Source side of reference relationship. The referenced target element will be serialized.</param>
		/// <param name="targetElement">Target side of relationship that will be serialized.</param>
		/// <returns>A monikerized string reference to target element.</returns>		
		public override string SerializeReference(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement sourceElement, DslModeling::ModelElement targetElement)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(sourceElement != null);
			if (sourceElement == null)
				throw new global::System.ArgumentNullException ("sourceElement");
			global::System.Diagnostics.Debug.Assert (sourceElement is NestedClass, "Expecting an instance of NestedClass!");
			global::System.Diagnostics.Debug.Assert(targetElement != null);
			if (targetElement == null)
				throw new global::System.ArgumentNullException ("targetElement");
			global::System.Diagnostics.Debug.Assert (targetElement is ModelClass, "Expecting an instance of ModelClass!");
			#endregion
			
			// full form reference
			DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
			global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");
			string targetMoniker = targetSerializer.CalculateQualifiedName(serializationContext.Directory, targetElement);
			string targetQualifier = targetSerializer.GetMonikerQualifier(serializationContext.Directory, targetElement);
			
			if (!string.IsNullOrEmpty(targetQualifier))
			{
				DslModeling::DomainClassXmlSerializer sourceSerializer = serializationContext.Directory.GetSerializer(sourceElement.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(sourceSerializer != null, "Cannot find serializer for " + sourceElement.GetDomainClass().Name + "!");
				string sourceQualifier = sourceSerializer.GetMonikerQualifier(serializationContext.Directory, sourceElement);
				if (string.Compare(targetQualifier, sourceQualifier, global::System.StringComparison.CurrentCulture) == 0)
				{
					// See if we can create a short form reference by omitting the qualifier
					global::System.Diagnostics.Debug.Assert(targetMoniker.StartsWith(targetQualifier + "/", global::System.StringComparison.CurrentCulture));
					string shortFormTargetMoniker = targetMoniker.Substring(targetQualifier.Length + 1);
					if (!DslModeling::SimpleMonikerResolver.IsFullyQualified(shortFormTargetMoniker))
						targetMoniker = shortFormTargetMoniker;
				}
			}
	
			return targetMoniker;
		}
		#endregion
		
		#region Overrides to provide metadata at runtime
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing Id.
		/// </summary>
		public override bool SerializesId
		{
			get
			{
				return false;
			}
		}
	
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing this relationship in full form.
		/// </summary>
		public override bool UsesFullForm
		{
			get
			{
				return true;
			}
		}
		#endregion
	}
}

namespace Castle.ActiveWriter
{
	/// <summary>
	/// Serializer InheritanceRelationSerializer for DomainClass InheritanceRelation.
	/// </summary>
	public partial class InheritanceRelationSerializer : DslModeling::DomainRelationshipXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// InheritanceRelationSerializer Constructor
		/// </summary>
		public InheritanceRelationSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of InheritanceRelation.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"inheritanceRelation"; }
		}
	
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one InheritanceRelation instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the InheritanceRelation element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory InheritanceRelation instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
				
			// Read nested XML elements, which include at least the monikerized instance of target role-player TargetModelClass
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					ActiveWriterSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read target role-player TargetModelClass.
					ReadTargetRolePlayer(serializationContext, element, reader);
	
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							ActiveWriterSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
				else
				{
					ActiveWriterSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "InheritanceRelation");
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		/// <summary>
		/// This method reads the target role player TargetModelClass.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at the open tag of the first child XML element.
		/// This method will read only one target role player instance. The method will skip any child XML element it encounters until it reaches:
		/// 1) The open tag of the target role player.
		/// 2) The end tag of the parent element (dangling relationship).
		/// 3) EOF (dangling relationship).
		/// After the call, the reader is positioned at:
		/// 1) The open tag of the next child element after the target role player.
		/// 2) The end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory InheritanceRelation instance that will link to the target ModelClass instance.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadTargetRolePlayer(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
	
			// Read the monikerized instance of target role-player TargetModelClass
			DslModeling::Moniker targetRoleMoniker = null;
			DslModeling::DomainClassXmlSerializer targetRoleSerializer = serializationContext.Directory.GetSerializer(ModelClass.DomainClassId);
			global::System.Diagnostics.Debug.Assert(targetRoleSerializer != null, "Cannot find serializer for ModelClass!");
	
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				targetRoleMoniker = targetRoleSerializer.TryCreateMonikerInstance(serializationContext, reader, ((InheritanceRelation)element).SourceModelClass, InheritanceRelation.DomainClassId, element.Partition);
				if (targetRoleMoniker != null)
				{
					// Attach the target role-player moniker.
					DslModeling::DomainRoleInfo.SetRolePlayerMoniker (element as DslModeling::ElementLink, InheritanceRelation.TargetModelClassDomainRoleId, targetRoleMoniker);
					// Moniker tag has no child XML elements in it, so just skip to the next element.
					DslModeling::SerializationUtilities.Skip(reader);
					break;
				}
				// Encountered one unknown XML element, skip it and keep reading.
				ActiveWriterSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
				DslModeling::SerializationUtilities.Skip(reader);
			}
			if (targetRoleMoniker == null)
			{
				ActiveWriterSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "InheritanceRelation");
			}
		}
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory InheritanceRelation instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// There is no property to read; do nothing
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory InheritanceRelation instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadElements(serializationContext, element, reader);
	
		}
	
		#region TryCreateInstance & TryCreateDerivedInstance
		/// <summary>
		/// This method creates a correct instance of InheritanceRelation based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized InheritanceRelation, a new InheritanceRelation instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created InheritanceRelation instance, or null if the reader is not pointing to a serialized InheritanceRelation instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, false /* include the type itself */);
		}
	
		/// <summary>
		/// This method creates a correct derived instance of InheritanceRelation based on the tag currently pointed by the reader.
		/// Note that the difference between this method and the above one is that this method will never create an instance of the
		/// InheritanceRelation type itself, only derived types are checked.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <returns>Created instance that derives from InheritanceRelation, or null if the reader is not pointing to such a serialized instance.</returns>
		public override DslModeling::ElementLink TryCreateDerivedInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, true /* derived types only */) as DslModeling::ElementLink;
		}
	
		/// <summary>
		/// Internal helper method for TryCreateInstance() and TryCreateDerivedInstance().
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <param name="derivedTypesOnly">If true, this method will only check derived types, but not the domain class iitself.</param>
		private DslModeling::ModelElement InternalTryCreateInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition, bool derivedTypesOnly)
		{
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (!derivedTypesOnly && string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "InheritanceRelation" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "InheritanceRelation".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived relationship instance.
						InheritanceRelationSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as InheritanceRelationSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of InheritanceRelation based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of InheritanceRelation.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new InheritanceRelation instance should be created.</param>	
		/// <returns>Created InheritanceRelation instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			// Create the link with place-holder role-players.
			return new InheritanceRelation(
				partition,
				DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (InheritanceRelation.SourceModelClassDomainRoleId), 
				DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (InheritanceRelation.TargetModelClassDomainRoleId)
			);
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from InheritanceRelation, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from InheritanceRelation.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(InheritanceRelation.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including InheritanceRelation itself) instance of InheritanceRelation based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "InheritanceRelation" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "InheritanceRelation".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						InheritanceRelationSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as InheritanceRelationSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of InheritanceRelation based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			// Cannot be monikerized.
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from InheritanceRelation, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from InheritanceRelation.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(InheritanceRelation.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized InheritanceRelation instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">InheritanceRelation instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the InheritanceRelation instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the InheritanceRelation instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			// Instance of InheritanceRelation cannot be monikerized.
			ActiveWriterSerializationBehaviorSerializationMessages.CannotMonikerizeElement(serializationContext, "InheritanceRelation");
		}
		
		/// <summary>
		/// Public Write() method that serializes one InheritanceRelation instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">InheritanceRelation instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">InheritanceRelation instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// There are no properties; do nothing
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">InheritanceRelation instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WriteElements(serializationContext, element, writer);
	
		}
		
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given InheritanceRelation instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">InheritanceRelation instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the InheritanceRelation instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			InheritanceRelation instance = element as InheritanceRelation;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of InheritanceRelation!");
	
			DslModeling::ModelElement container = instance.SourceModelClass;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.CalculateQualifiedName(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">InheritanceRelation instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			InheritanceRelation instance = element as InheritanceRelation;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of InheritanceRelation!");
			DslModeling::ModelElement container = instance.SourceModelClass;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	
		#region Monikerization Support
		/// <summary>
		/// Calculates a Moniker, given a reference to a ModelClass
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="sourceElement">Instance of ModelClass that contains the given serialized reference</param>
		/// <param name="domainClassId">DomainClassId of the model element that the given moniker string will be resolved to.</param>
		/// <param name="monikerString">Serialized string reference to an instance of ModelClass</param>
		/// <param name="store">Store where the Moniker will be created</param>
		/// <returns>A Moniker encapsulating the serialized string reference of ModelClass instance</returns>
		public override DslModeling::Moniker MonikerizeReference(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement sourceElement, global::System.Guid domainClassId, string monikerString, DslModeling::Store store)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(sourceElement != null);
			if (sourceElement == null)
				throw new global::System.ArgumentNullException ("sourceElement");
			global::System.Diagnostics.Debug.Assert (sourceElement is ModelClass, "Expecting an instance of ModelClass!");
			global::System.Diagnostics.Debug.Assert (!string.IsNullOrEmpty (monikerString));
			if (string.IsNullOrEmpty (monikerString))
				throw new global::System.ArgumentNullException ("monikerString");
			global::System.Diagnostics.Debug.Assert(store != null);
			if (store == null)
				throw new global::System.ArgumentNullException ("store");
			#endregion
			
			DslModeling::MonikerKey key = null;
			if (DslModeling::SimpleMonikerResolver.IsFullyQualified(monikerString))
			{
				key = new DslModeling::MonikerKey(monikerString, InheritanceRelation.DomainClassId, domainClassId, store);
			}
			else
			{
				DslModeling::DomainClassXmlSerializer sourceSerializer = serializationContext.Directory.GetSerializer(sourceElement.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(sourceSerializer != null, "Cannot find serializer for " + sourceElement.GetDomainClass().Name + "!");
				string sourceQualifier = sourceSerializer.GetMonikerQualifier(serializationContext.Directory, sourceElement);
				key = new DslModeling::MonikerKey(string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "{0}/{1}", sourceQualifier, monikerString), InheritanceRelation.DomainClassId, domainClassId, store);
			}
			return new DslModeling::Moniker(key, store);
		}
	
		/// <summary>
		/// Calculates a monikerized string reference to a ModelClass.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="sourceElement">Source side of reference relationship. The referenced target element will be serialized.</param>
		/// <param name="targetElement">Target side of relationship that will be serialized.</param>
		/// <returns>A monikerized string reference to target element.</returns>		
		public override string SerializeReference(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement sourceElement, DslModeling::ModelElement targetElement)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(sourceElement != null);
			if (sourceElement == null)
				throw new global::System.ArgumentNullException ("sourceElement");
			global::System.Diagnostics.Debug.Assert (sourceElement is ModelClass, "Expecting an instance of ModelClass!");
			global::System.Diagnostics.Debug.Assert(targetElement != null);
			if (targetElement == null)
				throw new global::System.ArgumentNullException ("targetElement");
			global::System.Diagnostics.Debug.Assert (targetElement is ModelClass, "Expecting an instance of ModelClass!");
			#endregion
			
			// full form reference
			DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
			global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");
			string targetMoniker = targetSerializer.CalculateQualifiedName(serializationContext.Directory, targetElement);
			string targetQualifier = targetSerializer.GetMonikerQualifier(serializationContext.Directory, targetElement);
			
			if (!string.IsNullOrEmpty(targetQualifier))
			{
				DslModeling::DomainClassXmlSerializer sourceSerializer = serializationContext.Directory.GetSerializer(sourceElement.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(sourceSerializer != null, "Cannot find serializer for " + sourceElement.GetDomainClass().Name + "!");
				string sourceQualifier = sourceSerializer.GetMonikerQualifier(serializationContext.Directory, sourceElement);
				if (string.Compare(targetQualifier, sourceQualifier, global::System.StringComparison.CurrentCulture) == 0)
				{
					// See if we can create a short form reference by omitting the qualifier
					global::System.Diagnostics.Debug.Assert(targetMoniker.StartsWith(targetQualifier + "/", global::System.StringComparison.CurrentCulture));
					string shortFormTargetMoniker = targetMoniker.Substring(targetQualifier.Length + 1);
					if (!DslModeling::SimpleMonikerResolver.IsFullyQualified(shortFormTargetMoniker))
						targetMoniker = shortFormTargetMoniker;
				}
			}
	
			return targetMoniker;
		}
		#endregion
		
		#region Overrides to provide metadata at runtime
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing Id.
		/// </summary>
		public override bool SerializesId
		{
			get
			{
				return false;
			}
		}
	
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing this relationship in full form.
		/// </summary>
		public override bool UsesFullForm
		{
			get
			{
				return false;
			}
		}
		#endregion
	}
}

namespace Castle.ActiveWriter
{
	/// <summary>
	/// Serializer ClassShapeSerializerBase for DomainClass ClassShape.
	/// </summary>
	public abstract partial class ClassShapeSerializerBase : DslDiagrams::CompartmentShapeSerializer
	{
		#region Constructor
		/// <summary>
		/// ClassShapeSerializerBase Constructor
		/// </summary>
		protected ClassShapeSerializerBase ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of ClassShape.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"classShape"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of ClassShape.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"classShapeMoniker"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of ClassShape in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"Id"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one ClassShape instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the ClassShape element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ClassShape instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					ActiveWriterSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							ActiveWriterSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ClassShape instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadElements(serializationContext, element, reader);
	
		}
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of ClassShape based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized ClassShape, a new ClassShape instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created ClassShape instance, or null if the reader is not pointing to a serialized ClassShape instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ClassShape" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "ClassShape".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						ClassShapeSerializerBase derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ClassShapeSerializerBase;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of ClassShape based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of ClassShape.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new ClassShape instance should be created.</param>	
		/// <returns>Created ClassShape instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (string.IsNullOrEmpty(idStr))
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					ActiveWriterSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				return new ClassShape(partition, new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id));
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				ActiveWriterSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				ActiveWriterSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				ActiveWriterSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from ClassShape, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from ClassShape.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ClassShape.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including ClassShape itself) instance of ClassShape based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ClassShape" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "ClassShape".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						ClassShapeSerializerBase derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ClassShapeSerializerBase;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of ClassShape based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				ActiveWriterSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			try
			{	// Normalize the Id.
				global::System.Guid id = new global::System.Guid(monikerString);
				monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
				DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, ClassShape.DomainClassId, partition.Store), partition.Store);
				// Set location info if possible.
				result.Location = serializationContext.Location;
				global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
				if (xmlLineInfo != null)
				{
					result.Line = xmlLineInfo.LineNumber;
					result.Column = xmlLineInfo.LinePosition;
				}
				return result;
			}
			catch (global::System.FormatException /* fEx */)
			{
				ActiveWriterSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
			catch (global::System.OverflowException /* oEx */)
			{	
				ActiveWriterSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from ClassShape, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from ClassShape.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ClassShape.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized ClassShape instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ClassShape instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the ClassShape instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the ClassShape instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one ClassShape instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ClassShape instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				ActiveWriterSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ClassShape instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WriteElements(serializationContext, element, writer);
	
		}
		
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given ClassShape instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ClassShape instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the ClassShape instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ClassShape instance = element as ClassShape;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ClassShape!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ClassShape instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	}
	
	/// <summary>
	/// Serializer ClassShapeSerializer for DomainClass ClassShape.
	/// </summary>
	public partial class ClassShapeSerializer : ClassShapeSerializerBase
	{
		#region Constructor
		/// <summary>
		/// ClassShapeSerializer Constructor
		/// </summary>
		public ClassShapeSerializer ()
			: base ()
		{
		}
		#endregion
	}
}

namespace Castle.ActiveWriter
{
	/// <summary>
	/// Serializer NestedClassShapeSerializerBase for DomainClass NestedClassShape.
	/// </summary>
	public abstract partial class NestedClassShapeSerializerBase : DslDiagrams::CompartmentShapeSerializer
	{
		#region Constructor
		/// <summary>
		/// NestedClassShapeSerializerBase Constructor
		/// </summary>
		protected NestedClassShapeSerializerBase ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of NestedClassShape.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"nestedClassShape"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of NestedClassShape.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"nestedClassShapeMoniker"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of NestedClassShape in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"Id"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one NestedClassShape instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the NestedClassShape element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory NestedClassShape instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					ActiveWriterSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							ActiveWriterSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory NestedClassShape instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadElements(serializationContext, element, reader);
	
		}
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of NestedClassShape based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized NestedClassShape, a new NestedClassShape instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created NestedClassShape instance, or null if the reader is not pointing to a serialized NestedClassShape instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "NestedClassShape" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "NestedClassShape".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						NestedClassShapeSerializerBase derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as NestedClassShapeSerializerBase;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of NestedClassShape based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of NestedClassShape.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new NestedClassShape instance should be created.</param>	
		/// <returns>Created NestedClassShape instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (string.IsNullOrEmpty(idStr))
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					ActiveWriterSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				return new NestedClassShape(partition, new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id));
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				ActiveWriterSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				ActiveWriterSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				ActiveWriterSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from NestedClassShape, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from NestedClassShape.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(NestedClassShape.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including NestedClassShape itself) instance of NestedClassShape based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "NestedClassShape" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "NestedClassShape".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						NestedClassShapeSerializerBase derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as NestedClassShapeSerializerBase;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of NestedClassShape based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = ActiveWriterSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				ActiveWriterSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			try
			{	// Normalize the Id.
				global::System.Guid id = new global::System.Guid(monikerString);
				monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
				DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, NestedClassShape.DomainClassId, partition.Store), partition.Store);
				// Set location info if possible.
				result.Location = serializationContext.Location;
				global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
				if (xmlLineInfo != null)
				{
					result.Line = xmlLineInfo.LineNumber;
					result.Column = xmlLineInfo.LinePosition;
				}
				return result;
			}
			catch (global::System.FormatException /* fEx */)
			{
				ActiveWriterSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
			catch (global::System.OverflowException /* oEx */)
			{	
				ActiveWriterSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from NestedClassShape, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from NestedClassShape.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(NestedClassShape.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized NestedClassShape instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">NestedClassShape instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the NestedClassShape instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the NestedClassShape instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			ActiveWriterSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one NestedClassShape instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">NestedClassShape instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				ActiveWriterSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">NestedClassShape instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WriteElements(serializationContext, element, writer);
	
		}
		
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given NestedClassShape instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">NestedClassShape instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the NestedClassShape instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			NestedClassShape instance = element as NestedClassShape;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of NestedClassShape!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">NestedClassShape instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	}
	
	/// <summary>
	/// Serializer NestedClassShapeSerializer for DomainClass NestedClassShape.
	/// </summary>
	public partial class NestedClassShapeSerializer : NestedClassShapeSerializerBase
	{
		#region Constructor
		/// <summary>
		/// NestedClassShapeSerializer Constructor
		/// </summary>
		public NestedClassShapeSerializer ()
			: base ()
		{
		}
		#endregion
	}
}

namespace Castle.ActiveWriter
{
	/// <summary>
	/// Serializer ManyToOneConnectorSerializer for DomainClass ManyToOneConnector.
	/// </summary>
	public partial class ManyToOneConnectorSerializer : DslDiagrams::BinaryLinkShapeSerializer
	{
		#region Constructor
		/// <summary>
		/// ManyToOneConnectorSerializer Constructor
		/// </summary>
		public ManyToOneConnectorSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of ManyToOneConnector.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"manyToOneConnector"; }
		}
	
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one ManyToOneConnector instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the ManyToOneConnector element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ManyToOneConnector instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					ActiveWriterSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						base.ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							ActiveWriterSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of ManyToOneConnector based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized ManyToOneConnector, a new ManyToOneConnector instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created ManyToOneConnector instance, or null if the reader is not pointing to a serialized ManyToOneConnector instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ManyToOneConnector" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "ManyToOneConnector".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						ManyToOneConnectorSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ManyToOneConnectorSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of ManyToOneConnector based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of ManyToOneConnector.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new ManyToOneConnector instance should be created.</param>	
		/// <returns>Created ManyToOneConnector instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			return new ManyToOneConnector(partition);
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from ManyToOneConnector, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from ManyToOneConnector.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ManyToOneConnector.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including ManyToOneConnector itself) instance of ManyToOneConnector based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ManyToOneConnector" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "ManyToOneConnector".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						ManyToOneConnectorSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ManyToOneConnectorSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of ManyToOneConnector based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			// Cannot be monikerized.
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from ManyToOneConnector, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from ManyToOneConnector.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ManyToOneConnector.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized ManyToOneConnector instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ManyToOneConnector instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the ManyToOneConnector instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the ManyToOneConnector instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			// Instance of ManyToOneConnector cannot be monikerized.
			ActiveWriterSerializationBehaviorSerializationMessages.CannotMonikerizeElement(serializationContext, "ManyToOneConnector");
		}
		
		/// <summary>
		/// Public Write() method that serializes one ManyToOneConnector instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ManyToOneConnector instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				ActiveWriterSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				base.WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given ManyToOneConnector instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ManyToOneConnector instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the ManyToOneConnector instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ManyToOneConnector instance = element as ManyToOneConnector;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ManyToOneConnector!");
	
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.CalculateQualifiedName(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ManyToOneConnector instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ManyToOneConnector instance = element as ManyToOneConnector;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ManyToOneConnector!");
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	}
}

namespace Castle.ActiveWriter
{
	/// <summary>
	/// Serializer ManyToManyConnectorSerializer for DomainClass ManyToManyConnector.
	/// </summary>
	public partial class ManyToManyConnectorSerializer : DslDiagrams::BinaryLinkShapeSerializer
	{
		#region Constructor
		/// <summary>
		/// ManyToManyConnectorSerializer Constructor
		/// </summary>
		public ManyToManyConnectorSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of ManyToManyConnector.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"manyToManyConnector"; }
		}
	
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one ManyToManyConnector instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the ManyToManyConnector element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ManyToManyConnector instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					ActiveWriterSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						base.ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							ActiveWriterSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of ManyToManyConnector based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized ManyToManyConnector, a new ManyToManyConnector instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created ManyToManyConnector instance, or null if the reader is not pointing to a serialized ManyToManyConnector instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ManyToManyConnector" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "ManyToManyConnector".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						ManyToManyConnectorSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ManyToManyConnectorSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of ManyToManyConnector based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of ManyToManyConnector.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new ManyToManyConnector instance should be created.</param>	
		/// <returns>Created ManyToManyConnector instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			return new ManyToManyConnector(partition);
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from ManyToManyConnector, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from ManyToManyConnector.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ManyToManyConnector.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including ManyToManyConnector itself) instance of ManyToManyConnector based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ManyToManyConnector" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "ManyToManyConnector".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						ManyToManyConnectorSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ManyToManyConnectorSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of ManyToManyConnector based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			// Cannot be monikerized.
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from ManyToManyConnector, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from ManyToManyConnector.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ManyToManyConnector.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized ManyToManyConnector instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ManyToManyConnector instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the ManyToManyConnector instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the ManyToManyConnector instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			// Instance of ManyToManyConnector cannot be monikerized.
			ActiveWriterSerializationBehaviorSerializationMessages.CannotMonikerizeElement(serializationContext, "ManyToManyConnector");
		}
		
		/// <summary>
		/// Public Write() method that serializes one ManyToManyConnector instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ManyToManyConnector instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				ActiveWriterSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				base.WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given ManyToManyConnector instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ManyToManyConnector instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the ManyToManyConnector instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ManyToManyConnector instance = element as ManyToManyConnector;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ManyToManyConnector!");
	
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.CalculateQualifiedName(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ManyToManyConnector instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ManyToManyConnector instance = element as ManyToManyConnector;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ManyToManyConnector!");
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	}
}

namespace Castle.ActiveWriter
{
	/// <summary>
	/// Serializer OneToOneConnectorSerializer for DomainClass OneToOneConnector.
	/// </summary>
	public partial class OneToOneConnectorSerializer : DslDiagrams::BinaryLinkShapeSerializer
	{
		#region Constructor
		/// <summary>
		/// OneToOneConnectorSerializer Constructor
		/// </summary>
		public OneToOneConnectorSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of OneToOneConnector.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"oneToOneConnector"; }
		}
	
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one OneToOneConnector instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the OneToOneConnector element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory OneToOneConnector instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					ActiveWriterSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						base.ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							ActiveWriterSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of OneToOneConnector based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized OneToOneConnector, a new OneToOneConnector instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created OneToOneConnector instance, or null if the reader is not pointing to a serialized OneToOneConnector instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "OneToOneConnector" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "OneToOneConnector".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						OneToOneConnectorSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as OneToOneConnectorSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of OneToOneConnector based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of OneToOneConnector.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new OneToOneConnector instance should be created.</param>	
		/// <returns>Created OneToOneConnector instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			return new OneToOneConnector(partition);
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from OneToOneConnector, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from OneToOneConnector.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(OneToOneConnector.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including OneToOneConnector itself) instance of OneToOneConnector based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "OneToOneConnector" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "OneToOneConnector".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						OneToOneConnectorSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as OneToOneConnectorSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of OneToOneConnector based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			// Cannot be monikerized.
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from OneToOneConnector, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from OneToOneConnector.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(OneToOneConnector.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized OneToOneConnector instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">OneToOneConnector instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the OneToOneConnector instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the OneToOneConnector instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			// Instance of OneToOneConnector cannot be monikerized.
			ActiveWriterSerializationBehaviorSerializationMessages.CannotMonikerizeElement(serializationContext, "OneToOneConnector");
		}
		
		/// <summary>
		/// Public Write() method that serializes one OneToOneConnector instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">OneToOneConnector instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				ActiveWriterSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				base.WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given OneToOneConnector instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">OneToOneConnector instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the OneToOneConnector instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			OneToOneConnector instance = element as OneToOneConnector;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of OneToOneConnector!");
	
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.CalculateQualifiedName(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">OneToOneConnector instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			OneToOneConnector instance = element as OneToOneConnector;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of OneToOneConnector!");
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	}
}

namespace Castle.ActiveWriter
{
	/// <summary>
	/// Serializer NestedConnectorSerializer for DomainClass NestedConnector.
	/// </summary>
	public partial class NestedConnectorSerializer : DslDiagrams::BinaryLinkShapeSerializer
	{
		#region Constructor
		/// <summary>
		/// NestedConnectorSerializer Constructor
		/// </summary>
		public NestedConnectorSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of NestedConnector.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"nestedConnector"; }
		}
	
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one NestedConnector instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the NestedConnector element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory NestedConnector instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					ActiveWriterSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						base.ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							ActiveWriterSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of NestedConnector based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized NestedConnector, a new NestedConnector instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created NestedConnector instance, or null if the reader is not pointing to a serialized NestedConnector instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "NestedConnector" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "NestedConnector".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						NestedConnectorSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as NestedConnectorSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of NestedConnector based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of NestedConnector.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new NestedConnector instance should be created.</param>	
		/// <returns>Created NestedConnector instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			return new NestedConnector(partition);
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from NestedConnector, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from NestedConnector.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(NestedConnector.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including NestedConnector itself) instance of NestedConnector based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "NestedConnector" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "NestedConnector".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						NestedConnectorSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as NestedConnectorSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of NestedConnector based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			// Cannot be monikerized.
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from NestedConnector, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from NestedConnector.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(NestedConnector.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized NestedConnector instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">NestedConnector instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the NestedConnector instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the NestedConnector instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			// Instance of NestedConnector cannot be monikerized.
			ActiveWriterSerializationBehaviorSerializationMessages.CannotMonikerizeElement(serializationContext, "NestedConnector");
		}
		
		/// <summary>
		/// Public Write() method that serializes one NestedConnector instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">NestedConnector instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				ActiveWriterSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				base.WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given NestedConnector instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">NestedConnector instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the NestedConnector instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			NestedConnector instance = element as NestedConnector;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of NestedConnector!");
	
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.CalculateQualifiedName(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">NestedConnector instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			NestedConnector instance = element as NestedConnector;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of NestedConnector!");
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	}
}

namespace Castle.ActiveWriter
{
	/// <summary>
	/// Serializer InheritanceConnectorSerializer for DomainClass InheritanceConnector.
	/// </summary>
	public partial class InheritanceConnectorSerializer : DslDiagrams::BinaryLinkShapeSerializer
	{
		#region Constructor
		/// <summary>
		/// InheritanceConnectorSerializer Constructor
		/// </summary>
		public InheritanceConnectorSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of InheritanceConnector.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"inheritanceConnector"; }
		}
	
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one InheritanceConnector instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the InheritanceConnector element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory InheritanceConnector instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					ActiveWriterSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						base.ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							ActiveWriterSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of InheritanceConnector based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized InheritanceConnector, a new InheritanceConnector instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created InheritanceConnector instance, or null if the reader is not pointing to a serialized InheritanceConnector instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "InheritanceConnector" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "InheritanceConnector".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						InheritanceConnectorSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as InheritanceConnectorSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of InheritanceConnector based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of InheritanceConnector.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new InheritanceConnector instance should be created.</param>	
		/// <returns>Created InheritanceConnector instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			return new InheritanceConnector(partition);
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from InheritanceConnector, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from InheritanceConnector.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(InheritanceConnector.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including InheritanceConnector itself) instance of InheritanceConnector based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "InheritanceConnector" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "InheritanceConnector".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						InheritanceConnectorSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as InheritanceConnectorSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of InheritanceConnector based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			// Cannot be monikerized.
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from InheritanceConnector, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from InheritanceConnector.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(InheritanceConnector.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized InheritanceConnector instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">InheritanceConnector instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the InheritanceConnector instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the InheritanceConnector instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			// Instance of InheritanceConnector cannot be monikerized.
			ActiveWriterSerializationBehaviorSerializationMessages.CannotMonikerizeElement(serializationContext, "InheritanceConnector");
		}
		
		/// <summary>
		/// Public Write() method that serializes one InheritanceConnector instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">InheritanceConnector instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				ActiveWriterSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				base.WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given InheritanceConnector instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">InheritanceConnector instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the InheritanceConnector instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			InheritanceConnector instance = element as InheritanceConnector;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of InheritanceConnector!");
	
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.CalculateQualifiedName(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">InheritanceConnector instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			InheritanceConnector instance = element as InheritanceConnector;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of InheritanceConnector!");
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	}
}

namespace Castle.ActiveWriter
{
	/// <summary>
	/// Serializer ActiveRecordMappingSerializer for DomainClass ActiveRecordMapping.
	/// </summary>
	public partial class ActiveRecordMappingSerializer : DslDiagrams::DiagramSerializer
	{
		#region Constructor
		/// <summary>
		/// ActiveRecordMappingSerializer Constructor
		/// </summary>
		public ActiveRecordMappingSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of ActiveRecordMapping.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"activeRecordMapping"; }
		}
	
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one ActiveRecordMapping instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the ActiveRecordMapping element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ActiveRecordMapping instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					ActiveWriterSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						base.ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							ActiveWriterSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of ActiveRecordMapping based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized ActiveRecordMapping, a new ActiveRecordMapping instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created ActiveRecordMapping instance, or null if the reader is not pointing to a serialized ActiveRecordMapping instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ActiveRecordMapping" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "ActiveRecordMapping".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						ActiveRecordMappingSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ActiveRecordMappingSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of ActiveRecordMapping based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of ActiveRecordMapping.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new ActiveRecordMapping instance should be created.</param>	
		/// <returns>Created ActiveRecordMapping instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			return new ActiveRecordMapping(partition);
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from ActiveRecordMapping, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from ActiveRecordMapping.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ActiveRecordMapping.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including ActiveRecordMapping itself) instance of ActiveRecordMapping based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ActiveRecordMapping" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "ActiveRecordMapping".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						ActiveRecordMappingSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ActiveRecordMappingSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of ActiveRecordMapping based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			// Cannot be monikerized.
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from ActiveRecordMapping, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from ActiveRecordMapping.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ActiveRecordMapping.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized ActiveRecordMapping instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ActiveRecordMapping instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the ActiveRecordMapping instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the ActiveRecordMapping instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			// Instance of ActiveRecordMapping cannot be monikerized.
			ActiveWriterSerializationBehaviorSerializationMessages.CannotMonikerizeElement(serializationContext, "ActiveRecordMapping");
		}
		
		/// <summary>
		/// Public Write() method that serializes one ActiveRecordMapping instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ActiveRecordMapping instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				ActiveWriterSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				base.WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given ActiveRecordMapping instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ActiveRecordMapping instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the ActiveRecordMapping instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ActiveRecordMapping instance = element as ActiveRecordMapping;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ActiveRecordMapping!");
	
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.CalculateQualifiedName(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ActiveRecordMapping instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ActiveRecordMapping instance = element as ActiveRecordMapping;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ActiveRecordMapping!");
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	}
}

namespace Castle.ActiveWriter
{
	/// <summary>
	/// A DomainXmlSerializationBehavior implementation for defined behavior ActiveWriterSerializationBehavior.
	/// This is the abstract base of the double-derived implementation.
	/// </summary>
	[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Generated code.")]		
	public abstract class ActiveWriterSerializationBehaviorBase : DslModeling::DomainXmlSerializationBehavior
	{
		///<summary>
		/// The xml namespace used by this domain model when serializing
		///</summary>
		public const string DomainModelXmlNamespace = @"http://schemas.microsoft.com/dsltools/ActiveWriter";
	
		#region Member Variables
		/// <summary>
		/// A list of DomainClass Ids mapped to DomainClassXmlSerializer types.
		/// </summary>
		private static global::System.Collections.Generic.List<DslModeling::DomainXmlSerializerDirectoryEntry> serializerTypes;
	
		/// <summary>
		/// A list of xml namespaces mapped to domain model types.
		/// </summary>
		private static global::System.Collections.Generic.List<DslModeling::DomainXmlSerializerNamespaceEntry> namespaceEntries;
	
		#endregion
	
		#region Constructor
		/// <summary>
		/// Protected constructor to prevent public instantiation.
		/// </summary>
		protected ActiveWriterSerializationBehaviorBase() : base() { }
		#endregion
		
		#region Protected Methods
		/// <summary>
		/// Allows custom serializers to be added.
		/// Base implementation doesn't do anything.
		/// </summary>
		/// <returns>Custom serializer types, null or empty list if there's no custom serializer types.</returns>
		[global::System.Diagnostics.DebuggerBrowsable(global::System.Diagnostics.DebuggerBrowsableState.Never)]
		protected virtual global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainXmlSerializerDirectoryEntry> CustomSerializerTypes
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return null; }
		}
		#endregion
	
		#region Public Methods
		/// <summary>
		/// This provides a mapping from DomainClass Id to DomainXmlSerializer implementation types.
		/// </summary>
		[global::System.Diagnostics.DebuggerBrowsable (global::System.Diagnostics.DebuggerBrowsableState.Never)]	// Will trigger creation otherwise.
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Generated code.")]		
		public override global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainXmlSerializerDirectoryEntry> AllSerializers
		{
			get
			{
				if (ActiveWriterSerializationBehavior.serializerTypes == null)
				{
					global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainXmlSerializerDirectoryEntry> customSerializerTypes = this.CustomSerializerTypes;
					int customSerializerCount = (customSerializerTypes == null ? 0 : customSerializerTypes.Count);
					ActiveWriterSerializationBehavior.serializerTypes = new global::System.Collections.Generic.List<DslModeling::DomainXmlSerializerDirectoryEntry>(23 + customSerializerCount);
	
					#region Serializers defined in this model
					ActiveWriterSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(Model.DomainClassId, typeof(ModelSerializer)));
					ActiveWriterSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(ModelClass.DomainClassId, typeof(ModelClassSerializer)));
					ActiveWriterSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(ModelProperty.DomainClassId, typeof(ModelPropertySerializer)));
					ActiveWriterSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(ModelElementWithAccess.DomainClassId, typeof(ModelElementWithAccessSerializer)));
					ActiveWriterSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(NamedElement.DomainClassId, typeof(NamedElementSerializer)));
					ActiveWriterSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(NestedClass.DomainClassId, typeof(NestedClassSerializer)));
					ActiveWriterSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(ModelHasClass.DomainClassId, typeof(ModelHasClassSerializer)));
					ActiveWriterSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(ManyToOneRelation.DomainClassId, typeof(ManyToOneRelationSerializer)));
					ActiveWriterSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(ClassHasProperty.DomainClassId, typeof(ClassHasPropertySerializer)));
					ActiveWriterSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(ManyToManyRelation.DomainClassId, typeof(ManyToManyRelationSerializer)));
					ActiveWriterSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(OneToOneRelation.DomainClassId, typeof(OneToOneRelationSerializer)));
					ActiveWriterSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(ModelHasNestedClasses.DomainClassId, typeof(ModelHasNestedClassesSerializer)));
					ActiveWriterSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(NestedClassHasProperties.DomainClassId, typeof(NestedClassHasPropertiesSerializer)));
					ActiveWriterSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(NestedClassReferencesModelClasses.DomainClassId, typeof(NestedClassReferencesModelClassesSerializer)));
					ActiveWriterSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(InheritanceRelation.DomainClassId, typeof(InheritanceRelationSerializer)));
					ActiveWriterSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(ClassShape.DomainClassId, typeof(ClassShapeSerializer)));
					ActiveWriterSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(NestedClassShape.DomainClassId, typeof(NestedClassShapeSerializer)));
					ActiveWriterSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(ManyToOneConnector.DomainClassId, typeof(ManyToOneConnectorSerializer)));
					ActiveWriterSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(ManyToManyConnector.DomainClassId, typeof(ManyToManyConnectorSerializer)));
					ActiveWriterSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(OneToOneConnector.DomainClassId, typeof(OneToOneConnectorSerializer)));
					ActiveWriterSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(NestedConnector.DomainClassId, typeof(NestedConnectorSerializer)));
					ActiveWriterSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(InheritanceConnector.DomainClassId, typeof(InheritanceConnectorSerializer)));
					ActiveWriterSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(ActiveRecordMapping.DomainClassId, typeof(ActiveRecordMappingSerializer)));
					#endregion
					
					// Custom ones
					if (customSerializerCount > 0)
					{
						ActiveWriterSerializationBehavior.serializerTypes.AddRange(customSerializerTypes);
					}
				}
				return ActiveWriterSerializationBehavior.serializerTypes.AsReadOnly();
			}
		}
		
		/// <summary>
		/// This provides a mapping from xml namespaces to domain model implementation types.
		/// </summary>
		[global::System.Diagnostics.DebuggerBrowsable (global::System.Diagnostics.DebuggerBrowsableState.Never)]	// Will trigger creation otherwise.
		//[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Generated code.")]		
		public override global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainXmlSerializerNamespaceEntry> AllNamespaces
		{
			get
			{
				if (ActiveWriterSerializationBehavior.namespaceEntries == null)
				{
					ActiveWriterSerializationBehavior.namespaceEntries = new global::System.Collections.Generic.List<DslModeling::DomainXmlSerializerNamespaceEntry>();
					ActiveWriterSerializationBehavior.namespaceEntries.Add(new DslModeling::DomainXmlSerializerNamespaceEntry(DomainModelXmlNamespace, typeof(global::Castle.ActiveWriter.ActiveWriterDomainModel)));
				}
				return ActiveWriterSerializationBehavior.namespaceEntries.AsReadOnly();
			}
		}
		
		#endregion
	}
	
	/// <summary>
	/// A DomainXmlSerializationBehavior implementation for defined behavior ActiveWriterSerializationBehavior.
	/// This is the concrete type of the double-derived implementation.
	/// </summary>
	public sealed partial class ActiveWriterSerializationBehavior : ActiveWriterSerializationBehaviorBase
	{
		#region Singleton Instance
		/// <summary>
		/// Singleton instance.
		/// </summary>
		private static ActiveWriterSerializationBehavior instance;
	
		/// <summary>
		/// Singleton instance.
		/// </summary>
		[global::System.Diagnostics.DebuggerBrowsable (global::System.Diagnostics.DebuggerBrowsableState.Never)]	// Will trigger creation otherwise.
		public static ActiveWriterSerializationBehavior Instance
		{
			get
			{	// No need for synchronization. Most likely running in single-thread environment, and creating an extra instance
				// doesn't really hurt.
				if (ActiveWriterSerializationBehavior.instance == null)
					ActiveWriterSerializationBehavior.instance = new ActiveWriterSerializationBehavior ();
				return ActiveWriterSerializationBehavior.instance;
			}
		}
	
		/// <summary>
		/// Private constructor to prevent public instantiation.
		/// </summary>
		private ActiveWriterSerializationBehavior() : base() { }
		#endregion
	}
}

namespace Castle.ActiveWriter
{
	/// <summary>
	/// Moniker resolver for serialization behavior ActiveWriterSerializationBehavior.
	/// </summary>
	public partial class ActiveWriterSerializationBehaviorMonikerResolver : ActiveWriterSerializationBehaviorMonikerResolverBase
	{
		/// <summary>
		/// Constructor.
		/// </summary>
		/// <param name="store">Store for this moniker resolver.</param>
		/// <param name="directory">Directory to used by this resolver to look up for serializers.</param>
		public ActiveWriterSerializationBehaviorMonikerResolver(DslModeling::Store store, DslModeling::DomainXmlSerializerDirectory directory)
			: base(store,directory)
		{
		}
	}
	
	/// <summary>
	/// Base moniker resolver for serialization behavior ActiveWriterSerializationBehavior.
	/// </summary>
	public partial class ActiveWriterSerializationBehaviorMonikerResolverBase : DslModeling::SimpleMonikerResolver
	{
		#region Member Variables
		/// <summary>
		/// Look-up directory to find serializers for domain classes.
		/// </summary>
		private DslModeling::DomainXmlSerializerDirectory directory;
		#endregion
	
		#region Constructor
		/// <summary>
		/// Constructor.
		/// </summary>
		/// <param name="store">Store for this moniker resolver.</param>
		/// <param name="directory">Directory to used by this resolver to look up for serializers.</param>
		public ActiveWriterSerializationBehaviorMonikerResolverBase(DslModeling::Store store, DslModeling::DomainXmlSerializerDirectory directory)
			: base (store)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException("directory");
			#endregion
	
			this.directory = directory;
		}
		#endregion
	
		#region Base Overrides
		/// <summary>
		/// Tells if a DomainClass can be monikerized or not.
		/// </summary>
		/// <param name="domainClassInfo">DomainClassInfo of the DomainClass to be checked.</param>
		/// <returns>True if the DomainClass can be monikerized, false otherwise.</returns>
		protected override bool CanBeMonikerized(DslModeling::DomainClassInfo domainClassInfo)
		{
			if (this.IsDisposed || this.directory == null || domainClassInfo == null)
				return false;
				
			DslModeling::DomainClassXmlSerializer serializer = this.directory.GetSerializer(domainClassInfo.Id);
			if (serializer != null)
				return (!string.IsNullOrEmpty(serializer.MonikerTagName));
			return false;
		}
			
		/// <summary>
		/// Calculate the fully qualified monikerized string of the given ModelElement.
		/// </summary>
		/// <param name="mel">ModelElement to get moniker from.</param>
		/// <returns>Calculated moniker string, returns null or empty string is the given ModelElement cannot be monikerized.</returns>
		protected override string CalculateQualifiedName(DslModeling::ModelElement mel)
		{
			if (this.IsDisposed || this.directory == null || mel == null)
				return string.Empty;
	
			string result = string.Empty;
			DslModeling::DomainClassXmlSerializer serializer = this.directory.GetSerializer(mel.GetDomainClass().Id);
			if (serializer != null)
				result = serializer.CalculateQualifiedName(this.directory, mel);
			return result;
		}
		
		/// <summary>
		/// Called at the end of synchronization when they're unresolved monikers.
		/// </summary>
		/// <param name="serializationResult">SerializationResult to store error/warning messages.</param>
		/// <param name="moniker">Unresolved moniker.</param>
		protected override void OnUnresolvedMoniker(DslModeling::SerializationResult serializationResult, DslModeling::Moniker moniker)
		{
			if (serializationResult != null)
			{
				ActiveWriterSerializationBehaviorSerializationMessages.UnresolvedMoniker(serializationResult, moniker);
			}
		}
		
		/// <summary>
		/// Called when resolving a moniker causes a duplicate link to be created.
		/// </summary>
		/// <param name="serializationResult">SerializationResult to store error/warning messages.</param>
		/// <param name="moniker">Moniker that causes duplicate link to be created.</param>
		protected override void OnMonikerResolvedToDuplicateLink(DslModeling::SerializationResult serializationResult, DslModeling::Moniker moniker)
		{
			if (serializationResult != null)
			{
				ActiveWriterSerializationBehaviorSerializationMessages.MonikerResolvedToDuplicateLink(serializationResult, moniker);
			}
			base.OnMonikerResolvedToDuplicateLink(serializationResult, moniker);
		}
		
		/// <summary>
		/// Called when two new elements are giving the same moniker, which will cause ambiguity during moniker resolution.
		/// </summary>
		/// <param name="context">SerializationContext to store error/warning messages.</param>
		/// <param name="moniker">Moniker that both elements give.</param>
		/// <param name="element1">The first element giving the moniker.</param>
		/// <param name="element2">The second element giving the same moniker.</param>
		protected override void OnAmbiguousMoniker(DslModeling::SerializationContext context, string moniker, DslModeling::ModelElement element1, DslModeling::ModelElement element2)
		{
			if (context != null)
			{
				ActiveWriterSerializationBehaviorSerializationMessages.AmbiguousMoniker(context, moniker, element1, element2);
			}
			base.OnAmbiguousMoniker(context, moniker, element1, element2);
		}
		
		/// <summary>
		/// Error message for UnresolvedMonikerException.
		/// </summary>
		[global::System.Diagnostics.DebuggerBrowsable(global::System.Diagnostics.DebuggerBrowsableState.Never)]
		protected override string UnresolvedMonikerExceptionMessage
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return ActiveWriterSerializationBehaviorSerializationMessages.ResourceManager.GetString("CannotOpenDocument"); }
		}
		#endregion
	}
}

namespace Castle.ActiveWriter
{
	/// <summary>
	/// Utility class to provide serialization messages
	/// </summary>
	public static partial class ActiveWriterSerializationBehaviorSerializationMessages
	{
		/// <summary>
		/// ResourceManager to get serialization messages from.
		/// </summary>
		[global::System.Diagnostics.DebuggerBrowsable(global::System.Diagnostics.DebuggerBrowsableState.Never)] // Will trigger creation otherwise.
		public static global::System.Resources.ResourceManager ResourceManager
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return ActiveWriterDomainModel.SingletonResourceManager; }
		}
	
		#region Warnings
		/// <summary>
		/// Add a warning for ambiguous schemas.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the warning message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="targetNamespace">Target namespace to be resolved.</param>
		/// <param name="schemaPath">The schema that is used to resolve the definition of the target namespace.</param>
		public static void AmbiguousSchema(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, string targetNamespace, string schemaPath)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(targetNamespace));
			if (string.IsNullOrEmpty(targetNamespace))
				throw new global::System.ArgumentNullException("targetNamespace");
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(schemaPath));
			if (string.IsNullOrEmpty(schemaPath))
				throw new global::System.ArgumentNullException("schemaPath");
			#endregion
	
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Warning,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("AmbiguousSchema"),
					targetNamespace,
					schemaPath
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		
		/// <summary>
		/// Add a warning when a full-form relationship seems to be serialized in short-form.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the warning message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="relationshipType">Type of the relationship.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters", Justification = "This is the type of the relationship, making it MemberInfo only adds confusion.")]
		public static void ExpectingFullFormRelationship(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, global::System.Type relationshipType)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			global::System.Diagnostics.Debug.Assert(relationshipType != null);
			if (relationshipType == null)
				throw new global::System.ArgumentNullException("relationshipType");
			#endregion
			
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Warning,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("ExpectingFullFormRelationship"),
					reader.Name,
					relationshipType.Name
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		
		/// <summary>
		/// Add a warning when a short-form relationship seems to be serialized in full-form.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the warning message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="relationshipType">Type of the relationship.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters", Justification = "This is the type of the relationship, making it MemberInfo only adds confusion.")]
		public static void ExpectingShortFormRelationship(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, global::System.Type relationshipType)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			global::System.Diagnostics.Debug.Assert(relationshipType != null);
			if (relationshipType == null)
				throw new global::System.ArgumentNullException("relationshipType");
			#endregion
			
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Warning,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("ExpectingShortFormRelationship"),
					relationshipType.Name
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		
		/// <summary>
		/// Add a warning for invalid property value with the given type, which will be ignored.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the warning message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="propertyName">Name of the property.</param>
		/// <param name="propertyType">Type of the property.</param>
		/// <param name="value">Invalid value that causes this warning.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters", Justification = "This is the type of the property, making it MemberInfo only adds confusion.")]
		public static void IgnoredPropertyValue(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, string propertyName, global::System.Type propertyType, string value)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			global::System.Diagnostics.Debug.Assert(propertyType != null);
			if (propertyType == null)
				throw new global::System.ArgumentNullException("propertyType");
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(propertyName));
			if (string.IsNullOrEmpty(propertyName))
				throw new global::System.ArgumentNullException("propertyName");
			#endregion
			
			if (value == null)
				value = "<null>";
	
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Warning,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("IgnoredPropertyValue"),
					value,
					propertyName,
					propertyType.Name
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		
		/// <summary>
		/// Add a warning for missing "Id" property.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the warning message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="newId">Auto-generated new Id.</param>
		public static void MissingId(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, global::System.Guid newId)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			#endregion
			
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Warning,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("MissingId"),
					newId.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture)
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		
			
		/// <summary>
		/// Add an warning for moniker resolved to duplicate link. The moniker will be ignored.
		/// </summary>
		/// <param name="serializationResult">SerializationResult to add the error message to.</param>
		/// <param name="moniker">Offending moniker.</param>
		public static void MonikerResolvedToDuplicateLink(DslModeling::SerializationResult serializationResult, DslModeling::Moniker moniker)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationResult != null);
			if (serializationResult == null)
				throw new global::System.ArgumentNullException("serializationResult");
			global::System.Diagnostics.Debug.Assert(moniker != null);
			if (moniker == null)
				throw new global::System.ArgumentNullException("moniker");
			#endregion
			
			DslModeling::SerializationUtilities.AddMessage(
				serializationResult,
				moniker.Location,
				DslModeling::SerializationMessageKind.Warning,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("MonikerResolvedToDuplicateLink"),
					moniker.MonikerName
				),
				moniker.Line,
				moniker.Column
			);
		}
		
		/// <summary>
		/// Add a warning for no schema found for the given target namespace, schema validation will be skipped in this case.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the warning message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="targetNamespace">Target namespace that cannot be resolved.</param>
		public static void NoSchema(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, string targetNamespace)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(targetNamespace));
			if (string.IsNullOrEmpty(targetNamespace))
				throw new global::System.ArgumentNullException("targetNamespace");
			#endregion
	
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Warning,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("NoSchema"),
					targetNamespace
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		
		/// <summary>
		/// Add a warning for schema validation error.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the warning message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="message">Validation message reported from schema validation.</param>
		public static void SchemaValidationError(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, string message)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(message));
			if (string.IsNullOrEmpty(message))
				throw new global::System.ArgumentNullException("message");
			#endregion
	
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Warning,
				message,
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		
		/// <summary>
		/// Add an warning for unexpected XML element.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the warning message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		public static void UnexpectedXmlElement(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			#endregion
				
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Warning,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("UnexpectedXmlElement"),
					reader.Name
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		#endregion
	
		#region Errors
		/// <summary>
		/// Add an error for ambiguous moniker.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the error message to.</param>
		/// <param name="moniker">The ambiguous moniker string.</param>
		/// <param name="element1">The first element using the given moniker.</param>
		/// <param name="element2">The second element using the given moniker.</param>
		public static void AmbiguousMoniker(DslModeling::SerializationContext serializationContext, string moniker, DslModeling::ModelElement element1, DslModeling::ModelElement element2)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(moniker != null);
			if (moniker == null)
				throw new global::System.ArgumentNullException("moniker");
			global::System.Diagnostics.Debug.Assert(element1 != null);
			if (element1 == null)
				throw new global::System.ArgumentNullException("element1");
			global::System.Diagnostics.Debug.Assert(element2 != null);
			if (element2 == null)
				throw new global::System.ArgumentNullException("element2");
			#endregion
	
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Error,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("AmbiguousMoniker"),
					moniker,
					DslModeling::SerializationUtilities.GetElementName(element1),
					DslModeling::SerializationUtilities.GetElementName(element2)
				),
				null	// No location info available
			);
		}
		
		/// <summary>
		/// Add an error for not able to monikerize an instance of the given DomainClass.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the error message to.</param>
		/// <param name="domainClassName">Name of the DomainClass whose instance cannot be monikerized.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Justification = "Generated code.")]	
		public static void CannotMonikerizeElement(DslModeling::SerializationContext serializationContext, string domainClassName)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(domainClassName));
			if (string.IsNullOrEmpty(domainClassName))
				throw new global::System.ArgumentNullException("domainClassName");
			#endregion
			
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext.Result,
				null,	/* no location available for this error, because save failed. */
				DslModeling::SerializationMessageKind.Error,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("CannotMonikerizeElement"),
					domainClassName
				),
				0,
				0
			);
		}
		
		/// <summary>
		/// Add an error for dangling relationship instance.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the error message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="relationshipType">Type name of the relationship.</param>
		public static void DanglingRelationship(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, string relationshipType)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(relationshipType));
			if (string.IsNullOrEmpty(relationshipType))
				throw new global::System.ArgumentNullException("relationshipType");
			#endregion
			
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Error,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("DanglingRelationship"),
					relationshipType
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		
		/// <summary>
		/// Add an error for invalid property value with given type.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the error message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="propertyName">Name of the property.</param>
		/// <param name="propertyType">Type of the property.</param>
		/// <param name="value">Invalid value that causes this error.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters", Justification = "This is the type of the property, making it MemberInfo only adds confusion.")]
		public static void InvalidPropertyValue(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, string propertyName, global::System.Type propertyType, string value)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			global::System.Diagnostics.Debug.Assert(propertyType != null);
			if (propertyType == null)
				throw new global::System.ArgumentNullException("propertyType");
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(propertyName));
			if (string.IsNullOrEmpty(propertyName))
				throw new global::System.ArgumentNullException("propertyName");
			#endregion
			
			if (value == null)
				value = "<null>";
	
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Error,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("InvalidPropertyValue"),
					value,
					propertyName,
					propertyType.Name
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		
		/// <summary>
		/// Add an error for missing moniker.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the error message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="monikerAttributeName">Name of the attribute that should hold the moniker.</param>
		public static void MissingMoniker(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, string monikerAttributeName)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerAttributeName));
			if (string.IsNullOrEmpty(monikerAttributeName))
				throw new global::System.ArgumentNullException("monikerAttributeName");
			#endregion
			
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Error,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("MissingMoniker"),
					monikerAttributeName
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		
		/// <summary>
		/// Add an error for unresolved moniker.
		/// </summary>
		/// <param name="serializationResult">SerializationResult to add the error message to.</param>
		/// <param name="moniker">Unresolved moniker.</param>
		public static void UnresolvedMoniker(DslModeling::SerializationResult serializationResult, DslModeling::Moniker moniker)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationResult != null);
			if (serializationResult == null)
				throw new global::System.ArgumentNullException("serializationResult");
			global::System.Diagnostics.Debug.Assert(moniker != null);
			if (moniker == null)
				throw new global::System.ArgumentNullException("moniker");
			#endregion
			
			DslModeling::SerializationUtilities.AddMessage(
				serializationResult,
				moniker.Location,
				DslModeling::SerializationMessageKind.Error,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("UnresolvedMoniker"),
					moniker.MonikerName
				),
				moniker.Line,
				moniker.Column
			);
		}
	
		/// <summary>
		/// Add an error for Version mismatch.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the error message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="expectedVersion">The version that's expected.</param>
		/// <param name="actualVersion">Actual version from the file.</param>
		public static void VersionMismatch(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, global::System.Version expectedVersion, global::System.Version actualVersion)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			global::System.Diagnostics.Debug.Assert(expectedVersion != null);
			if (expectedVersion == null)
				throw new global::System.ArgumentNullException("expectedVersion");
			global::System.Diagnostics.Debug.Assert(actualVersion != null);
			if (actualVersion == null)
				throw new global::System.ArgumentNullException("actualVersion");
			#endregion
			
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Error,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("VersionMismatch"), 
					actualVersion.ToString(4), 
					expectedVersion.ToString(4)
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		#endregion
	}
}
namespace Castle.ActiveWriter
{
	/// <summary>
	/// Provides an implementation of the IDomainModelSerializer interface
	/// that can be used to serialize / deserialize the ActiveWriter domain model.
	/// </summary>
	/// <remarks>Double-derived class - the default implementation is in ActiveWriterDomainModelSerializerBase.
	/// This class exist so users can customize behavior easily.</remarks>
	[global::System.ComponentModel.Composition.Export(typeof(DslModeling::IDomainModelSerializer))]
	[DslModeling::DomainModelSerializer(typeof(global::Castle.ActiveWriter.ActiveWriterDomainModel), global::Castle.ActiveWriter.ActiveWriterSerializationBehavior.DomainModelXmlNamespace, "actiw")]
	public partial class ActiveWriterDomainModelSerializer : ActiveWriterDomainModelSerializerBase
	{
	}
	
	
	/// <summary>
	/// Base class that implements IDomainModelSerializer
	/// </summary>
	public abstract partial class ActiveWriterDomainModelSerializerBase : DslModeling::IDomainModelSerializer
	{
	
		#region Public properties
	
		/// <summary>
		/// The XML namespace used when serializing the domain model
		/// </summary>
		public virtual string DomainModelNamespace
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return global::Castle.ActiveWriter.ActiveWriterSerializationBehavior.DomainModelXmlNamespace; }
		}
	
		/// <summary>
		/// Returns true: this DSL can be serialized / deserialized directly.
		/// </summary>
		public virtual bool IsSerializable
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return true; }
		}
	
		/// <summary>
		/// The type of the domain model
		/// </summary>
		public virtual global::System.Type DomainModelType
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return typeof(global::Castle.ActiveWriter.ActiveWriterDomainModel); }
		}
	
		/// <summary>
		/// File extension used for model files of this kind of domain model
		/// </summary>
		/// <remarks>If a domain model type cannot be serialized independently, or cannot
		/// be serialized to a file, it should return null or empty.</remarks>
		public string ModelFileExtension
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return "actiw"; }
		}
	
		#endregion
		
		
		#region Load / Save model methods
		
		/// <summary>
		/// Loads a Model instance and its associated diagram file.
		/// </summary>
		/// <param name="serializationResult">Stores serialization result from the load operation.</param>
		/// <param name="partition">Partition in which the new Model instance will be created.</param>
		/// <param name="fileName">Name of the file from which the Model instance will be deserialized.</param>
		/// <param name="serializerLocator">Used to locate any additional domain model types required to load the model. Can be null.</param>
		/// <returns>The loaded Model instance.</returns>
		public virtual DslModeling::ModelElement LoadModel(DslModeling::SerializationResult serializationResult, 
			DslModeling::Partition partition, 
			string fileName, 
			DslModeling::ISerializerLocator serializerLocator)
		{
			if (serializationResult == null) { throw new global::System.ArgumentNullException("serializationResult"); }
			if (partition == null) { throw new global::System.ArgumentNullException("partition"); }
			if (string.IsNullOrEmpty(fileName)) { throw new global::System.ArgumentNullException("fileName"); }
	
			return ActiveWriterSerializationHelper.Instance.LoadModel(serializationResult, partition, fileName, null, null, serializerLocator);
		}
	
		/// <summary>
		/// Saves the given model root to the given file, with specified encoding.
		/// </summary>
		/// <param name="serializationResult">Stores serialization result from the save operation.</param>
		/// <param name="modelRoot">Model instance to be saved.</param>
		/// <param name="fileName">Name of the file in which the Model instance will be saved.</param>
		/// <param name="encoding">Encoding to use when saving the Model instance.</param>
		public void SaveModel(DslModeling::SerializationResult serializationResult, 
			DslModeling::ModelElement modelRoot, 
			string fileName, 
			System.Text.Encoding encoding)
		{
			if (serializationResult == null) { throw new global::System.ArgumentNullException("serializationResult"); }
			if (modelRoot == null) { throw new global::System.ArgumentNullException("modelRoot"); }
			if (string.IsNullOrEmpty("fileName")) { throw new global::System.ArgumentNullException("fileName"); }
	
			global::Castle.ActiveWriter.Model rootElement = modelRoot as global::Castle.ActiveWriter.Model;
			if (rootElement == null)
			{
				string errorMessage = string.Format(global::System.Globalization.CultureInfo.CurrentCulture,
					global::Castle.ActiveWriter.ActiveWriterDomainModel.SingletonResourceManager.GetString("InvalidSaveRootElementType"),
					modelRoot.GetType().ToString());
	
				throw new global::System.ArgumentException(errorMessage, "modelRoot");
	
			}
	
			ActiveWriterSerializationHelper.Instance.SaveModel(serializationResult, rootElement, fileName,encoding, true);
		}
	
		#endregion
	
		#region Load / Save model and diagram methods
	
		/// <summary>
		/// Calculates and returns the name of the diagram file for the specified model file
		/// </summary>
		/// <param name="modelFileName">The relevant model file name</param>
		/// <returns>Name of the associated diagram file</returns>
		/// <remarks>There is no guarantee that either the model file or the calculated diagram file exist.</remarks>
		public virtual string CalculateDiagramFileName(string modelFileName)
		{
			if (string.IsNullOrEmpty(modelFileName))
			{
				throw new global::System.ArgumentNullException("modelFileName");
			}
			return modelFileName + ".diagram";
		}
	
		/// <summary>
		/// Loads a Model instance and its associated diagram file.
		/// </summary>
		/// <param name="serializationResult">Stores serialization result from the load operation.</param>
		/// <param name="modelPartition">Partition in which the new Model instance will be created.</param>
		/// <param name="modelFileName">Name of the file from which the Model instance will be deserialized.</param>
		/// <param name="diagramPartition">Partition in which the new ActiveRecordMapping instance will be created.</param>
		/// <param name="diagramFileName">Name of the file from which the ActiveRecordMapping instance will be deserialized.</param>
		/// <param name="serializerLocator">Used to locate any additional domain model types required to load the model. Can be null.</param>
		/// <returns>The loaded Model instance.</returns>
		public DslModeling::ModelElement LoadModelAndDiagram(DslModeling::SerializationResult serializationResult, 
			DslModeling::Partition modelPartition, 
			string modelFileName, 
			DslModeling::Partition diagramPartition, 
			string diagramFileName, 
			DslModeling::ISerializerLocator serializerLocator)
		{
			if (serializationResult == null) { throw new global::System.ArgumentNullException("serializationResult"); }
			if (modelPartition == null) { throw new global::System.ArgumentNullException("modelPartition"); }
			if (string.IsNullOrEmpty(modelFileName)) { throw new global::System.ArgumentNullException("modelFileName"); }
			if (diagramPartition == null) { throw new global::System.ArgumentNullException("diagramPartition"); }
			if (string.IsNullOrEmpty(diagramFileName)) { throw new global::System.ArgumentNullException("diagramFileName"); }
	
			return ActiveWriterSerializationHelper.Instance.LoadModelAndDiagram(serializationResult, modelPartition, modelFileName, diagramPartition, diagramFileName, null, null, serializerLocator);
		}
	
		/// <summary>
		/// Saves the given Model and ActiveRecordMapping to the given files, with specified encoding.
		/// </summary>
		/// <param name="serializationResult">Stores serialization result from the save operation.</param>
		/// <param name="modelRoot">Model instance to be saved.</param>
		/// <param name="modelFileName">Name of the file in which the CanonicalSampleRoot instance will be saved.</param>
		/// <param name="diagram">ActiveRecordMapping to be saved.</param>
		/// <param name="diagramFileName">Name of the file in which the diagram will be saved.</param>
		/// <param name="encoding">Encoding to use when saving the diagram.</param>
		public void SaveModelAndDiagram(DslModeling::SerializationResult serializationResult, 
			DslModeling::ModelElement modelRoot, 
			string modelFileName, 
			DslModeling::ModelElement diagram, 
			string diagramFileName, 
			System.Text.Encoding encoding)
		{
			if (serializationResult == null) { throw new global::System.ArgumentNullException("serializationResult"); }
			if (modelRoot == null) { throw new global::System.ArgumentNullException("modelRoot"); }
			if (string.IsNullOrEmpty("modelFileName")) { throw new global::System.ArgumentNullException("modelFileName"); }
			if (diagram == null) { throw new global::System.ArgumentNullException("diagram"); }
			if (string.IsNullOrEmpty("diagramFileName")) { throw new global::System.ArgumentNullException("diagramFileName"); }
	
			global::Castle.ActiveWriter.Model typedRoot = modelRoot as global::Castle.ActiveWriter.Model;
			if (typedRoot == null)
			{
				string errorMessage = string.Format(global::System.Globalization.CultureInfo.CurrentCulture,
					global::Castle.ActiveWriter.ActiveWriterDomainModel.SingletonResourceManager.GetString("InvalidSaveRootElementType"),
					modelRoot.GetType().ToString());
	
				throw new global::System.ArgumentException(errorMessage, "modelRoot");
			}
			global::Castle.ActiveWriter.ActiveRecordMapping typedDiagram = diagram as global::Castle.ActiveWriter.ActiveRecordMapping;
			if (typedDiagram == null)
			{
				string errorMessage = string.Format(global::System.Globalization.CultureInfo.CurrentCulture,
					global::Castle.ActiveWriter.ActiveWriterDomainModel.SingletonResourceManager.GetString("InvalidSaveDiagramType"),
					diagram.GetType().ToString());
	
				throw new global::System.ArgumentException(errorMessage, "diagram");
			}
	
			ActiveWriterSerializationHelper.Instance.SaveModelAndDiagram(serializationResult, typedRoot, modelFileName, typedDiagram, diagramFileName, encoding, true);
		}
	
		#endregion
		
	}
}


